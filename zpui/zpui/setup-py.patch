diff --git a/setup.py b/setup.py
new file mode 100644
index 0000000..ce36cc3
--- /dev/null
+++ b/setup.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+import os
+from setuptools import setup, find_packages
+
+def read(fname):
+    return open(os.path.join(os.path.dirname(__file__), fname)).read()
+
+setup(
+    name = "ZPUI",
+    version = "0.0.1",
+    description = ("Official ZeroPhone UI framework, based on pyLCI"),
+    license = "Apache",
+    keywords = "zpui zerophone",
+    url = "http://zpui.rtfd.org",
+    long_description = read('README.md'),
+    packages = find_packages(),
+    install_requires = [
+		'luma.oled',
+		'python-nmap',
+		'smspdu',
+		'zerophone_hw>=0.3.0',
+		'gpio',
+		'vobject',
+		'pytest',
+		'mock',
+		'pydbus',
+		'pyotp',
+		'jsonrpclib',
+		'smbus2',
+		'pygame',
+		'serial',
+		'pygobject',
+	],
+    classifiers = [
+        "Development Status :: 1 - Planning",
+        "Development Status :: 2 - Pre-Alpha",
+        "Development Status :: 3 - Alpha",
+        "Environment :: Other Environment",
+        "Intended Audience :: End Users/Desktop",
+        "License :: OSI Approved :: Apache Software License",
+        "Natural Language :: English",
+        "Operating System :: POSIX :: Linux",
+        "Programming Language :: Python :: 2",
+        "Programming Language :: Python :: 2.7",
+        "Topic :: Desktop Environment :: Window Managers",
+        "Topic :: System :: System Shells"
+    ],
+	include_package_data = True,
+	entry_points = {
+		'gui_scripts': [
+			'zpui = zpui.main:init',
+		],
+	}
+)
diff --git a/__init__.py b/zpui/__init__.py
similarity index 100%
rename from __init__.py
rename to zpui/__init__.py
diff --git a/zpui/apps/__init__.py b/zpui/apps/__init__.py
new file mode 100644
index 0000000..b4994e5
--- /dev/null
+++ b/zpui/apps/__init__.py
@@ -0,0 +1,18 @@
+_ordering = [
+"personal", 
+"network_apps",
+"phone",
+"hardware_apps",
+"games",
+"privacy_apps",
+"system_apps", 
+"media_apps", 
+"raspberrypi", 
+"ee_apps", 
+"utils", 
+"scripts", 
+"clock", 
+"update"]
+
+
+from zero_app import ZeroApp
diff --git a/zpui/apps/app_manager.py b/zpui/apps/app_manager.py
new file mode 100755
index 0000000..05d8395
--- /dev/null
+++ b/zpui/apps/app_manager.py
@@ -0,0 +1,256 @@
+import importlib
+import os
+import traceback
+
+from apps import zero_app
+from helpers import setup_logger
+from ui import Printer, Menu
+
+logger = setup_logger(__name__, "info")
+
+
+class ListWithMetadata(list):
+    ordering_alias = None
+
+
+class AppManager(object):
+    subdir_menus = {}
+    """ Example of subdir_menus:
+    {'apps/network_apps': <ui.menu.Menu instance at 0x7698ac10>, 
+    ...
+    'apps/system_apps': <ui.menu.Menu instance at 0x7698abc0>}
+    """
+    app_list = {}
+    """Example of app_list:
+    {'apps/network_apps/wpa_cli': <module 'apps.network_apps.wpa_cli.main' from '/root/WCS/apps/network_apps/wpa_cli/main.py'>, 
+    'apps/system_apps/system': <module 'apps.system_apps.system.main' from '/root/WCS/apps/system_apps/system/main.py'>, 
+    ...
+    'apps/network_apps/network': <module 'apps.network_apps.network.main' from '/root/WCS/apps/network_apps/network/main.py'>}
+     """
+    ordering_cache = {}
+
+    def __init__(self, app_directory, context_manager, config=None):
+        self.app_directory = app_directory
+        self.cm = context_manager
+        self.i, self.o = self.cm.get_io_for_context("main")
+        self.config = config if config else {}
+
+    def load_all_apps(self):
+        base_menu = Menu([], self.i, self.o, "Main app menu",
+                                    exitable=False)  # Main menu for all applications.
+        base_menu.exit_entry = ["Exit", "exit"]
+        base_menu.process_contents()
+        self.subdir_menus[self.app_directory] = base_menu
+        apps_blocked_in_config = self.config.get("do_not_load", {})
+        for path, subdirs, modules in app_walk(self.app_directory):
+            for subdir in subdirs:
+                # First, we create subdir menus (not yet linking because they're not created in correct order) and put them in subdir_menus.
+                subdir_path = os.path.join(path, subdir)
+                self.subdir_menus[subdir_path] = Menu([], self.i, self.o, subdir_path)
+            for _module in modules:
+                # Then, we load modules and store them along with their paths
+                try:
+                    module_path = os.path.join(path, _module)
+                    if module_path in apps_blocked_in_config:
+                        logger.warning("App {} blocked from config; not loading".format(module_path))
+                        continue
+                    app = self.load_app(module_path)
+                    logger.info("Loaded app {}".format(module_path))
+                    self.app_list[module_path] = app
+                except Exception as e:
+                    logger.error("Failed to load app {}".format(module_path))
+                    logger.error(traceback.format_exc())
+                    Printer(["Failed to load", os.path.split(module_path)[1]], self.i, self.o, 2)
+        for subdir_path in self.subdir_menus:
+            # Now it's time to link menus to parent menus
+            if subdir_path == self.app_directory:
+                continue
+            parent_path = os.path.split(subdir_path)[0]
+            ordering = self.get_ordering(parent_path)
+            parent_menu = self.subdir_menus[parent_path]
+            subdir_menu = self.subdir_menus[subdir_path]
+            subdir_menu_name = self.get_subdir_menu_name(subdir_path)
+            # Inserting by the ordering given
+            parent_menu_contents = self.insert_by_ordering([subdir_menu_name, subdir_menu.activate],
+                                                           os.path.split(subdir_path)[1], parent_menu.contents,
+                                                           ordering)
+            parent_menu.set_contents(parent_menu_contents)
+        for app_path in self.app_list:
+            # Last thing is attaching applications to the menu structure created.
+            app = self.app_list[app_path]
+            subdir_path, app_dirname = os.path.split(app_path)
+            ordering = self.get_ordering(subdir_path)
+            menu_name = app.menu_name if hasattr(app, "menu_name") else app_dirname.capitalize()
+            self.bind_callback(app, app_path, menu_name, ordering, subdir_path)
+        return base_menu
+
+    def bind_callback(self, app, app_path, menu_name, ordering, subdir_path):
+        if hasattr(app, "callback") and callable(app.callback):  # for function based apps
+            app_callback = app.callback
+        elif hasattr(app, "on_start") and callable(app.on_start):  # for class based apps
+            app_callback = app.on_start
+        else:
+            logger.debug("App \"{}\" has no callback; loading silently".format(menu_name))
+            return
+        self.cm.register_context_target(app_path, app_callback)
+        menu_callback = lambda: self.cm.switch_to_context(app_path)
+        #App callback is available and wrapped, inserting
+        subdir_menu = self.subdir_menus[subdir_path]
+        subdir_menu_contents = self.insert_by_ordering([menu_name, menu_callback], os.path.split(app_path)[1],
+                                                       subdir_menu.contents, ordering)
+        subdir_menu.set_contents(subdir_menu_contents)
+
+    def get_app_path_for_cmdline(self, cmdline_app_path):
+        main_py_string = "/main.py"
+        if cmdline_app_path.endswith(main_py_string):
+            app_path = cmdline_app_path[:-len(main_py_string)]
+        elif cmdline_app_path.endswith("/"):
+            app_path = cmdline_app_path[:-1]
+        else:
+            app_path = cmdline_app_path
+        return app_path
+
+    def load_app(self, app_path, threaded = True):
+        if "__init__.py" not in os.listdir(app_path):
+            raise ImportError("Trying to import an app with no __init__.py in its folder!")
+        app_import_path = app_path.replace('/', '.')
+        # If user runs in single-app mode and by accident
+        # autocompletes the app name too far, it shouldn't fail
+        app = importlib.import_module(app_import_path + '.main', package='apps')
+        context = self.cm.create_context(app_path)
+        context.threaded = threaded
+        i, o = self.cm.get_io_for_context(app_path)
+        if is_class_based_module(app):
+            app_class = get_zeroapp_class_in_module(app)
+            app = app_class(i, o)
+        else:
+            app.init_app(i, o)
+        self.pass_context_to_app(app, app_path, context)
+        return app
+
+    def pass_context_to_app(self, app, app_path, context):
+        """
+        This is a function to pass context objects to apps. For now, it works
+        with both class-based and module-based apps. It only passes the context
+        if it detects that the app has the appropriate function to do that.
+        """
+        if hasattr(app, "set_context") and callable(app.set_context):
+            try:
+                app.set_context(context)
+            except Exception as e:
+                logger.exception("App {}: app class has 'set_context' but raised exception when passed a context".format(app_path))
+            else:
+                logger.info("Passed context to app {}".format(app_path))
+
+    def get_subdir_menu_name(self, subdir_path):
+        """
+        This function gets a subdirectory path and imports __init__.py from it.
+        It then gets _menu_name attribute from __init__.py and returns it.
+        If failed to either import __init__.py or get the _menu_name attribute,
+        it returns the subdirectory name.
+        """
+        subdir_import_path = subdir_path.replace('/', '.')
+        try:
+            subdir_object = importlib.import_module(subdir_import_path + '.__init__')
+            return subdir_object._menu_name
+        except Exception as e:
+            logger.error("Exception while loading __init__.py for subdir {}".format(subdir_path))
+            logger.error(e)
+            return os.path.split(subdir_path)[1].capitalize()
+
+    def get_ordering(self, path):
+        """This function gets a subdirectory path and imports __init__.py from it. It then gets _ordering attribute from __init__.py and returns it. It also caches the attribute for faster initialization.
+        If failed to either import __init__.py or get the _ordering attribute, it returns an empty list."""
+        if path in self.ordering_cache:
+            return self.ordering_cache[path]
+        import_path = path.replace('/', '.')
+        ordering = []
+        try:
+            imported_module = importlib.import_module(import_path + '.__init__')
+            ordering = imported_module._ordering
+            logger.debug("Found ordering for {} directory!".format(import_path))
+        except ImportError as e:
+            logger.error("Exception while loading __init__.py for directory {}".format(path))
+            logger.debug(e)
+        except AttributeError as e:
+            pass
+        finally:
+            self.ordering_cache[path] = ordering
+            return ordering
+
+    def insert_by_ordering(self, to_insert, alias, l, ordering):
+        if alias in ordering:
+            # HAAAAAAAAAAAAAAXXXXXXXXXX
+            to_insert = ListWithMetadata(to_insert)
+            # Marking the object we're inserting with its alias
+            # so that we won't mix up ordering of elements later
+            to_insert.ordering_alias = alias
+            if not l:  # No conditions to check
+                l.append(to_insert)
+                return l
+            for e in l:
+                if hasattr(e, "ordering_alias"):
+                    if ordering.index(e.ordering_alias) > ordering.index(alias):
+                        l.insert(l.index(e), to_insert)
+                        return l
+                    else:
+                        pass  # going to next element
+                else:
+                    l.insert(l.index(e), to_insert)
+                    return l
+        l.append(to_insert)
+        return l  # Catch-all
+
+
+def app_walk(base_dir):
+    """Example of app_walk(directory):  
+    [('./apps', ['ee_apps', 'media_apps', 'test', 'system_apps', 'skeleton', 'network_apps'], ['__init__.pyc', '__init__.py']),
+    ('./apps/ee_apps', ['i2ctools'], ['__init__.pyc', '__init__.py']),
+    ('./apps/ee_apps/i2ctools', [], ['__init__.pyc', '__init__.py', 'main.pyc', 'main.py']),
+    ('./apps/media_apps', ['mocp', 'volume'], ['__init__.pyc', '__init__.py']),
+    ('./apps/media_apps/mocp', [], ['__init__.pyc', '__init__.py', 'main.pyc', 'main.py']),
+    ('./apps/media_apps/volume', [], ['__init__.pyc', '__init__.py', 'main.pyc', 'main.py'])]
+    """
+    walk_results = []
+    modules = []
+    subdirs = []
+    for element in os.listdir(base_dir):
+        full_path = os.path.join(base_dir, element)
+        if os.path.isdir(full_path):
+            if is_subdir(full_path):
+                subdirs.append(element)
+                results = app_walk(full_path)
+                for result in results:
+                    walk_results.append(result)
+            elif is_module_dir(full_path):
+                modules.append(element)
+    walk_results.append((base_dir, subdirs, modules))
+    return walk_results
+
+
+def get_zeroapp_class_in_module(module_):
+    if 'init_app' in dir(module_):
+        return None
+    module_content = [item for item in dir(module_) if not item.startswith('__')]
+    for item in module_content:
+        class_ = getattr(module_, item)
+        try:
+            if issubclass(class_, zero_app.ZeroApp) and item != 'ZeroApp':
+                return class_
+        except Exception as e:
+            pass  # not a class : ignore
+    return None
+
+
+def is_class_based_module(module_):
+    return get_zeroapp_class_in_module(module_) is not None
+
+
+def is_module_dir(dir_path):
+    contents = os.listdir(dir_path)
+    return "main.py" in contents and "do_not_load" not in contents
+
+
+def is_subdir(dir_path):
+    contents = os.listdir(dir_path)
+    return "__init__.py" in contents and "main.py" not in contents and "do_not_load" not in contents
diff --git a/input/__init__.py b/zpui/apps/clock/__init__.py
similarity index 100%
rename from input/__init__.py
rename to zpui/apps/clock/__init__.py
diff --git a/zpui/apps/clock/main.py b/zpui/apps/clock/main.py
new file mode 100755
index 0000000..847b6f1
--- /dev/null
+++ b/zpui/apps/clock/main.py
@@ -0,0 +1,132 @@
+from __future__ import division
+
+import math
+from datetime import datetime, timedelta
+
+from apps import ZeroApp
+from ui import Menu, Refresher, Canvas, IntegerAdjustInput
+
+from helpers import read_or_create_config, local_path_gen
+
+local_path = local_path_gen(__name__)
+
+class ClockApp(ZeroApp, Refresher):
+
+    def __init__(self, i, o, *args, **kwargs):
+        super(ClockApp, self).__init__(i, o)
+        self.menu_name = "Clock"
+        self.countdown = None
+        self.refresher = Refresher(self.on_refresh, i, o, keymap={"KEY_RIGHT":self.countdown_settings})
+        default_config = '{}'
+        config_filename = "config.json"
+        self.config = read_or_create_config(local_path(config_filename), default_config, self.menu_name+" app")
+
+    def format_countdown(self):
+        if not self.countdown: return None
+        h, m, s, sign = self.get_countdown_time_left()
+        if sign: return None
+        return "{}m".format(h*60+m)
+
+    def get_countdown_time_left(self):
+        delta = self.countdown["time"]-datetime.now()
+        print(delta)
+        seconds = delta.seconds
+        sign = None
+        if delta.days < 0:
+            seconds = -seconds
+            sign = "+"
+        hours, remainder = divmod(seconds, 3600)
+        minutes, seconds = divmod(remainder, 60)
+        if sign == "+":
+            hours = hours+24
+        return hours, minutes, seconds, sign
+
+    def countdown_settings(self):
+        # Setting an absolute countdown is not yet possible
+        # because we don't yet have a TimePicker UI element
+        def gmc(): #get menu contents
+            countdown_label = self.format_countdown()
+            contents = []
+            if countdown_label: contents.append(["Countdown: {}".format(countdown_label)])
+            #contents.append(["Set absolute", lambda: self.set_countdown(absolute=True)])
+            contents.append(["Set relative", self.set_countdown])
+            return contents
+        Menu([], self.i, self.o, "Countdown settings menu", contents_hook=gmc).activate()
+
+    def set_countdown(self, absolute=False):
+        if absolute: raise NotImplementedError # Needs a TimePicker or something like that
+        rel_start = 0
+        message = "After (in minutes):"
+        if self.countdown:
+            # A countdown is already active
+            # Using it as a starting point
+            h, m, s, _ = self.get_countdown_time_left()
+            rel_start = h*60+m
+        offset = IntegerAdjustInput(rel_start, self.i, self.o, message=message).activate()
+        if offset is not None:
+            countdown = {"time": datetime.now()+timedelta(minutes=offset)}
+            self.countdown = countdown
+
+    def draw_analog_clock(self, c, time, radius="min(*c.size) / 3", clock_x = "center_x+32", clock_y = "center_y+5", h_len = "radius / 2", m_len = "radius - 5", s_len = "radius - 3", **kwargs):
+        """Draws the analog clock, with parameters configurable through config.json."""
+        center_x, center_y = c.get_center()
+        clock_x = eval(clock_x)
+        clock_y = eval(clock_y)
+        radius = eval(radius)
+        c.ellipse((clock_x - radius, clock_y - radius, clock_x + radius, clock_y + radius), fill=False, outline="white")
+        self.draw_needle(c, 60 - time.second / 60, eval(s_len), clock_x, clock_y, 1)
+        self.draw_needle(c, 60 - time.minute / 60, eval(m_len), clock_x, clock_y, 1)
+        self.draw_needle(c, 24 - time.hour / 24, eval(h_len), clock_x, clock_y, 1)
+
+    def draw_countdown(self, c, countdown_x="(center_x/2)-10", countdown_y="center_y/2*3", **kwargs):
+        """Draws the digital clock, with parameters configurable through config.json."""
+        h, m, s, sign = self.get_countdown_time_left()
+        hz, mz, sz = map(lambda x:str(x).zfill(2), (h, m, s))
+        string = "{}:{}".format(mz, sz)
+        if h: string = hz+":"+string
+        if sign: string = sign+string
+        center_x, center_y = c.get_center()
+        centered_coords = c.get_centered_text_bounds(string)
+        x = eval(countdown_x)
+        y = eval(countdown_y)
+        c.text((x, y), string, fill="white")
+
+    def draw_text(self, c, time, text_x="10", text_y="center_y-5", time_format = "%H:%M:%S", **kwargs):
+        """Draws the digital clock, with parameters configurable through config.json."""
+        time_str = time.strftime(time_format)
+        center_x, center_y = c.get_center()
+        centered_coords = c.get_centered_text_bounds(time_str)
+        x = eval(text_x)
+        y = eval(text_y)
+        c.text(time_str, (x, y))
+
+    def on_refresh(self):
+        current_time = datetime.now()
+        return self.render_clock(current_time, **self.config)
+
+    def render_clock(self, time, **kwargs):
+        c = Canvas(self.o)
+        width, height = c.size
+        self.draw_text(c, time, **kwargs)
+        self.draw_analog_clock(c, time, **kwargs)
+        if self.countdown:
+            self.draw_countdown(c, **kwargs)
+        return c.get_image()
+
+    def draw_needle(self, c, progress, radius, x, y, width):
+        # type: (Canvas, float, float, float, float, int) -> None
+        hour_angle = math.pi * 2 * progress + math.pi
+        c.line(
+            (
+                int(x),
+                int(y),
+                int(x + radius * math.sin(hour_angle)),
+                int(y + radius * math.cos(hour_angle))
+            ),
+            width=width,
+            fill=True
+        )
+
+    def on_start(self):
+        super(ClockApp, self).on_start()
+        self.refresher.activate()
diff --git a/zpui/apps/example_apps/__init__.py b/zpui/apps/example_apps/__init__.py
new file mode 100644
index 0000000..b8923b2
--- /dev/null
+++ b/zpui/apps/example_apps/__init__.py
@@ -0,0 +1 @@
+_menu_name = "Example apps"
diff --git a/input/drivers/__init__.py b/zpui/apps/example_apps/char_arrow_input/__init__.py
similarity index 100%
rename from input/drivers/__init__.py
rename to zpui/apps/example_apps/char_arrow_input/__init__.py
diff --git a/zpui/apps/example_apps/char_arrow_input/main.py b/zpui/apps/example_apps/char_arrow_input/main.py
new file mode 100755
index 0000000..8242f69
--- /dev/null
+++ b/zpui/apps/example_apps/char_arrow_input/main.py
@@ -0,0 +1,22 @@
+
+
+from helpers import setup_logger
+
+menu_name = "Char input app"
+
+from ui import CharArrowKeysInput as Input
+logger = setup_logger(__name__, "info")
+
+#Some globals for us
+i = None #Input device
+o = None #Output device
+
+#Callback for ZPUI. It gets called when application is activated in the main menu
+def callback():
+    char_input = Input(i, o, initial_value = "password")
+    logger.info(repr(char_input.activate()))
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output #Getting references to output and input device objects and saving them as globals
+
diff --git a/output/__init__.py b/zpui/apps/example_apps/checkbox_test/__init__.py
similarity index 100%
rename from output/__init__.py
rename to zpui/apps/example_apps/checkbox_test/__init__.py
diff --git a/zpui/apps/example_apps/checkbox_test/main.py b/zpui/apps/example_apps/checkbox_test/main.py
new file mode 100755
index 0000000..55cdafd
--- /dev/null
+++ b/zpui/apps/example_apps/checkbox_test/main.py
@@ -0,0 +1,23 @@
+menu_name = "Checkbox test"
+
+from subprocess import call
+from ui import Checkbox, Printer
+
+callback = None
+i = None
+o = None
+
+checkbox_contents = [
+["First element", '1_el', False],
+["Second element", '2_el', True],
+["Third element", '3_el', False],
+["Fourth element xD", '4_el', True]
+]
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
+def callback():
+    result = Checkbox(checkbox_contents, i, o, "Shutdown menu").activate()
+    Printer(str(result), i, o, 1)
diff --git a/output/drivers/__init__.py b/zpui/apps/example_apps/class_based_skeleton/__init__.py
similarity index 100%
rename from output/drivers/__init__.py
rename to zpui/apps/example_apps/class_based_skeleton/__init__.py
diff --git a/zpui/apps/example_apps/class_based_skeleton/main.py b/zpui/apps/example_apps/class_based_skeleton/main.py
new file mode 100755
index 0000000..49bd187
--- /dev/null
+++ b/zpui/apps/example_apps/class_based_skeleton/main.py
@@ -0,0 +1,33 @@
+# -*- coding: utf-8 -*-
+
+from subprocess import call
+from apps.zero_app import ZeroApp
+from helpers import setup_logger
+from ui import Menu, Printer
+
+
+logger = setup_logger(__name__, "info")
+
+
+class SkeletonApp(ZeroApp):
+    def __init__(self, i, o):
+        """gets called when ZPUI is starting"""
+        super(SkeletonApp, self).__init__(i, o)  # call to base class constructor so input and outputs are saved
+        self.menu_name = "Class Based Skeleton"  # App name as seen in main menu while using the system
+        self.main_menu_contents = [
+            ["Internal command", self.call_internal],
+            ["External command", self.call_external],
+            ["Exit", 'exit']]
+
+    def on_start(self):
+        """gets called when application is activated in the main menu"""
+        super(SkeletonApp, self).on_start()  # call to base class method. Not mandatory but good practice
+        Menu(self.main_menu_contents, self.i, self.o, "Skeleton app menu").activate()
+
+    def call_internal(self):
+        Printer(["Calling internal", "command"], self.i, self.o, 1)
+        logger.info("Success")
+
+    def call_external(self):
+        Printer(["Calling external", "command"], self.i, self.o, 1)
+        call(['echo', 'Success'])
diff --git a/zpui/apps/example_apps/dialog_test/__init__.py b/zpui/apps/example_apps/dialog_test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/dialog_test/main.py b/zpui/apps/example_apps/dialog_test/main.py
new file mode 100755
index 0000000..ae50a7c
--- /dev/null
+++ b/zpui/apps/example_apps/dialog_test/main.py
@@ -0,0 +1,22 @@
+
+
+from helpers import setup_logger
+
+menu_name = "DialogBox test" #App name as seen in main menu while using the system
+
+from ui import DialogBox
+
+logger = setup_logger(__name__, "info")
+#Some globals for us
+i = None #Input device
+o = None #Output device
+
+def callback():
+    logger.info(DialogBox('ync', i, o, message="It's working?").activate())
+    logger.info((DialogBox('yyy', i, o, message="Isn't it beautiful?").activate()))
+    logger.info((DialogBox([["Yes", True], ["Absolutely", True]], i, o, message="Do you like it").activate()))
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output #Getting references to output and input device objects and saving them as globals
+
diff --git a/zpui/apps/example_apps/ffs_test/__init__.py b/zpui/apps/example_apps/ffs_test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/ffs_test/main.py b/zpui/apps/example_apps/ffs_test/main.py
new file mode 100755
index 0000000..57e86e4
--- /dev/null
+++ b/zpui/apps/example_apps/ffs_test/main.py
@@ -0,0 +1,17 @@
+menu_name = "FFS test app"
+
+from ui import Printer, format_for_screen as ffs
+
+from subprocess import check_output
+
+callback = None
+#Some globals for us
+i = None
+o = None
+
+def init_app(input, output):
+    global callback, i, o
+    i = input; o = output
+    lsusb_output = check_output(['lsusb'])
+    callback = lambda: Printer(ffs(lsusb_output, o.cols), i, o, sleep_time=5, skippable=True)
+
diff --git a/zpui/apps/example_apps/fire_detector/__init__.py b/zpui/apps/example_apps/fire_detector/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/fire_detector/fire.png b/zpui/apps/example_apps/fire_detector/fire.png
new file mode 100644
index 0000000..f3641da
Binary files /dev/null and b/zpui/apps/example_apps/fire_detector/fire.png differ
diff --git a/zpui/apps/example_apps/fire_detector/main.py b/zpui/apps/example_apps/fire_detector/main.py
new file mode 100755
index 0000000..33db1f1
--- /dev/null
+++ b/zpui/apps/example_apps/fire_detector/main.py
@@ -0,0 +1,27 @@
+menu_name = "Flame detector"
+
+from RPi import GPIO
+import sys
+import os
+
+from helpers import ExitHelper
+from ui import GraphicsPrinter
+
+local_path = lambda x: os.path.join( os.path.dirname(sys.modules[__name__].__file__), x )
+
+i = None; o = None
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
+def callback():
+    GPIO.setmode(GPIO.BCM)
+    GPIO.setup(18, GPIO.IN)
+    eh = ExitHelper(i).start()
+    while eh.do_run():
+        state = GPIO.input(18)
+        if state:
+            GraphicsPrinter(local_path("no_fire.png"), None, o, 0.1)
+        else:
+            GraphicsPrinter(local_path("fire.png"), None, o, 0.1)
diff --git a/zpui/apps/example_apps/fire_detector/no_fire.png b/zpui/apps/example_apps/fire_detector/no_fire.png
new file mode 100644
index 0000000..ea818a8
Binary files /dev/null and b/zpui/apps/example_apps/fire_detector/no_fire.png differ
diff --git a/zpui/apps/example_apps/listbox_test/__init__.py b/zpui/apps/example_apps/listbox_test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/listbox_test/main.py b/zpui/apps/example_apps/listbox_test/main.py
new file mode 100755
index 0000000..35fbe68
--- /dev/null
+++ b/zpui/apps/example_apps/listbox_test/main.py
@@ -0,0 +1,24 @@
+
+
+from helpers import setup_logger
+
+menu_name = "Listbox test" #App name as seen in main menu while using the system
+
+from ui import Listbox
+
+logger = setup_logger(__name__, "info")
+#Some globals for us
+i = None #Input device
+o = None #Output device
+
+def callback():
+    listbox_contents = [
+    ["Number", 101],
+    ["String", "stringstring"],
+    ["Tuple", (1, 2, 3)]]
+    logger.info(Listbox(listbox_contents, i, o).activate())
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output #Getting references to output and input device objects and saving them as globals
+
diff --git a/zpui/apps/example_apps/loadingbar_test_app/__init__.py b/zpui/apps/example_apps/loadingbar_test_app/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/loadingbar_test_app/main.py b/zpui/apps/example_apps/loadingbar_test_app/main.py
new file mode 100644
index 0000000..cce370f
--- /dev/null
+++ b/zpui/apps/example_apps/loadingbar_test_app/main.py
@@ -0,0 +1,43 @@
+from time import sleep
+
+from apps import ZeroApp
+from ui import ProgressBar, TextProgressBar, CircularProgressBar, GraphicalProgressBar, IdleDottedMessage, Throbber, \
+    Listbox
+
+
+class LoadingBarExampleApp(ZeroApp):
+    def __init__(self, i, o):
+        super(LoadingBarExampleApp, self).__init__(i, o)
+        self.menu_name = "Loading bar test app"
+
+        self.default_progress_bar = ProgressBar(self.i, self.o)
+        self.text_progress_bar = TextProgressBar(self.i, self.o, refresh_interval=.1, show_percentage=True,
+                                                 percentage_offset=0)
+        self.circular_progress = CircularProgressBar(self.i, self.o, show_percentage=True)
+        self.dotted_progress_bar = IdleDottedMessage(self.i, self.o)
+        self.throbber = Throbber(self.i, self.o, message="Test message")
+        self.graphical_progress_bar = GraphicalProgressBar(self.i, self.o)
+        self.default_progress_bar = ProgressBar(self.i, self.o)
+        lb_contents = [
+            ["Default progress bar", self.default_progress_bar],
+            ["Text progress bar", self.text_progress_bar],
+            ["Dotted idle ", self.dotted_progress_bar],
+            ["Circular progress ", self.circular_progress],
+            ["Idle Throbber", self.throbber],
+            ["Graphical Loading bar", self.graphical_progress_bar],
+        ]
+        self.bar_choice_listbox = Listbox(lb_contents, self.i, self.o)
+
+    def on_start(self):
+        super(LoadingBarExampleApp, self).on_start()
+        with self.bar_choice_listbox.activate() as chosen_loading_bar:
+            if hasattr(chosen_loading_bar, "progress"):
+                for i in range(101):
+                    chosen_loading_bar.progress = i
+                    sleep(0.01)
+                sleep(1)
+                for i in range(101)[::-1]:
+                    chosen_loading_bar.progress = i
+                    sleep(0.1)
+            else:
+                sleep(3)
diff --git a/zpui/apps/example_apps/menu_arrow_test/__init__.py b/zpui/apps/example_apps/menu_arrow_test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/menu_arrow_test/main.py b/zpui/apps/example_apps/menu_arrow_test/main.py
new file mode 100755
index 0000000..b3e17a5
--- /dev/null
+++ b/zpui/apps/example_apps/menu_arrow_test/main.py
@@ -0,0 +1,18 @@
+from __future__ import print_function
+
+menu_name = "Menu arrow testing"
+
+from ui import Menu
+
+#Some globals for us
+i = None #Input device
+o = None #Output device
+
+def callback():
+    contents = [["Arrow test", lambda: print("Enter"), lambda: print("Right")]]
+    Menu(contents, i, o, "Menu arrow test menu").activate()
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output 
+
diff --git a/zpui/apps/example_apps/menu_dynupdate_test/__init__.py b/zpui/apps/example_apps/menu_dynupdate_test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/menu_dynupdate_test/main.py b/zpui/apps/example_apps/menu_dynupdate_test/main.py
new file mode 100755
index 0000000..652b874
--- /dev/null
+++ b/zpui/apps/example_apps/menu_dynupdate_test/main.py
@@ -0,0 +1,39 @@
+menu_name = "Menu dynamic update testing"
+
+from ui import Menu
+
+#Some globals for us
+i = None #Input device
+o = None #Output device
+
+counter1 = 0
+counter2 = 20
+
+def counter_change(cnum, amount):
+    global counter1, counter2
+    if cnum == 1:
+        counter1 += amount
+    else:
+        counter2 += amount 
+        if counter2 < 0:
+            counter2 = 0
+
+def construct_contents():
+    contents = [
+    ["Counter1 = {}".format(counter1)],
+    ["Counter1 + 1", lambda: counter_change(1, +1) ] ]
+    for i in range(counter1):
+        contents.append(["Counter1:{}".format(i)])
+    contents.append(["Counter2 = {}".format(counter2)])
+    contents.append(["Counter2-3", lambda:counter_change(2, -3)])
+    for i in range(counter2):
+        contents.append(["Counter2:{}".format(i)])
+    return contents
+
+def callback():
+    Menu([], i, o, "Menu update test menu", contents_hook=construct_contents).activate()
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output 
+
diff --git a/zpui/apps/example_apps/number_input/__init__.py b/zpui/apps/example_apps/number_input/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/number_input/main.py b/zpui/apps/example_apps/number_input/main.py
new file mode 100755
index 0000000..f0eb486
--- /dev/null
+++ b/zpui/apps/example_apps/number_input/main.py
@@ -0,0 +1,24 @@
+
+
+from helpers import setup_logger
+
+menu_name = "Number input app"
+
+from datetime import datetime
+
+from ui import IntegerInDecrementInput as Input
+
+logger = setup_logger(__name__, "info")
+
+i = None #Input device
+o = None #Output device
+
+#Callback for ZPUI. It gets called when application is activated in the main menu
+def callback():
+    number_input = Input(0, i, o)
+    logger.info(number_input.activate())
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output #Getting references to output and input device objects and saving them as globals
+
diff --git a/zpui/apps/example_apps/numbered_input_menu_test/__init__.py b/zpui/apps/example_apps/numbered_input_menu_test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/numbered_input_menu_test/main.py b/zpui/apps/example_apps/numbered_input_menu_test/main.py
new file mode 100644
index 0000000..25d3e1e
--- /dev/null
+++ b/zpui/apps/example_apps/numbered_input_menu_test/main.py
@@ -0,0 +1,34 @@
+# coding=utf-8
+
+
+from apps.zero_app import ZeroApp
+from helpers import setup_logger
+from ui import NumberedMenu
+import random
+
+logger = setup_logger(__name__, "info")
+class NumberedInputTestApp(ZeroApp):
+
+    def __init__(self, i, o):
+        super(NumberedInputTestApp, self).__init__(i, o)
+        self.n_menu = None
+        self.menu_name = "Numbered Input Menu"
+        hellos = ["hello", "hello again", "ditto", "same"]
+        self.main_menu_contents = [ [hellos[i%4],
+                                    lambda x=i: self.print_hello(x, hellos[x%4])]
+                                     for i in range(16) ]
+
+    @staticmethod
+    def print_hello(index, hello):
+        logger.info("{} {}".format(index, hello))
+
+    def on_start(self):
+        super(NumberedInputTestApp, self).on_start()
+        self.n_menu = NumberedMenu(
+            self.main_menu_contents,
+            self.i,
+            self.o,
+            self.menu_name,
+            prepend_numbers=True,
+            input_delay=1)
+        self.n_menu.activate()
diff --git a/zpui/apps/example_apps/numpad_input/__init__.py b/zpui/apps/example_apps/numpad_input/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/numpad_input/main.py b/zpui/apps/example_apps/numpad_input/main.py
new file mode 100755
index 0000000..792703e
--- /dev/null
+++ b/zpui/apps/example_apps/numpad_input/main.py
@@ -0,0 +1,24 @@
+
+
+from helpers import setup_logger
+
+menu_name = "Char input app"
+
+from ui import NumpadCharInput as CharInput, NumpadNumberInput as NumberInput
+
+logger = setup_logger(__name__, "info")
+#Some globals for us
+i = None #Input device
+o = None #Output device
+
+#Callback for ZPUI. It gets called when application is activated in the main menu
+def callback():
+    char_input = CharInput(i, o, message="Input characters")
+    logger.info(repr(char_input.activate()))
+    number_input = NumberInput(i, o, message="Input numbers")
+    logger.info(repr(number_input.activate()))
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output #Getting references to output and input device objects and saving them as globals
+
diff --git a/zpui/apps/example_apps/refresher/__init__.py b/zpui/apps/example_apps/refresher/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/refresher/main.py b/zpui/apps/example_apps/refresher/main.py
new file mode 100755
index 0000000..f90bcb4
--- /dev/null
+++ b/zpui/apps/example_apps/refresher/main.py
@@ -0,0 +1,31 @@
+menu_name = "Refresher app" 
+
+from datetime import datetime
+
+from ui import Refresher
+
+counter = 0
+
+def count():
+    global counter
+    counter += 1
+    return ["Counter is", str(counter)]
+
+def show_time():
+    now = datetime.now()
+    return [now.strftime("%H:%M:%S").center(o.cols), now.strftime("%Y-%m-%d").center(o.cols)]
+
+#Callback global for ZPUI. It gets called when application is activated in the main menu
+callback = None
+
+#Some globals for us
+i = None #Input device
+o = None #Output device
+
+def init_app(input, output):
+    global callback, i, o
+    i = input; o = output #Getting references to output and input device objects and saving them as globals
+    time_refresher = Refresher(show_time, i, o, 1, name="Timer")
+    counter_refresher = Refresher(count, i, o, 1, keymap={"KEY_ENTER":time_refresher.activate}, name="Counter")
+    callback = counter_refresher.activate
+
diff --git a/zpui/apps/example_apps/sandbox/__init__.py b/zpui/apps/example_apps/sandbox/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/sandbox/main.py b/zpui/apps/example_apps/sandbox/main.py
new file mode 100755
index 0000000..1729616
--- /dev/null
+++ b/zpui/apps/example_apps/sandbox/main.py
@@ -0,0 +1,17 @@
+menu_name = "Python sandbox"
+
+i = None
+o = None
+context = None
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
+def set_context(new_context):
+    global context
+    context = new_context
+
+def callback():
+    import code as __code__
+    __code__.interact(local=dict(globals(), **locals()))
diff --git a/zpui/apps/example_apps/scrolling_test/__init__.py b/zpui/apps/example_apps/scrolling_test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/scrolling_test/main.py b/zpui/apps/example_apps/scrolling_test/main.py
new file mode 100755
index 0000000..7b6a2f3
--- /dev/null
+++ b/zpui/apps/example_apps/scrolling_test/main.py
@@ -0,0 +1,22 @@
+menu_name = "Scrolling test"
+
+i = None 
+o = None
+
+from ui import Menu, Printer, Listbox, PathPicker
+
+callback = None
+
+def init_app(input, output):
+    global callback, i, o
+    i = input; o = output
+    lb_contents = [["Very long listbox option name", 1], ["Even longer option name", 2]]
+    lb=Listbox(lb_contents, i, o, "Scrolling test listbox")
+    pp=PathPicker('/', i, o)
+    main_menu_contents = [
+    ["Command with very long name", lb.activate],
+    ["Command with an even longer name", pp.activate],
+    ["Exit", 'exit']]
+    main_menu = Menu(main_menu_contents, i, o, "Scrolling test menu")
+    callback = main_menu.activate
+
diff --git a/zpui/apps/example_apps/skeleton/__init__.py b/zpui/apps/example_apps/skeleton/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/skeleton/main.py b/zpui/apps/example_apps/skeleton/main.py
new file mode 100755
index 0000000..c0a5479
--- /dev/null
+++ b/zpui/apps/example_apps/skeleton/main.py
@@ -0,0 +1,38 @@
+
+
+from helpers import setup_logger
+
+menu_name = "Skeleton app"  # App name as seen in main menu while using the system
+
+from subprocess import call
+from time import sleep
+
+from ui import Menu, Printer
+
+logger = setup_logger(__name__, "info")
+
+def call_internal():
+    Printer(["Calling internal", "command"], i, o, 1)
+    logger.info("Success")
+
+def call_external():
+    Printer(["Calling external", "command"], i, o, 1)
+    call(['echo', 'Success'])
+
+#Callback global for ZPUI. It gets called when application is activated in the main menu
+callback = None
+
+i = None #Input device
+o = None #Output device
+
+def init_app(input, output):
+    global callback, i, o
+    i = input;
+    o = output  # Getting references to output and input device objects and saving them as globals
+    main_menu_contents = [
+    ["Internal command", call_internal],
+    ["External command", call_external],
+    ["Exit", 'exit']]
+    main_menu = Menu(main_menu_contents, i, o, "Skeleton app menu")
+    callback = main_menu.activate
+
diff --git a/zpui/apps/example_apps/streaming_test/__init__.py b/zpui/apps/example_apps/streaming_test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/streaming_test/main.py b/zpui/apps/example_apps/streaming_test/main.py
new file mode 100755
index 0000000..67466d7
--- /dev/null
+++ b/zpui/apps/example_apps/streaming_test/main.py
@@ -0,0 +1,39 @@
+menu_name = "Refresher app" 
+
+from ui import Refresher, PrettyPrinter
+
+counter = 0
+keys_called = []
+
+def process_key(key, *args):
+    global counter, keys_called
+    if len(keys_called) >= o.rows:
+        keys_called = keys_called[1:]
+    keys_called.append([counter, key])
+    counter += 1
+    ltk = [k for c, k in keys_called][-3:]
+    if len(ltk) >= 3 and ltk[0]==ltk[1]==ltk[2]:
+        refresher.deactivate()
+    else:
+        refresher.refresh() #Makes changes appear faster
+
+def get_keys():
+    return ["{}:{}".format(num, key) for num, key in keys_called]
+
+refresher = None
+i = None #Input device
+o = None #Output device
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output 
+
+def callback():
+    global refresher, keys_called
+    keys_called = []
+    i.set_streaming(process_key)
+    refresher = Refresher(get_keys, i, o, 1, name="Key monitor")
+    refresher.keymap.pop("KEY_LEFT") #Removing deactivate callback to show KEY_LEFT
+    PrettyPrinter("To exit this app, press the same key 3 times", i, o)
+    refresher.activate()
+    i.remove_streaming()
diff --git a/zpui/apps/example_apps/test/__init__.py b/zpui/apps/example_apps/test/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/test/main.py b/zpui/apps/example_apps/test/main.py
new file mode 100755
index 0000000..f81a13a
--- /dev/null
+++ b/zpui/apps/example_apps/test/main.py
@@ -0,0 +1,17 @@
+menu_name = "Hello World" #ZPUI needs this variable to show app name in the main menu
+
+from ui import Printer #This UI element prints your text on the screen, waits the amount of time you tell it to and exits.
+from ui import format_for_screen as ffs #This helper function takes a text message and splits it into blocks so that it fits the screen
+
+#Some globals for storing input and output device objects
+i = None
+o = None
+
+def callback():
+    """A function that's called when the app is selected in the menu"""
+    Printer(ffs("Hello and welcome to Aperture Science computer aided enrichment center", o.cols), i, o, sleep_time=5, skippable=True)
+
+def init_app(input, output):
+    """A function called once when ZPUI loads, to pass all the variables to the app"""
+    global i, o
+    i = input; o = output
diff --git a/zpui/apps/example_apps/text_reader/__init__.py b/zpui/apps/example_apps/text_reader/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/example_apps/text_reader/main.py b/zpui/apps/example_apps/text_reader/main.py
new file mode 100644
index 0000000..b235ded
--- /dev/null
+++ b/zpui/apps/example_apps/text_reader/main.py
@@ -0,0 +1,34 @@
+# coding=utf-8
+from apps.zero_app import ZeroApp
+from ui.scrollable_element import TextReader
+
+
+class TextReaderExample(ZeroApp):
+    def __init__(self, i, o):
+        super(TextReaderExample, self).__init__(i, o)
+        zen_of_python = """Beautiful is better than ugly.
+Explicit is better than implicit.
+Simple is better than complex.
+Complex is better than complicated.
+Flat is better than nested.
+Sparse is better than dense.
+Readability counts.
+Special cases aren't special enough to break the rules.
+Although practicality beats purity.
+Errors should never pass silently.
+Unless explicitly silenced.
+In the face of ambiguity, refuse the temptation to guess.
+There should be one - and preferably only one - obvious way to do it.
+Although that way may not be obvious at first unless you're Dutch.
+Now is better than never.
+Although never is often better than right now.
+If the implementation is hard to explain, it's a bad idea.
+If the implementation is easy to explain, it may be a good idea.
+Namespaces are one honking great idea - let's do more of those!
+"""
+        self.menu_name = "TextReader test app"
+        self.text_reader = TextReader(zen_of_python, i, o, self.menu_name)
+
+    def on_start(self):
+        super(TextReaderExample, self).on_start()
+        self.text_reader.activate()
diff --git a/zpui/apps/flashlight/__init__.py b/zpui/apps/flashlight/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/flashlight/main.py b/zpui/apps/flashlight/main.py
new file mode 100644
index 0000000..deae86f
--- /dev/null
+++ b/zpui/apps/flashlight/main.py
@@ -0,0 +1,19 @@
+menu_name = "Flashlight"
+
+from zerophone_hw import RGB_LED
+
+led = None
+state = False
+
+def init_app(i, o):
+    global led
+    led = RGB_LED()
+
+def callback():
+    global state
+    if not state:
+        led.set_color("white")
+        state = True
+    else:
+        led.set_color("none")
+        state = False
diff --git a/zpui/apps/games/__init__.py b/zpui/apps/games/__init__.py
new file mode 100644
index 0000000..a272af6
--- /dev/null
+++ b/zpui/apps/games/__init__.py
@@ -0,0 +1 @@
+_menu_name = "Games"
diff --git a/zpui/apps/games/g_2048/__init__.py b/zpui/apps/games/g_2048/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/games/g_2048/logic.py b/zpui/apps/games/g_2048/logic.py
new file mode 100644
index 0000000..e3a686e
--- /dev/null
+++ b/zpui/apps/games/g_2048/logic.py
@@ -0,0 +1,158 @@
+"""The MIT License (MIT)
+
+Copyright (c) 2014 Tay Yang Shun
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE."""
+
+from random import randint, choice
+from helpers import flatten
+
+class GameOf2048(object):
+
+    matrix = None
+
+    def __init__(self, x_dim=4, y_dim=4):
+        self.x_dim = x_dim
+        self.y_dim = y_dim
+        self.matrix = self.get_new_matrix(self.x_dim, self.y_dim)
+        self.add_random_digit()
+
+    def get_new_matrix(self, x, y):
+        new = []
+        for i in range(y):
+            row = []
+            for i in range(x):
+                row.append(0)
+            new.append(row)
+        return new
+
+    def add_random_digit(self):
+        if not any([cell == 0 for cell in flatten(self.matrix)]):
+            #No place available to add
+            return
+        a=randint(0,self.y_dim-1)
+        b=randint(0,self.x_dim-1)
+        while(self.matrix[a][b]!=0):
+            a=randint(0,self.y_dim-1)
+            b=randint(0,self.x_dim-1)
+        digit = choice([2]*9 +[4])
+        self.matrix[a][b]=digit
+
+    def get_game_state(self):
+        if any([cell == 2048 for cell in flatten(self.matrix)]):
+            return 'win'
+        #If there are empty fields, the game isn't over yet
+        if any([cell == 0 for cell in flatten(self.matrix)]):
+            return 'not over'
+        for i in range(len(self.matrix)-1): #intentionally reduced to check the row on the right and below
+            for j in range(len(self.matrix[0])-1): #more elegant to use exceptions but most likely this will be their solution
+                if self.matrix[i][j]==self.matrix[i+1][j] or self.matrix[i][j+1]==self.matrix[i][j]:
+                    return 'not over'
+        for k in range(len(self.matrix)-1): #to check the left/right entries on the last row
+            if self.matrix[len(self.matrix)-1][k]==self.matrix[len(self.matrix)-1][k+1]:
+                return 'not over'
+        for j in range(len(self.matrix)-1): #check up/down entries on last column
+            if self.matrix[j][len(self.matrix)-1]==self.matrix[j+1][len(self.matrix)-1]:
+                return 'not over'
+        return 'lose'
+
+    def get_field(self):
+        return self.matrix
+
+    def reverse(self):
+        new = []
+        for i in range(len(self.matrix)):
+            new.append([])
+            for j in range(len(self.matrix[0])):
+                new[i].append(self.matrix[i][len(self.matrix[0])-j-1])
+        self.matrix = new
+
+    def transpose(self):
+        new=[]
+        for i in range(len(self.matrix[0])):
+            new.append([])
+            for j in range(len(self.matrix)):
+                new[i].append(self.matrix[j][i])
+        self.matrix = new
+
+    def cover_up(self):
+        new = self.get_new_matrix(self.x_dim, self.y_dim)
+        changed=False
+        for i in range(4):
+            count=0
+            for j in range(4):
+                if self.matrix[i][j]!=0:
+                    new[i][count]=self.matrix[i][j]
+                    if j!=count:
+                        changed=True
+                    count+=1
+        self.matrix = new
+        return changed
+
+    def merge(self):
+        changed=False
+        for i in range(4):
+            for j in range(3):
+                if self.matrix[i][j]==self.matrix[i][j+1] and self.matrix[i][j]!=0:
+                    self.matrix[i][j]*=2
+                    self.matrix[i][j+1]=0
+                    changed=True
+        return changed
+
+    #UI-focused functions
+
+    def up(self):
+        self.transpose()
+        coverup_changed = self.cover_up()
+        merge_changed = self.merge()
+        has_changed = coverup_changed or merge_changed
+        self.cover_up()
+        self.transpose()
+        if has_changed:
+            self.add_random_digit()
+
+    def down(self):
+        self.transpose()
+        self.reverse()
+        coverup_changed = self.cover_up()
+        merge_changed = self.merge()
+        has_changed = coverup_changed or merge_changed
+        self.cover_up()
+        self.reverse()
+        self.transpose()
+        if has_changed:
+            self.add_random_digit()
+
+    def left(self):
+        coverup_changed = self.cover_up()
+        merge_changed = self.merge()
+        has_changed = coverup_changed or merge_changed
+        self.cover_up()
+        if has_changed:
+            self.add_random_digit()
+
+    def right(self):
+        self.reverse()
+        coverup_changed = self.cover_up()
+        merge_changed = self.merge()
+        has_changed = coverup_changed or merge_changed
+        self.cover_up()
+        self.reverse()
+        if has_changed:
+            self.add_random_digit()
diff --git a/zpui/apps/games/g_2048/main.py b/zpui/apps/games/g_2048/main.py
new file mode 100644
index 0000000..c864d4b
--- /dev/null
+++ b/zpui/apps/games/g_2048/main.py
@@ -0,0 +1,112 @@
+from threading import Event, Lock
+from time import sleep
+
+from apps import ZeroApp
+from ui import DialogBox, ffs
+from helpers import ExitHelper
+
+from logic import GameOf2048
+
+class GameApp(ZeroApp):
+
+    game = None
+    do_exit = None
+    is_processing = None
+    menu_name = "2048"
+
+    def on_start(self):
+        self.do_exit = Event()
+        self.moving = Lock()
+        if self.game is None:
+            #No game started yet, starting
+            self.start_new_game()
+        elif self.game.get_game_state() == 'lose':
+            start_new = DialogBox("ync", self.i, self.o, message="Last game lost, start new?").activate()
+            if start_new is None:
+                return # Picked cancel, exiting the app
+            elif start_new is True:
+                self.start_new_game()
+        #By now, the `game` property should have a game
+        #Let's launch the main loop
+        while not self.do_exit.isSet():
+            self.game_loop()
+
+    def start_new_game(self):
+        self.game = GameOf2048(4, 4)
+
+    def set_keymap(self):
+        keymap = {"KEY_LEFT": lambda:self.make_a_move("left"),
+                  "KEY_RIGHT": lambda:self.make_a_move("right"),
+                  "KEY_UP": lambda:self.make_a_move("up"),
+                  "KEY_DOWN": lambda:self.make_a_move("down"),
+                  "KEY_ENTER": self.confirm_exit}
+        self.i.stop_listen()
+        self.i.set_keymap(keymap)
+        self.i.listen()
+
+    def confirm_exit(self):
+        with self.moving:
+            if self.game.get_game_state() == 'not over':
+                choices = ["n", ["Restart", "restart"], "y"]
+            else:
+                choices = ["y", ["Restart", "restart"], "n"]
+            choice = DialogBox(choices, self.i, self.o, message="Exit the game?").activate()
+            if choice == "restart":
+                self.start_new_game()
+                self.set_keymap()
+                self.refresh()
+            elif choice is True:
+                self.do_exit.set()
+            else:
+                self.set_keymap()
+                self.refresh()
+
+    def make_a_move(self, direction):
+        with self.moving:
+            assert(direction in ["up", "down", "left", "right"])
+            getattr(self.game, direction)()
+            self.refresh()
+        
+    def game_loop(self):
+        self.set_keymap()
+        self.refresh()
+        while self.game.get_game_state() == 'not over' and not self.do_exit.isSet():
+            sleep(1)
+        if self.do_exit.isSet():
+            return
+        #Waiting for player to click any of five primary keys
+        #Then, prompting to restart the game
+        eh = ExitHelper(self.i, keys=self.i.reserved_keys).start()
+        while eh.do_run():
+            sleep(0.1)
+        do_restart = DialogBox("ync", self.i, self.o, message="Restart the game?").activate()
+        if do_restart is None: #Cancel, leaving the playing field as-is
+            return
+        elif do_restart is False: #No, not restarting, thus exiting the game
+            self.do_exit.set()
+        else:
+            self.start_new_game() #Yes, restarting (game_loop will be entered once more from on_start() )
+
+    def display_field(self, field):
+        assert len(field) == 4, "Can't display a field that's not 4x4!"
+        assert len(field[0]) == 4, "Can't display a field that's not 4x4!"
+        display_data = []
+        space_for_each_number = self.o.cols / len(field[0])
+        for field_row in field:
+            field_row_str = [str(i) if i else "." for i in field_row]
+            display_row = "".join(str(i).center(space_for_each_number) for i in field_row_str)
+            display_data.append(display_row.ljust(self.o.cols))
+            display_data.append(""*self.o.cols)
+        #Replacing the center row with the game state, if applicable
+        game_state = self.game.get_game_state()
+        state_str = {"win":"You won!",
+                     "lose":"You lost!",
+                     "not over":""  }[game_state]
+        display_data[3] = state_str.center(self.o.cols)
+        #Footer - game name
+        display_data[7] = "2048".center(self.o.cols)
+        return display_data
+
+    def refresh(self):
+        displayed_field = self.display_field(self.game.get_field())
+        self.o.display_data(*displayed_field)
diff --git a/zpui/apps/hardware_apps/__init__.py b/zpui/apps/hardware_apps/__init__.py
new file mode 100644
index 0000000..a899775
--- /dev/null
+++ b/zpui/apps/hardware_apps/__init__.py
@@ -0,0 +1 @@
+_menu_name = "Hardware"
diff --git a/zpui/apps/hardware_apps/i2ctools/__init__.py b/zpui/apps/hardware_apps/i2ctools/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/hardware_apps/i2ctools/main.py b/zpui/apps/hardware_apps/i2ctools/main.py
new file mode 100755
index 0000000..ead3c6d
--- /dev/null
+++ b/zpui/apps/hardware_apps/i2ctools/main.py
@@ -0,0 +1,139 @@
+menu_name = "I2C tools"
+
+from subprocess import call
+from ui import Menu, Printer, DialogBox, LoadingIndicator, UniversalInput, Refresher, IntegerAdjustInput
+from helpers import setup_logger, read_or_create_config, local_path_gen, write_config
+
+from collections import OrderedDict
+from time import sleep
+
+import smbus
+
+local_path = local_path_gen(__name__)
+logger = setup_logger(__name__, "warning")
+default_config = '{"recent_devices":[], "scan_range":"conservative"}'
+config_path = local_path("config.json")
+config = read_or_create_config(config_path, default_config, menu_name+" app")
+
+def save_config(config):
+    write_config(config, config_path)
+
+current_bus = None
+
+scan_ranges = {"conservative":(0x03, 0x77),
+                       "full":(0x00, 0x7f)}
+
+def scan_i2c_bus():
+    global current_bus
+    Printer("Scanning:", i, o, 0)
+    current_bus = smbus.SMBus(1) # 1 indicates /dev/i2c-1
+    found_devices = OrderedDict()
+    scan_range = config.get("scan_range", "conservative")
+    if scan_range not in scan_ranges.keys(): #unknown scan range - config edited manually?
+      scan_range = "conservative"
+    scan_range_args = scan_ranges[scan_range]
+    for device in range(*scan_range_args):
+      try: #If you try to read and it answers, it's there
+         current_bus.read_byte(device)
+      except IOError as e: 
+         if e.errno == 16:
+             found_devices[device] = "busy"
+         elif e.errno == 121:
+             pass
+         else:
+             found_devices[device] = "error unknown"
+             logger.error("Errno {} unknown - can be used? {}".format(e.errno, repr(e)))
+      else:
+         found_devices[device] = "ok"
+    return found_devices
+
+def scan_i2c_devices():
+    try:
+        with LoadingIndicator(i, o, message="Scanning I2C bus"):
+            devices = scan_i2c_bus()
+    except:
+        logger.exception("I2C scan failed!")
+        PrettyPrinter("I2C scan failed!", i, o, 3)
+    if not devices:
+        Printer("No devices found", i, o, 2)
+    else:
+        device_menu_contents = [["{} - {}".format(hex(dev), state), lambda x=dev: i2c_device_menu(x)] for dev, state in devices.items()]
+        Menu(device_menu_contents, i, o, "I2C tools app, scan results menu").activate()
+
+def i2c_device_menu(addr):
+    m_c = [["Simple read", lambda: i2c_read_ui(addr)],
+           #["Simple write", lambda: i2c_write_ui(addr)],
+           ["Register read", lambda: i2c_read_ui(addr, reg=True)]]
+           #["Register write", lambda: i2c_write_ui(addr, reg=True)]]
+    Menu(m_c, i, o, "I2C tools app, device menu for address {}".format(hex(addr))).activate()
+
+last_values = []
+
+def i2c_read_ui(address, reg=None):
+    global last_values
+
+    if reg == True:
+        reg = UniversalInput(i, o, message="Register:", charmap="hex").activate()
+        if reg is None: # User picked "cancel"
+            return
+    if isinstance(reg, basestring):
+        reg = int(reg, 16)
+
+    last_values = []
+    values_on_screen = o.cols
+
+    def read_value(): # A helper function to read a value and format it into a list
+        global last_values
+        try:
+            if reg:
+                answer = "{} {}".format( hex(reg), hex(current_bus.read_byte_data(address, reg)) )
+            else:
+                answer = hex(current_bus.read_byte(address))
+        except IOError:
+            answer = "{} error".format(reg) if reg else "error"
+        last_values.append(answer)
+        last_values = last_values[:values_on_screen]
+        return list(reversed(last_values))
+
+    r = Refresher(read_value, i, o)
+    def change_interval(): # A helper function to adjust the Refresher's refresh interval while it's running
+        new_interval = IntegerAdjustInput(r.refresh_interval, i, o, message="Refresh interval:").activate()
+        if new_interval is not None:
+            r.set_refresh_interval(new_interval)
+    r.update_keymap({"KEY_RIGHT":change_interval})
+    r.activate()
+
+# Some globals for ZPUI
+main_menu = None
+callback = None
+# Some globals for us
+i = None
+o = None
+
+def change_range():
+    global config
+    dialogbox_options = [["Safe", "conservative"], ["Full", "full"], "c"]
+    dialogbox = DialogBox(dialogbox_options, i, o, message="Scan range", name="I2C tools app range setting dialogbox")
+    if config.get("scan_range", "conservative") == "full":
+        # setting dialogbox position to the "full" option as it's currently selected
+        dialogbox.set_start_option(1)
+    new_range = dialogbox.activate()
+    if new_range is not None:
+        config["scan_range"] = new_range
+        save_config(config)
+
+def change_settings():
+    settings = [["Scan range", change_range]]
+    Menu(settings, i, o, "I2C tools app settings menu").activate()
+
+main_menu_contents = [
+["Scan bus (bus 1)", scan_i2c_devices],
+["Settings", change_settings]
+]
+
+def init_app(input, output):
+    global main_menu, callback, i, o
+    i = input; o = output
+    main_menu = Menu(main_menu_contents, i, o, "I2C tools menu")
+    callback = main_menu.activate
+
diff --git a/zpui/apps/hardware_apps/status/__init__.py b/zpui/apps/hardware_apps/status/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/hardware_apps/status/main.py b/zpui/apps/hardware_apps/status/main.py
new file mode 100755
index 0000000..d3854f4
--- /dev/null
+++ b/zpui/apps/hardware_apps/status/main.py
@@ -0,0 +1,43 @@
+menu_name = "Assistant status" 
+
+from serial import Serial
+
+from ui import Refresher
+
+serial_device = "/dev/serial/by-id/usb-Silicon_Labs_CP2102_USB_to_UART_Bridge_Controller_0371-if00-port0"
+port = Serial(serial_device, 115200, timeout=1)
+
+def get_voltage():
+    port.flushInput()
+    answer = at_command('AT+CBC')
+    if answer is None: return None
+    if not answer.startswith('+CBC'): return None
+    voltage_str = answer.split(':')[1].split(',')[2]
+    voltage = int(voltage_str)/1000.0
+    return voltage
+
+def at_command(command):
+    port.write(command+b'\n')
+    echo = port.readline(len(command)+10)
+    if not command in echo:
+        return None
+    answer = port.readline(1000)
+    return answer.strip()
+
+def show_status():
+    bat_voltage = get_voltage()
+    if bat_voltage is not None:
+        bat_voltage = round(bat_voltage, 2)
+    data = [
+    "Battery: "+str(bat_voltage).rjust(o.cols-len("Battery: "))]
+    return data
+
+i = None; o = None
+
+def callback():
+    Refresher(show_status, i, o, 0.1, name="Assistant status monitor").activate()
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
diff --git a/zpui/apps/hardware_apps/thermo/__init__.py b/zpui/apps/hardware_apps/thermo/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/hardware_apps/thermo/main.py b/zpui/apps/hardware_apps/thermo/main.py
new file mode 100755
index 0000000..0242322
--- /dev/null
+++ b/zpui/apps/hardware_apps/thermo/main.py
@@ -0,0 +1,33 @@
+menu_name = "MLX90614" 
+
+from mlx90614 import MLX90614
+
+from ui import Refresher
+
+sensor = MLX90614()
+
+def show_temp():
+    try:
+        amb_temp = round(sensor.read_amb_temp(), 1)
+        obj_temp = round(sensor.read_obj_temp(), 1)
+    except IOError:
+        amb_temp = None
+        obj_temp = None
+    data = [
+    "Ambient:"+str(amb_temp).rjust(o.cols-len("Ambient:")),
+    "Object:"+str(obj_temp).rjust(o.cols-len("Object:"))]
+    return data
+
+#Callback global for ZPUI. It gets called when application is activated in the main menu
+
+#Some globals for us
+i = None #Input device
+o = None #Output device
+
+def callback():
+    Refresher(show_temp, i, o, 0.1, name="Temperature monitor").activate()
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
diff --git a/zpui/apps/hardware_apps/thermo/mlx90614.py b/zpui/apps/hardware_apps/thermo/mlx90614.py
new file mode 100644
index 0000000..c81abff
--- /dev/null
+++ b/zpui/apps/hardware_apps/thermo/mlx90614.py
@@ -0,0 +1,55 @@
+"""
+MLX90614 driver. 
+You might need to enter this command on your Raspberry Pi:
+echo "Y" > /sys/module/i2c_bcm2708/parameters/combined
+(I've put it in my rc.local so it's executed each bootup)
+"""
+
+import smbus
+
+class MLX90614(object):
+
+    MLX90614_RAWIR1=0x04
+    MLX90614_RAWIR2=0x05
+    MLX90614_TA=0x06
+    MLX90614_TOBJ1=0x07
+    MLX90614_TOBJ2=0x08
+
+    MLX90614_TOMAX=0x20
+    MLX90614_TOMIN=0x21
+    MLX90614_PWMCTRL=0x22
+    MLX90614_TARANGE=0x23
+    MLX90614_EMISS=0x24
+    MLX90614_CONFIG=0x25
+    MLX90614_ADDR=0x0E
+    MLX90614_ID1=0x3C
+    MLX90614_ID2=0x3D
+    MLX90614_ID3=0x3E
+    MLX90614_ID4=0x3F
+
+
+    def __init__(self, address=0x5a, bus_num=1):
+        self.bus_num = bus_num
+        self.address = address
+        self.bus = smbus.SMBus(bus=bus_num)
+
+    def read_reg(self, reg_addr):
+        return self.bus.read_word_data(self.address, reg_addr)
+
+    def data_to_temp(self, data):
+        temp = (data*0.02) - 273.15
+        return temp
+
+    def read_amb_temp(self):
+        data = self.read_reg(self.MLX90614_TA)
+        return self.data_to_temp(data)
+
+    def read_obj_temp(self):
+        data = self.read_reg(self.MLX90614_TOBJ1)
+        return self.data_to_temp(data)
+
+
+if __name__ == "__main__":
+    sensor = MLX90614()
+    print(sensor.read_amb_temp())
+    print(sensor.read_obj_temp())
diff --git a/zpui/apps/hardware_apps/usb/__init__.py b/zpui/apps/hardware_apps/usb/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/hardware_apps/usb/main.py b/zpui/apps/hardware_apps/usb/main.py
new file mode 100755
index 0000000..195b150
--- /dev/null
+++ b/zpui/apps/hardware_apps/usb/main.py
@@ -0,0 +1,71 @@
+
+
+from helpers import setup_logger
+
+menu_name = "USB control"
+
+from zerophone_hw import USB_DCDC
+from ui import Menu, Printer
+from time import sleep
+import os
+
+logger = setup_logger(__name__, "warning")
+i = None
+o = None
+
+dcdc = USB_DCDC()
+
+def dcdc_off_on():
+    dcdc.off()
+    sleep(0.5)
+    dcdc.on()
+
+usb_file = None
+usb_file_base_dir = "/sys/devices/platform/soc/"
+usb_control_file = "buspower"
+usb_full_path = None
+
+def usb_off_on():
+    with open(usb_full_path, "w") as f:
+        f.write("0")
+        sleep(0.5)
+        f.write("1")
+
+def usb_on():
+    with open(usb_full_path, "w") as f:
+        f.write("1")
+
+def usb_off():
+    with open(usb_full_path, "w") as f:
+        f.write("0")
+
+
+main_menu_contents = [ 
+["Restart 5V DC-DC", dcdc_off_on],
+["Turn 5V DC-DC on", dcdc.on],
+["Turn 5V DC-DC off", dcdc.off],
+["Restart USB bus", usb_off_on],
+["Turn USB bus on", usb_on],
+["Turn USB bus off", usb_off]
+]
+
+def init_app(input, output):
+    global i, o, usb_file, usb_full_path
+    i = input; o = output
+    #Find the usb device control directory
+    device_files = os.listdir(usb_file_base_dir)
+    usb_files = [file for file in device_files if file.endswith(".usb")]
+    if not usb_files:
+        logger.error("Can't find suitable USB file at {}! What's wrong with this hardware?".format(usb_file_base_dir))
+        raise IOError
+    usb_file = usb_files[0] #I'm guessing having more than one file would mean 
+    #having more than one USB controller, so this is not Raspberry Pi stuff anymore
+    #and I can only test this on a Pi right now.
+    usb_full_path = os.path.join(usb_file_base_dir, usb_file, usb_control_file)
+    if not os.path.exists(usb_full_path):
+        logger.error("Can't find {} file at {}! What's wrong with this hardware?".format(usb_control_file, usb_full_path))
+        raise IOError
+        
+def callback():
+    Menu(main_menu_contents, i, o, "USB app menu").activate()
+
diff --git a/zpui/apps/main_screen/__init__.py b/zpui/apps/main_screen/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/main_screen/main.py b/zpui/apps/main_screen/main.py
new file mode 100644
index 0000000..75c298d
--- /dev/null
+++ b/zpui/apps/main_screen/main.py
@@ -0,0 +1,88 @@
+import os
+from datetime import datetime
+from threading import Event
+from cProfile import Profile
+#from cProfile import runcall as profile
+
+from mock import Mock
+from apps import ZeroApp
+from ui import Menu, PrettyPrinter, Canvas
+
+from zerophone_hw import is_charging
+from PIL import ImageFont
+
+from __main__ import input_processor, cm # TODO: dirty hack, to be removed
+
+class App(ZeroApp):
+
+    menu_name = "Main screen"
+
+    def __init__(self, *args, **kwargs):
+        ZeroApp.__init__(self, *args, **kwargs)
+        #input_processor.set_global_callback("KEY_HANGUP", self.switch_to_self)
+
+    #def switch_to_self(self):
+    #    cm.switch_to_context("apps/main_screen")
+
+    def on_start(self, *args, **kwargs):
+        screen = MainScreen([], self.i, self.o, "Main screen")
+        screen.activate()
+        screen.p.print_stats(2)
+
+class MainScreen(Menu):
+    is_numbered = False
+
+    def set_view(self, config):
+        self.view = Mock()
+
+    def idle_loop(self):
+        Menu.idle_loop(self)
+        self.refresh()
+
+    #def switch_to_main_menu(self):
+    #    cm.switch_to_context("main")
+
+    #def switch_to_stopwatch(self):
+    #    cm.switch_to_context("stopwatch")
+
+    #def generate_keymap(self):
+    #    keymap = {"KEY_F1":self.switch_to_main_menu, "KEY_F2":self.switch_to_stopwatch}
+    #    Menu.generate_keymap(self)
+    #    self.keymap.update(keymap)
+
+    def validate_contents(self, contents):
+        self.p = Profile()
+
+    def process_contents(self):
+        pass
+
+    def draw_battery_icon(self, c):
+        c.rectangle(("-20", 0, "-2", 7))
+        c.rectangle(("-16", 0, "-2", 7), fill="white")
+        c.rectangle(("-22", 1, "-20", 6), fill="white")
+        if is_charging():
+            c.text("Ch", ("-15", -2))
+
+    def draw_network_icon(self, c):
+        c.line((3, 1, 3, 6))
+        c.line((1, 1, 5, 1))
+        c.point(((1, 2), (5, 2)))
+        offset = 7
+        for x in reversed(range(6)):
+            c.line((x*2+offset, 6-x, x*2+offset, 6))
+
+    def refresh(self):
+        now = datetime.now()
+        hhmm = now.strftime("%H:%M")
+        ss = now.strftime("%S")
+        ddmmyy = now.strftime("%d%m%y")
+        c = Canvas(self.o)
+        #c.line((0, 8, c.width, 8), fill="white")
+        c.text(hhmm, (5, 8), font=("Fixedsys62.ttf", 32))
+        c.text(ss, (87, 23))
+        c.text(ddmmyy, (90, 12))
+        c.text("0 notifications", (10, 39))
+        self.draw_battery_icon(c)
+        self.draw_network_icon(c)
+        image = c.get_image()
+        self.p.runcall( self.o.display_image, image )
diff --git a/zpui/apps/media_apps/__init__.py b/zpui/apps/media_apps/__init__.py
new file mode 100644
index 0000000..6bed4f9
--- /dev/null
+++ b/zpui/apps/media_apps/__init__.py
@@ -0,0 +1 @@
+_menu_name = "Multimedia"
diff --git a/zpui/apps/media_apps/mocp/__init__.py b/zpui/apps/media_apps/mocp/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/media_apps/mocp/main.py b/zpui/apps/media_apps/mocp/main.py
new file mode 100755
index 0000000..0fbf429
--- /dev/null
+++ b/zpui/apps/media_apps/mocp/main.py
@@ -0,0 +1,62 @@
+menu_name = "MOCP control"
+
+from subprocess import call
+from ui import Menu, Printer, DialogBox
+
+callback = None
+i = None
+o = None
+
+#MOCP commands
+def mocp_command(*command, **options):
+    try:
+        return call(['mocp'] + list(command))
+    except:
+        #We shouldn't print anything to the screen if called from a non-maskable callback
+        silent = options.get("silent", False)
+        if not silent:
+            Printer(["Oops", "Is mocp there?"], i, o, 1)
+
+def mocp_toggle_play():
+    mocp_command("-G")
+
+def mocp_next(silent=False):
+    mocp_command("-f", silent=silent)
+
+def mocp_prev(silent=False):
+    mocp_command("-r", silent=silent)
+
+def option_switch_dialog(option):
+    answer = DialogBox([["On", 'o'], ["Off", 'u'], ["Toggle", "t"]], i, o, message=option.capitalize()+":", name="MOCP {} option control dialog".format(option)).activate()
+    if answer: mocp_switch_option(answer, option)
+
+shuffle_dialog = lambda: option_switch_dialog("shuffle")
+repeat_dialog = lambda: option_switch_dialog("repeat")
+autonext_dialog = lambda: option_switch_dialog("autonext")
+
+def mocp_switch_option(switch_type, option):
+    mocp_command("-{}".format(switch_type), option)
+
+main_menu_contents = [ 
+["Toggle play/pause", mocp_toggle_play],
+["Next song", mocp_next],
+["Previous song", mocp_prev],
+["Shuffle", shuffle_dialog],
+["Repeat", repeat_dialog],
+["Autonext", autonext_dialog]
+]
+
+def set_global_callbacks():
+    import __main__ #HHHHHAAAAAAAAAAAXXXX
+    __main__.input_processor.set_global_callback("KEY_PROG1", mocp_next)
+    __main__.input_processor.set_global_callback("KEY_CAMERA", mocp_prev)
+
+def init_app(input, output):
+    global main_menu, callback, i, o
+    i = input; o = output
+    set_global_callbacks()
+    #i.set_nonmaskable_callback("KEY_PROG1", lambda: mocp_next(silent=True) )
+    #i.set_nonmaskable_callback("KEY_CAMERA", lambda: mocp_prev(silent=True) )
+    main_menu = Menu(main_menu_contents, i, o, "MOCP menu")
+    callback = main_menu.activate
+
diff --git a/zpui/apps/media_apps/volume/__init__.py b/zpui/apps/media_apps/volume/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/media_apps/volume/main.py b/zpui/apps/media_apps/volume/main.py
new file mode 100755
index 0000000..8f2657f
--- /dev/null
+++ b/zpui/apps/media_apps/volume/main.py
@@ -0,0 +1,116 @@
+menu_name = "Volume control"
+
+config_filename = "config.json"
+default_config = '{"card":0, "channel":"PCM", "adjust_amount":1, "adjust_type":"dB"}'
+
+i = None
+o = None
+callback = None
+
+from helpers import read_or_create_config, write_config, local_path_gen
+local_path = local_path_gen(__name__)
+config_path = local_path(config_filename)
+config = read_or_create_config(config_path, default_config, menu_name+" app")
+
+import os
+from subprocess import call, check_output
+
+from ui import Menu, IntegerAdjustInput, Listbox, ellipsize
+
+#amixer commands
+def amixer_command(command):
+    with open(os.devnull, "w") as f:
+        return call(['amixer'] + list(command), stdout=f)
+
+def amixer_get_channels():
+    controls = []
+    output = check_output(['amixer', '-c', str(config["card"])])
+    for line in output.split('\n'):
+        if 'mixer control' in line:
+            controls.append(line.split("'")[1])
+    return controls
+        
+def amixer_sset(sset_value):
+    return amixer_command(["-c", str(config["card"]), "--", "sset", config["channel"], sset_value])
+
+def get_adjust_value():
+    return str(config["adjust_amount"])+config["adjust_type"]
+
+def plus_volume():
+    return amixer_sset(get_adjust_value()+'+')
+
+def minus_volume():
+    return amixer_sset(get_adjust_value()+'-')
+
+def toggle_mute():
+    return amixer_sset("toggle")
+
+def settings_menu():
+    menu_contents = [
+    #["Select card", select_card],
+    ["Select channel", select_channel],
+    ["Adjust type", select_adjust_type],
+    ["Adjust amount", change_adjust_amount]]
+    Menu(menu_contents, i, o, "Settings menu").activate()
+
+def select_card():
+    #TODO get a list of all cards
+    global config
+    contents = []
+    cards = [] 
+    for card in cards:
+        contents.append([ellipsize(card["name"], o.cols), card["id"]])
+    card_id = Listbox(contents, i, o, "Card selection listbox").activate()
+    if card_id is None:
+        return False
+    config["card"] = card_id
+    write_config(config, config_path)
+
+def select_channel():
+    global config
+    contents = []
+    channels = amixer_get_channels()
+    for channel in channels:
+        contents.append([ellipsize(channel, o.cols), channel])
+    channel = Listbox(contents, i, o, "Channel selection listbox").activate()
+    if channel is None:
+        return False
+    config["channel"] = channel
+    write_config(config, config_path)
+
+def select_adjust_type():
+    global config
+    contents = [
+    ["Percent", '%'],
+    ["Decibels", 'dB'],
+    ["HW value", '']]
+    adjust_type = Listbox(contents, i, o, "Adjust selection listbox").activate()
+    if adjust_type is None:
+        return False
+    config["adjust_type"] = adjust_type
+    write_config(config, config_path)
+
+def change_adjust_amount():
+    global config
+    value = IntegerAdjustInput(config['adjust_amount'], i, o, message="Adjust amount", interval=1).activate()
+    if value is None:
+        return False
+    config["adjust_amount"] = value
+    write_config(config, config_path)
+
+def set_global_callbacks():
+    import __main__ #HHHHHAAAAAAAAAAAXXXX
+    __main__.input_processor.set_global_callback("KEY_VOLUMEUP", plus_volume)
+    __main__.input_processor.set_global_callback("KEY_VOLUMEDOWN", minus_volume)
+
+def init_app(input, output):
+    global i, o, callback
+    i = input; o = output
+    set_global_callbacks()
+    main_menu_contents = [ 
+    ["Increase volume", plus_volume],
+    ["Decrease volume", minus_volume],
+    ["Toggle mute", toggle_mute],
+    ["Settings", settings_menu]]
+    callback = Menu(main_menu_contents, i, o, "Volume menu").activate
+
diff --git a/zpui/apps/network_apps/__init__.py b/zpui/apps/network_apps/__init__.py
new file mode 100644
index 0000000..9019e28
--- /dev/null
+++ b/zpui/apps/network_apps/__init__.py
@@ -0,0 +1,6 @@
+_menu_name = "Networking"
+_ordering = [
+"wpa_cli",
+"network",
+"nmap",
+"upnp"]
diff --git a/zpui/apps/network_apps/network/__init__.py b/zpui/apps/network_apps/network/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/network_apps/network/if_info.py b/zpui/apps/network_apps/network/if_info.py
new file mode 100644
index 0000000..f3a97b4
--- /dev/null
+++ b/zpui/apps/network_apps/network/if_info.py
@@ -0,0 +1,47 @@
+import subprocess
+#Description used for all interfaces
+from copy import copy
+
+if_description = { 
+   'state':'down',
+   'addr':None,
+   'addr6':None,
+   'ph_addr':None    
+}
+
+def parse_params(param_string):
+    state = None
+    words = param_string.split(" ")
+    for index, word in enumerate(words):
+        if word == 'state':
+            state = words[index+1].lower()
+    return {'state':state}
+
+def parse_ip_addr():
+    interfaces = {}
+    current_if = None
+    ip_output = subprocess.check_output(['ip', 'addr'])
+    ip_output = [line for line in ip_output.split('\n') if line != ""]
+    for line in ip_output:
+        if line[0].isdigit(): #First line for interface
+            num, if_name, params = line.split(':', 2)
+            if_name = if_name.strip(" ")
+            current_if = if_name
+            interfaces[if_name] = copy(if_description)
+            param_dict = parse_params(params)
+            interfaces[if_name].update(param_dict)
+        else: #Lines that continue describing interfaces
+            line = line.lstrip()
+            if line.startswith('inet '):
+                words = line.split(" ")
+                interfaces[current_if]['addr'] = words[1]
+            if line.startswith('link/ether'):
+                words = line.split(" ")
+                interfaces[current_if]['ph_addr'] = words[1]
+            if line.startswith('inet6'):
+                words = line.split(" ")
+                interfaces[current_if]['addr6'] = words[1]
+    return interfaces
+
+if __name__ == "__main__":
+    print(parse_ip_addr())
diff --git a/zpui/apps/network_apps/network/main.py b/zpui/apps/network_apps/network/main.py
new file mode 100755
index 0000000..92ed368
--- /dev/null
+++ b/zpui/apps/network_apps/network/main.py
@@ -0,0 +1,81 @@
+menu_name = "Interfaces"
+#Some globals for LCS
+callback = None
+#Some globals for us
+if_menu = None
+i = None
+o = None
+
+from subprocess import call
+from time import sleep
+
+from ui import Menu, Printer
+from if_info import parse_ip_addr
+
+def show_ifc_data(ifc_name, ifc_data):
+    if ifc_data['addr'] is not None:
+        ip, mask = str(ifc_data['addr']).rsplit('/', 1)
+    else:
+        ip = "None"
+        mask = "0"
+    ip_header = "IP: "
+    mask_str = "/{}".format(mask)
+    ip_header_str = ip_header + mask_str.rjust(o.cols-len(ip_header)) #Magic to make it beautiful
+    ifd_menu_contents = [
+    ["state: "+str(ifc_data['state'])],
+    [[ip_header_str, ip]],
+    ["IP6: "+str(ifc_data['addr6']), lambda: Printer(str(ifc_data['addr6']), i, o, 3)],
+    ["MAC: "+str(ifc_data['ph_addr'])]
+    ]
+    ifd_menu = Menu(ifd_menu_contents, i, o, "{} interface data menu".format(ifc_name), entry_height=2)
+    ifd_menu.activate()
+
+def update_if_menu_contents():
+    #This function builds a menu out of all the interface names, each having a callback to show_if_function with interface name as argument
+    global if_menu
+    menu_contents = []
+    ifc_dict = parse_ip_addr()
+    for ifc in ifc_dict:
+        ifc_data = ifc_dict[ifc]
+        menu_contents.append([ifc, lambda x=ifc, y=ifc_data: show_ifc_data(x, y)])
+    menu_contents.append(["Exit", 'exit'])
+    if_menu.set_contents(menu_contents)
+
+def activate_wrapper(activate_cb):
+    def wrapper():
+        update_if_menu_contents()
+        activate_cb()
+    return wrapper
+
+def init_app(input, output):
+    global if_menu, callback, i, o
+    i = input; o = output
+    if_menu = Menu([], i, o, "Interface selection menu")
+    if_menu.activate = activate_wrapper(if_menu.activate) #Decorating around the menu.activate module so that every time menu is activated interface data is refreshed
+    callback = if_menu.activate
+    
+
+
+"""
+def i2c_detect():
+    o.clear()  #This code for printing data one element on one row begs for a separate UI element module
+    o.display_data("Scanning:")
+    bus = smbus.SMBus(1) # 1 indicates /dev/i2c-1
+    found_devices = []
+    device_count = len(found_devices)
+    if device_count == 0:
+        o.display_data("No devices found")
+        sleep(2)
+    else:
+        screen_rows = o.rows
+        num_screens = device_count/screen_rows
+        if device_count%screen_rows != 0: #There is one more screen, it's just not full but we need to add one more.
+            num_screens += 1
+        for screen_num in range(num_screens):
+            shown_element_numbers = [(screen_num*screen_rows)+i for i in range(screen_rows)]
+            screen_data = [found_devices[i] for i in shown_element_numbers] 
+            o.clear()
+            o.display_data(*screen_data)
+            sleep(1)
+"""
+
diff --git a/zpui/apps/network_apps/nmap/.gitignore b/zpui/apps/network_apps/nmap/.gitignore
new file mode 100644
index 0000000..a9a1bd3
--- /dev/null
+++ b/zpui/apps/network_apps/nmap/.gitignore
@@ -0,0 +1 @@
+reports/
diff --git a/zpui/apps/network_apps/nmap/__init__.py b/zpui/apps/network_apps/nmap/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/network_apps/nmap/if_info.py b/zpui/apps/network_apps/nmap/if_info.py
new file mode 100644
index 0000000..ffe23fa
--- /dev/null
+++ b/zpui/apps/network_apps/nmap/if_info.py
@@ -0,0 +1,83 @@
+import subprocess
+#Description used for all interfaces
+from copy import copy
+
+if_description = { 
+   'state':'down',
+   'addr':None,
+   'addr6':None,
+   'ph_addr':None    
+}
+
+def parse_params(param_string):
+    state = None
+    words = param_string.split(" ")
+    for index, word in enumerate(words):
+        if word == 'state':
+            state = words[index+1].lower()
+    return {'state':state}
+
+def get_ip_addr():
+    interfaces = {}
+    current_if = None
+    ip_output = subprocess.check_output(['ip', 'addr'])
+    ip_output = [line for line in ip_output.split('\n') if line != ""]
+    for line in ip_output:
+        if line[0].isdigit(): #First line for interface
+            num, if_name, params = line.split(':', 2)
+            if_name = if_name.strip(" ")
+            current_if = if_name
+            interfaces[if_name] = copy(if_description)
+            param_dict = parse_params(params)
+            interfaces[if_name].update(param_dict)
+        else: #Lines that continue describing interfaces
+            line = line.lstrip()
+            if line.startswith('inet '):
+                words = line.split(" ")
+                interfaces[current_if]['addr'] = words[1]
+            if line.startswith('link/ether'):
+                words = line.split(" ")
+                interfaces[current_if]['ph_addr'] = words[1]
+            if line.startswith('inet6'):
+                words = line.split(" ")
+                interfaces[current_if]['addr6'] = words[1]
+    return interfaces
+
+def get_network_from_ip(ip_str):
+    ip, mask_len_str = ip_str.split('/')
+    mask_len = int(mask_len_str)
+    ip_byte_repr_str = ip_to_byte_str(ip)
+    net_ip_byte_repr_str = ip_byte_repr_str[:mask_len][::-1].zfill(32)[::-1]
+    network_ip = byte_str_to_ip(net_ip_byte_repr_str)
+    return "{}/{}".format(network_ip, mask_len_str)
+
+def ip_to_byte_str(ip):
+    octets = ip.split('.')
+    ip_byte_repr_str = "".join([bin(int(octet))[2:].zfill(8) for octet in octets])
+    return ip_byte_repr_str
+
+def byte_str_to_ip(byte_str):
+    octets = [str(int(byte_str[i*8:][:8], 2)) for i in range(4)]
+    ip = ".".join(octets)
+    return ip
+
+def sort_ips(ips):
+    #Let's try and sort the IPs by their integer representation
+    ip_to_int_repr = {}
+    for ip in ips:
+        #Converting IP to its integer value
+        int_repr = int(ip_to_byte_str(ip), 2)
+        #Adding it to a dictionary to preserve integer_ip-to-ip link
+        ip_to_int_repr[int_repr] = ip
+    #Sorting the integer representations
+    int_reprs = ip_to_int_repr.keys()
+    int_reprs.sort()
+    #Now returning the IPs associated with integer representations - by order of elements the sorted list
+    return [ip_to_int_repr[int_repr] for int_repr in int_reprs]
+        
+
+if __name__ == "__main__":
+    print(get_ip_addr())
+    ip = "192.168.88.153/24"
+    network = get_network_from_ip(ip)
+    print("IP {} is from network {}".format(ip, network))
diff --git a/zpui/apps/network_apps/nmap/main.py b/zpui/apps/network_apps/nmap/main.py
new file mode 100755
index 0000000..88140ec
--- /dev/null
+++ b/zpui/apps/network_apps/nmap/main.py
@@ -0,0 +1,356 @@
+menu_name = "Nmap"
+i = None
+o = None
+
+from functools import wraps
+import time
+import os, sys
+
+from ui import Menu, Printer, Checkbox, format_for_screen as ffs, NumpadNumberInput, NumpadCharInput
+from if_info import get_ip_addr, get_network_from_ip, sort_ips
+
+try:
+    import nmap
+except ImportError:
+    nmap = None #So we can give an error if nmap module is missing
+
+#Folder name - to store the saved reports
+report_dir = "reports"
+
+#Ports for "unsafe ports" heuristics
+#Taken mostly from Wikipedia: https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers
+#Can lookup info here, too: http://www.speedguide.net/port.php?port=$PORT_NUM
+
+#Third parameter in list is whether port is selected by default in "port choice" checkbox or not
+heuristic_ports = [["SSH,Telnet",          "22,23",                         True],
+                   ["HTTP,HTTPS",          "80,443,8080",                   True],
+                   ["DNS,TFTP,NTP,RADIUS", "53,69,123,1812",               False],
+                   ["SQL,MQTT,cPanel",    "1433,1434,1883,2095,2096,2083",  True],
+                   ["Printers",            "9100,515,631,170",              True],
+                   ["Routers",             "32764,8089,8291",              True],
+                   ["Git/SVN/Bitbucket",   "9418,3690,7990",               False],
+                   ["File sharing",        "445,21,944,2049",               True],
+                   ["Windows stuff",       "135,445,593",                   True],
+                   ["Misc",                "19,502",                       False]]
+
+
+#Figuring out the path of the app folder - not that simple
+current_module_path = os.path.dirname(sys.modules[__name__].__file__)
+if report_dir not in os.listdir(current_module_path):
+    os.mkdir(os.path.join(current_module_path, report_dir))
+
+report_dir_full_path = os.path.join(current_module_path, report_dir)
+
+#Global storage variables - can be dumped to a file at any time
+current_scan = None
+current_filename = ""
+
+
+#Smart scan functions
+
+def smart_scan():
+    #First, getting all available interfaces
+    networks = []
+    interface_data = get_ip_addr()
+    for interface_name in interface_data.keys():
+        #Autofiltering unsuitable interfaces
+        interface_info = interface_data[interface_name]
+        state = interface_info["state"]
+        ip = interface_info["addr"] if interface_info["addr"] else None
+        if state == "up" and ip is not None:
+            #Only using interface if it's up and has an IP
+            #Automatically filters out localhost
+            networks.append( ["{}:{}".format(interface_name, ip), ip] )
+    if not networks:
+        #No suitable interfaces found after filtering
+        Printer(ffs("No suitable network interfaces found!", o.cols), i, o, 3)
+        return None
+    if len(networks) == 1:
+        #Only one good interface, using it automatically
+        network_ip = networks[0][1]
+    else:
+        #Allowing user to pick an interface
+        network_ip = Listbox(networks, i, o).activate()
+        if network_ip is None: #Listbox exited without making a choice
+            return None
+    network_ip = get_network_from_ip(network_ip)
+    chosen_ports = Checkbox(heuristic_ports, i, o, name="NMap: select port types", final_button_name="Run scan").activate()
+    if chosen_ports is None: return None
+    chosen_port_list = [port_choice for port_choice in chosen_ports if chosen_ports[port_choice] == True]
+    port_string = ",".join(chosen_port_list)
+    #So the library I'm using is silently failing. I launch the scan from command-line and see:
+    #
+    #WARNING: Duplicate port number(s) specified.  Are you alert enough to be using Nmap?  Have some coffee or Jolt(tm).
+    #
+    #Well, thank you, but it's a script and fuck off.
+    port_string = ",".join(list(set(port_string.split(","))))
+    #De-duplicated and ready to go.
+    print(port_string)
+    Printer(ffs("Scanning {}".format(network_ip), o.cols), i, o, 0)
+    nm = nmap.PortScanner()
+    nm.scan(network_ip, arguments="-n -p {}".format(port_string))
+    print(nm)
+    show_quick_scan_results_for_network(network_ip, nm)
+
+#"Arbitrary IP/network scan" functions
+
+class NumpadIPAddressInput(NumpadNumberInput):
+    #Making an UI input element with IP address-suitable character mapping
+    default_mapping = {"1":"1", "2":"2", "3":"3", "4":"4", "5":"5", "6":"6", "7":"7", "8":"8", "9":"9", "0":"0", "*":".*", "#":"/"}
+
+def cleanup_validate_ip(ip):
+    if "/" in ip:
+        #Got a netmask, checking it
+        parts = ip.split("/")
+        #Do we have more than one / in IP?
+        if len(parts) != 2:
+            raise ValueError("stray / in IP!")
+        else:
+            ip, netmask = parts
+        #Is netmask an integer?
+        try:
+            netmask = int(netmask, 10)
+        except:
+            raise ValueError("netmask is not an integer")
+        #Is netmask between 0 and 32?
+        if netmask < 0 or netmask > 32:
+            raise ValueError("netmask out of IPv4 range")
+    else:
+        #Got no netmask
+        netmask = None
+    octets = ip.split(".")
+    #Do we have exactly 4 octets?
+    if len(octets) != 4:
+        raise ValueError("expected x.x.x.x format")
+    #A list to for invalid octets - to show them all in one error message
+    invalid_octets = []
+    #A list for new octets - in case any are fixed
+    new_octets = []
+    for octet in octets:
+        if octet == "":
+            #Can have an empty octet, which counts as 0
+            #Allows to write "127...1" (sorry, no "127.1" yet)
+            octet = "0"
+            new_octets.append(octet)
+            continue
+        elif octet == "*":
+            #Nothing to check
+            new_octets.append(octet)
+            continue
+        #Is each octet a proper integer?
+        try:
+            octet = int(octet, 10)
+        except:
+            invalid_octets.append(octet)
+            continue #One octet invalid but need to go to the next one
+        #Is each octet in proper range?
+        if octet < 0 or octet > 255:
+            invalid_octets.append(octet)
+        else:
+            new_octets.append(octet)
+    if len(invalid_octets) == 1:
+        #Just one invalid octet
+        raise ValueError("invalid octet: {}".format(invalid_octets[0]))
+    elif len(invalid_octets) > 1:
+        #Multiple invalid octets
+        octet_string = ",".join([str(octet) for octet in invalid_octets])
+        raise ValueError("invalid octets: {}".format(octet_string))
+    else:
+        #No invalid octets, assembling the IP and returning it
+        ip = ".".join([str(octet) for octet in new_octets])
+        if netmask: ip = ip+"/"+str(netmask)
+        return ip
+
+def scan_arbitrary_ip():
+    ip = NumpadIPAddressInput(i, o, message="IP to scan:").activate()
+    if ip is None: return #Cancelled
+    valid_ip = False
+    while not valid_ip:
+        #Validating the IP in a loop
+        try:
+            ip = cleanup_validate_ip(ip)
+        except ValueError as e:
+            #If not valid, giving an opportunity to either fix it or cancel the scan
+            Printer(ffs("Invalid ip: {}! Reason: {}".format(ip, e.message), o.cols), i, o, 3)
+            ip = NumpadIPAddressInput(i, o, message="Fix the IP", value=ip).activate()
+            if ip is None: return #Cancelled
+            #To the next loop iteration
+        else:
+            valid_ip = True
+    if "/" in ip:
+        #Network address with a netmask, interpreting it as a network address and just calling nmap
+        quick_scan_network_by_ip(ip)
+    elif "*" in ip:
+        Printer(ffs("Wildcards without a netmask are not yet supported by the interface, sorry", o.cols), i, o, 3)
+        return
+    else:
+        scan_ip(ip)
+    
+
+#"Dump scan to file" functions
+
+def dump_current_scan_to_file():
+    if current_scan is not None:
+        filename = "{}.xml".format(current_filename)
+        filename = filename.replace("/", "-") #For netmasks
+        report_path = os.path.join(report_dir_full_path, filename)
+        with open(report_path, "w") as f:
+            xml = current_scan.get_nmap_last_output()
+            f.write(xml)
+        print("Saved report {}".format(filename))
+
+def save_restore_global_storage(func):
+    """A decorator that restores previous contents of report storage 
+    once the function that last overwrote it exits."""
+    @wraps(func)
+    def wrapper(*args, **kwargs):
+        global current_scan, current_filename
+        __current_scan__ = current_scan
+        __current_filename__ = current_filename
+        result = func(*args, **kwargs)
+        current_scan = __current_scan__
+        current_filename = __current_filename__
+        return result
+    return wrapper
+
+
+#IP/interface/network scanning functions
+
+def scan_localhost(host = "127.0.0.1"):
+    scan_ip(host)
+
+def scan_ip(ip, ports="0-1023"):
+    Printer("Scanning {}:{}".format(ip, ports), i, o, 0) #Leaves the message on the screen
+    nm = nmap.PortScanner()
+    nm.scan(ip, ports)
+    show_scan_results_for_ip(ip, nm)
+
+def quick_scan_network_by_ip(ip_on_network):
+    if ip_on_network == "None":
+        Printer("No IP to scan!", i, o, 2)
+        return False
+    network_ip = get_network_from_ip(ip_on_network)
+    Printer("Scanning {}".format(network_ip), i, o, 0)
+    nm = nmap.PortScanner()
+    nm.scan(network_ip, arguments="-sn")
+    show_quick_scan_results_for_network(network_ip, nm)
+
+    
+#Different menus
+
+def scan_network_menu():
+    #A report to be passed to Menu object
+    networks = []
+    #External library function that parses "ip addr" output
+    interface_data = get_ip_addr()
+    for interface_name in interface_data.keys():
+        interface_info = interface_data[interface_name]
+        state = interface_info["state"]
+        ip = interface_info["addr"] if interface_info["addr"] else "None"
+        networks.append( ["{}:{}, {}".format(interface_name, state, ip), lambda x=ip: quick_scan_network_by_ip(x)] )
+    Menu(networks, i, o).activate()
+
+def ip_info_menu(ip_info):
+    ip = ip_info["addresses"]["ipv4"]
+    mac = ip_info["addresses"]["mac"] if "mac" in ip_info["addresses"] else "Unknown MAC"
+    vendor = ip_info["vendor"][mac] if mac in ip_info["vendor"] else "Unknown vendor"
+    menu_contents = [
+    ["IP: {}".format(ip)],
+    [mac],
+    [vendor]]
+    if "tcp" in ip_info.keys() and ip_info["tcp"]:
+        open_ports = []
+        for port_num in ip_info["tcp"].keys():
+            port_info = ip_info["tcp"][port_num]
+            if port_info["state"] == 'open':
+                open_ports.append(["{}:{}".format(port_num, port_info["name"])])
+        if open_ports:
+            menu_contents.append(["Open ports:"])
+            menu_contents += open_ports
+        else:
+            menu_contents.append(["No open ports found"])
+    menu_contents.append(["-Scan ports 0-1023", lambda: scan_ip(ip)])
+    Menu(menu_contents, i, o).activate()
+    
+
+#Scan result display functions
+
+@save_restore_global_storage
+def show_scan_results_for_ip(ip, ip_results):
+    global current_scan, current_filename
+    current_scan = ip_results
+    current_filename = "ip_{}_{}".format(ip, time.strftime("%Y%m%d-%H%M%S"))
+    ip_result = ip_results[ip]
+    #Assembling a report we can pass straight to Menu object
+    report = []
+    #IP, state, hostname
+    ip = ip_result["addresses"]["ipv4"]
+    report.append([ ["IP: {}, {}".format(ip, ip_result.state())] ])
+    report.append([ ["Host: {}".format(ip_result.hostname())] ])
+    #Now assemble a list of open ports:
+    protocols = ip_result.all_protocols()
+    if protocols:
+        report.append([["Open ports:"]])
+        for protocol in protocols:
+            ports = ip_result[protocol].keys()
+            ports.sort()
+            for port in ports:
+                report.append([["  {}:{}".format(protocol, port)]])
+    else: #No open ports for any protocol found?
+        report.append([["No open ports found"]])
+    #Show report
+    Menu(report, i, o).activate()
+
+@save_restore_global_storage
+def show_quick_scan_results_for_network(net_ip, net_results):
+    global current_scan, current_filename
+    current_scan = net_results
+    current_filename = "net_{}_{}".format(net_ip, time.strftime("%Y%m%d-%H%M%S"))
+    net_report = []
+    ips = net_results.all_hosts()
+    ips = sort_ips(ips)
+    for ip in ips:
+        result = net_results[ip]
+        open_ports_found = "tcp" in result.keys() and result["tcp"]
+        if open_ports_found:
+            open_port_count = len([port_desc for port_desc in result["tcp"].values() if "state" in port_desc and port_desc["state"] == "open"])
+        mac = result["addresses"]["mac"] if "mac" in result["addresses"] else "Unknown MAC"
+        if result["vendor"] and mac in result["vendor"].keys():
+            info_str = result["vendor"][mac]
+        else:
+            info_str = mac
+        if open_ports_found:
+            info_str = "{}P;{}".format(open_port_count, info_str)
+        net_report.append([[ip, info_str], lambda x=result: ip_info_menu(x)])
+    Menu(net_report, i, o, entry_height=2).activate()
+
+    
+#ZPUI functions
+
+def callback():
+    #Check if we have all the software necessary for the app to work
+    #If not, show error messages and exit
+    if nmap is None:
+        Printer(ffs("nmap Python module not found!", o.cols), i, o, 3)
+        return False
+    try:
+        nm = nmap.PortScanner()
+    except nmap.nmap.PortScannerError:
+        Printer(ffs("nmap not installed!", o.cols), i, o, 3)
+        return False
+    #Dump function support
+    i.set_maskable_callback("KEY_F5", dump_current_scan_to_file)
+    #Constructing and loading app main menu
+    menu_contents = [
+    ["Smart scan", smart_scan],
+    ["Scan a network", scan_network_menu],
+    ["Scan arbitrary IP", scan_arbitrary_ip],
+    ["Scan localhost", scan_localhost]
+    ]
+    Menu(menu_contents, i, o).activate()
+    #Have to remove the dump function callback because once application exits it isn't removed automatically
+    i.remove_maskable_callback("KEY_F5")
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
diff --git a/zpui/apps/network_apps/upnp/__init__.py b/zpui/apps/network_apps/upnp/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/network_apps/upnp/main.py b/zpui/apps/network_apps/upnp/main.py
new file mode 100755
index 0000000..56db893
--- /dev/null
+++ b/zpui/apps/network_apps/upnp/main.py
@@ -0,0 +1,87 @@
+#Code taken from here: https://habrahabr.ru/post/332812/ and, consequently, from here: https://www.electricmonk.nl/log/2016/07/05/exploring-upnp-with-python/
+
+
+from helpers import setup_logger
+
+menu_name = "UPnP/SSDP scan"
+
+from ui import Menu, Printer, IntegerAdjustInput, format_for_screen as ffs
+from helpers import read_or_create_config, write_config, local_path_gen
+
+from collections import OrderedDict
+from traceback import format_exc
+from time import sleep
+import socket
+import sys
+import os
+
+
+logger = setup_logger(__name__, "warning")
+
+#Some globals for us
+i = None
+o = None
+
+config_filename = "config.json"
+default_config = '{"timeout":1,"dst":"239.255.255.250","st":"upnp:rootdevice"}'
+
+local_path = local_path_gen(__name__)
+config_path = local_path(config_filename)
+config = read_or_create_config(config_path, default_config, menu_name+" app")
+
+def run_scan():
+    Printer("Scanning:", i, o, 0)
+    msg = [
+        'M-SEARCH * HTTP/1.1',
+        'Host:{}:1900'.format(config["dst"]),
+        'ST:{}'.format(config["st"]),
+        'Man:"ssdp:discover"',
+        'MX:1',
+        '']
+    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
+    s.settimeout(config["timeout"])
+    s.sendto('\r\n'.join(msg), (config["dst"], 1900) )
+
+    found_devices = OrderedDict()
+    while True:
+        try:
+            data, addr = s.recvfrom(32*1024)
+        except socket.timeout:
+            break
+        except Exception as e:
+            logger.error(format_exc())
+            logger.exception(e)
+        else:
+            ip_str = "{}:{}".format(*addr)
+            found_devices[ip_str] = data
+    
+    if not found_devices:
+        Printer("No devices found", i, o, 2)
+    else:
+        data = [[ip, lambda x=ip, y=d: read_info(x, y)] for ip, d in found_devices.iteritems()]
+        Menu(data, i, o).activate()
+
+def read_info(ip_str, data):
+    Printer(ffs("[+] {}\n{}".format(ip_str, data), o.cols), i, o, 5)
+
+def adjust_timeout():
+    global config
+    timeout = IntegerAdjustInput(config["timeout"], i, o, message="Socket timeout:").activate()
+    if timeout is not None and timeout > 0:
+        config["timeout"] = timeout
+        write_config(config, config_path)
+    elif not timeout > 0:
+        Printer(ffs("Timeout has to be larger than 0!", o.cols), i, o)
+
+main_menu_contents = [
+["Scan", run_scan],
+["Change timeout", adjust_timeout]
+]
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
+def callback():
+    Menu(main_menu_contents, i, o, "UPnP/SSDP app menu").activate()
+
diff --git a/zpui/apps/network_apps/wpa_cli/__init__.py b/zpui/apps/network_apps/wpa_cli/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/network_apps/wpa_cli/main.py b/zpui/apps/network_apps/wpa_cli/main.py
new file mode 100755
index 0000000..46ee127
--- /dev/null
+++ b/zpui/apps/network_apps/wpa_cli/main.py
@@ -0,0 +1,332 @@
+from helpers import setup_logger
+
+menu_name = "Wireless"
+
+i = None
+o = None
+
+from time import sleep
+from threading import Thread
+from traceback import format_exc
+
+from ui import Menu, Printer, MenuExitException, UniversalInput, Refresher, DialogBox, ellipsize
+
+import wpa_cli
+
+logger = setup_logger(__name__, "warning")
+def show_scan_results():
+    network_menu_contents = []
+    networks = wpa_cli.get_scan_results()
+    for network in networks:
+        if network["ssid"] == '':
+            ssid = '[Hidden]'
+        elif network["ssid"]:
+            ssid = network["ssid"]
+        network_menu_contents.append([ssid, lambda x=network: network_info_menu(x)])
+    network_menu = Menu(network_menu_contents, i, o, "Wireless network menu")
+    network_menu.activate()
+
+def network_info_menu(network_info):
+    network_info_contents = [
+    ["Connect", lambda x=network_info: connect_to_network(x)],
+    ["BSSID", lambda x=network_info['bssid']: Printer(x, i, o, 5, skippable=True)],
+    ["Frequency", lambda x=network_info['frequency']: Printer(x, i, o, 5, skippable=True)],
+    ["Open" if wpa_cli.is_open_network(network_info) else "Secured", lambda x=network_info['flags']: Printer(x, i, o, 5, skippable=True)]]
+    network_info_menu = Menu(network_info_contents, i, o, "Wireless network info", catch_exit=False)
+    network_info_menu.activate()
+
+def connect_to_network(network_info):
+    #First, looking in the known networks
+    configured_networks = wpa_cli.list_configured_networks()
+    for network in configured_networks:
+        if network_info['ssid'] == network['ssid']:
+            Printer([network_info['ssid'], "known,connecting"], i, o, 1)
+            wpa_cli.enable_network(network['network id'])
+            wpa_cli.save_config()
+            raise MenuExitException
+    #Then, if it's an open network, just connecting
+    if wpa_cli.is_open_network(network_info):
+        network_id = wpa_cli.add_network()
+        Printer(["Network is open", "adding to known"], i, o, 1)
+        ssid = network_info['ssid']
+        wpa_cli.set_network(network_id, 'ssid', '"{}"'.format(ssid))
+        wpa_cli.set_network(network_id, 'key_mgmt', 'NONE')
+        Printer(["Connecting to", network_info['ssid']], i, o, 1)
+        wpa_cli.enable_network(network_id)
+        wpa_cli.save_config()
+        raise MenuExitException
+    #Offering to enter a password
+    else:
+        input = UniversalInput(i, o, message="Password:", name="WiFi password enter UI element")
+        password = input.activate()
+        if password is None:
+            return False
+        network_id = wpa_cli.add_network()
+        Printer(["Password entered", "adding to known"], i, o, 1)
+        ssid = network_info['ssid']
+        wpa_cli.set_network(network_id, 'ssid', '"{}"'.format(ssid))
+        wpa_cli.set_network(network_id, 'psk', '"{}"'.format(password))
+        Printer(["Connecting to", network_info['ssid']], i, o, 1)
+        wpa_cli.enable_network(network_id)
+        wpa_cli.save_config()
+        raise MenuExitException
+    #No WPS PIN input possible yet and I cannot yet test WPS button functionality.
+        
+etdn_thread = None #Well-hidden global
+
+def enable_temp_disabled_networks():
+    global etdn_thread
+    if not etdn_thread:
+        etdn_thread = Thread(target=etdn_runner)
+        etdn_thread.daemon = True
+        etdn_thread.start()
+
+def etdn_runner():
+    global etdn_thread
+    saved_networks = wpa_cli.list_configured_networks()
+    for network in saved_networks:
+        if network["flags"] == "[TEMP-DISABLED]":
+            logger.warning("Network {} is temporarily disabled, re-enabling".format(network["ssid"]))
+            try:
+                enable_network(network["network_id"])
+            except Exception as e:
+                logger.error(format_exc())
+                logger.exception(e)
+    etdn_thread = None
+
+def scan(delay = True, silent = False):
+    delay = 1 if delay else 0
+    try:
+        wpa_cli.initiate_scan()
+        enable_temp_disabled_networks()
+    except wpa_cli.WPAException as e:
+        if e.code=="FAIL-BUSY":
+            if not silent:
+                Printer("Still scanning...", i, o, 1)
+        else:
+            raise
+    else:
+        if not silent:
+            Printer("Scanning...", i, o, 1)
+    finally:
+        sleep(delay)
+
+def reconnect():
+    try:
+        w_status = wpa_cli.connection_status()
+    except:
+        return ["wpa_cli fail".center(o.cols)]
+    ip = w_status.get('ip_address', None)
+    ap = w_status.get('ssid', None)
+    if not ap:
+        Printer("Not connected!", i, o, 1)
+        return False
+    id = w_status.get('id', None)
+    if not id:
+        logger.error("Current network {} is not in configured network list!".format(ap))
+        return False
+    disable_network(id)
+    scan()
+    enable_network(id)
+    return True
+
+def status_refresher_data():
+    try:
+        w_status = wpa_cli.connection_status()
+    except:
+        return ["wpa_cli fail".center(o.cols)]
+    #Getting data
+    state = w_status['wpa_state']
+    ip = w_status.get('ip_address', 'None')
+    ap = w_status.get('ssid', 'None')
+
+    #Formatting strings for screen width
+    if len(ap) > o.cols: #AP doesn't fit on the screen
+        ap = ellipsize(ap, o.cols)
+    if o.cols >= len(ap) + len("SSID: "):
+        ap = "SSID: "+ap
+    ip_max_len = 15 #3x4 digits + 3 dots
+    if o.cols >= ip_max_len+4: #disambiguation fits on the screen
+        ip = "IP: "+ip
+    data = [ap.center(o.cols), ip.center(o.cols)]    
+
+    #Formatting strings for screen height
+    #Additional state info
+    if o.rows > 2:
+       data.append(("St: "+state).center(o.cols))
+    #Button usage tips - we could have 3 rows by now, can we add at least 3 more?
+    if o.rows >= 6:
+       empty_rows = o.rows-6 #ip, ap, state and two rows we'll add
+       for i in range(empty_rows): data.append("") #Padding
+       data.append("ENTER: more info".center(o.cols))
+       data.append("UP: reconnect".center(o.cols))
+       data.append("RIGHT: rescan".center(o.cols))
+
+    return data
+
+def status_monitor():
+    keymap = {"KEY_ENTER":wireless_status, "KEY_RIGHT":lambda: scan(False), "KEY_UP":lambda: reconnect()}
+    refresher = Refresher(status_refresher_data, i, o, 0.5, keymap, "Wireless monitor")
+    refresher.activate()
+
+def wireless_status():
+    w_status = wpa_cli.connection_status()
+    state = w_status['wpa_state']
+    status_menu_contents = [[["state:", state]]] #State is an element that's always there, let's see possible states
+    if state == 'COMPLETED':
+        #We have bssid, ssid and key_mgmt at least
+        status_menu_contents.append(['SSID: '+w_status['ssid']])
+        status_menu_contents.append(['BSSID: '+w_status['bssid']])
+        key_mgmt = w_status['key_mgmt']
+        status_menu_contents.append([['Security:', key_mgmt]])
+        #If we have WPA in key_mgmt, we also have pairwise_cipher and group_cipher set to something other than NONE so we can show them
+        if key_mgmt != 'NONE':
+            try: #What if?
+                group = w_status['group_cipher']
+                pairwise = w_status['pairwise_cipher']
+                status_menu_contents.append([['Group/Pairwise:', group+"/"+pairwise]])
+            except:
+                pass
+    elif state in ['AUTHENTICATING', 'SCANNING', 'ASSOCIATING']:
+        pass #These states don't have much information
+    #In any case, we might or might not have IP address info
+    status_menu_contents.append([['IP address:',w_status['ip_address'] if 'ip_address' in w_status else 'None']])
+    #We also always have WiFi MAC address as 'address'
+    status_menu_contents.append(['MAC: '+w_status['address']])
+    status_menu = Menu(status_menu_contents, i, o, "Wireless status menu", entry_height=2)
+    status_menu.activate()
+
+def change_interface():
+    #This function builds a menu out of all the interface names, each having a callback to show_if_function with interface name as argument
+    menu_contents = []
+    interfaces = wpa_cli.get_interfaces()
+    for interface in interfaces:
+        menu_contents.append([interface, lambda x=interface: change_current_interface(x)])
+    interface_menu = Menu(menu_contents, i, o, "Interface change menu")
+    interface_menu.activate()
+
+def change_current_interface(interface):
+    try:
+        wpa_cli.set_active_interface(interface)
+    except wpa_cli.WPAException:
+        Printer(['Failed to change', 'interface'], i, o, skippable=True)
+    else:
+        Printer(['Changed to', interface], i, o, skippable=True)
+    finally:
+        raise MenuExitException
+        
+def save_changes():
+    try:
+        wpa_cli.save_config()
+    except wpa_cli.WPAException:
+        Printer(['Failed to save', 'changes'], i, o, skippable=True)
+    else:
+        Printer(['Saved changes'], i, o, skippable=True)
+        
+saved_networks = None #I'm a well-hidden global
+
+def manage_networks():
+    global saved_networks
+    saved_networks = wpa_cli.list_configured_networks()
+    network_menu_contents = []
+    #As of wpa_supplicant 2.3-1, header elements are ['network id', 'ssid', 'bssid', 'flags']
+    for num, network in enumerate(saved_networks):
+        network_menu_contents.append(["{0[network id]}: {0[ssid]}".format(network), lambda x=num: saved_network_menu(saved_networks[x])])
+    network_menu = Menu(network_menu_contents, i, o, "Saved network menu", catch_exit=False)
+    network_menu.activate()
+
+def saved_network_menu(network_info):
+    global saved_networks
+    id = network_info['network id']
+    bssid = network_info['bssid']
+    network_status = network_info["flags"] if network_info["flags"] else "[ENABLED]"
+    network_info_contents = [
+    [network_status],
+    ["Select", lambda x=id: select_network(x)],
+    ["Enable", lambda x=id: enable_network(x)],
+    ["Disable", lambda x=id: disable_network(x)],
+    ["Remove", lambda x=id: remove_network(x)],
+    ["Set password", lambda x=id: set_password(x)],
+    ["BSSID", lambda x=bssid: Printer(x, i, o, 5, skippable=True)]]
+    network_info_menu = Menu(network_info_contents, i, o, "Wireless network info", catch_exit=False)
+    network_info_menu.activate() 
+    #After menu exits, we'll request the status again and update the network list
+    saved_networks = wpa_cli.list_configured_networks()
+
+def select_network(id):
+    try:
+        wpa_cli.select_network(id)
+    except wpa_cli.WPAException:
+        Printer(['Failed to', 'select network'], i, o, skippable=True)
+    else:
+        wpa_cli.save_config()
+        Printer(['Selected network', str(id)], i, o, skippable=True)
+    
+def enable_network(id):
+    try:
+        wpa_cli.enable_network(id)
+    except wpa_cli.WPAException:
+        Printer(['Failed to', 'enable network'], i, o, skippable=True)
+    else:
+        wpa_cli.save_config()
+        Printer(['Enabled network', str(id)], i, o, skippable=True)
+    
+def disable_network(id):
+    try:
+        wpa_cli.disable_network(id)
+    except wpa_cli.WPAException:
+        Printer(['Failed to', 'disable network'], i, o, skippable=True)
+    else:
+        wpa_cli.save_config()
+        Printer(['Disabled network', str(id)], i, o, skippable=True)
+
+def remove_network(id):
+    want_to_remove = DialogBox("yn", i, o, message="Remove network?").activate()
+    if not want_to_remove:
+        return 
+    try:
+        wpa_cli.remove_network(id)
+    except wpa_cli.WPAException:
+        Printer(['Failed to', 'remove network'], i, o, skippable=True)
+    else:
+        wpa_cli.save_config()
+        Printer(['Removed network', str(id)], i, o, skippable=True)
+        raise MenuExitException
+
+def set_password(id):    
+    input = UniversalInput(i, o, message="Password:", name="WiFi password enter UI element")
+    password = input.activate()
+    if password is None:
+        return False
+    wpa_cli.set_network(id, 'psk', '"{}"'.format(password))
+    wpa_cli.save_config()
+    Printer(["Password entered"], i, o, 1)
+
+def callback():
+    #A function for main menu to be able to dynamically update
+    def get_contents():
+        current_interface = wpa_cli.get_current_interface()
+        return [["Status", status_monitor],
+        ["Current: {}".format(current_interface), change_interface],
+        ["Scan", scan],
+        ["Networks", show_scan_results],
+        ["Saved networks", manage_networks]]
+    #Now testing if we actually can connect
+    try:
+        get_contents()
+    except OSError as e:
+        if e.errno == 2:
+            Printer(["Do you have", "wpa_cli?"], i, o, 3, skippable=True)
+            return
+        else:
+            raise e
+    except wpa_cli.WPAException:
+        Printer(["Do you have", "wireless cards?", "Is wpa_supplicant", "running?"], i, o, 3, skippable=True)
+        return
+    else:
+        Menu([], i, o, "wpa_cli main menu", contents_hook=get_contents).activate()
+
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
diff --git a/zpui/apps/network_apps/wpa_cli/wpa_cli.py b/zpui/apps/network_apps/wpa_cli/wpa_cli.py
new file mode 100644
index 0000000..6c43add
--- /dev/null
+++ b/zpui/apps/network_apps/wpa_cli/wpa_cli.py
@@ -0,0 +1,191 @@
+
+from subprocess import check_output, CalledProcessError
+from time import sleep
+
+from helpers import setup_logger
+
+logger = setup_logger(__name__, "warning")
+
+#wpa_cli related functions and objects
+def wpa_cli_command(*command):
+    try:
+        return check_output(['wpa_cli'] + list(command))
+    except CalledProcessError as e:
+        raise WPAException(command[0], e.returncode, output=e.output, args=command[1:])
+
+class WPAException(Exception):
+    def __init__(self, command, exit_code, args=None, output=None):
+        self.command = command
+        self.code = exit_code
+        self.args = args
+        if args != []:
+            message = "'wpa_cli {}' returned {}".format(self.command, self.code)
+        else:
+            message = "'wpa_cli {} {}' returned {}".format(self.command, ' '.join(args), self.code)
+        if output:
+            message += "\n Output: {}".format(output)
+        super(WPAException, self).__init__(message)
+
+#wpa_cli command wrappers and their helpers
+
+def connect_new_network(network_info):
+    #First, looking in the known networks
+    conf_networks = list_configured_networks()
+    network_found = False
+    for network in conf_networks:
+        if network_info['ssid'] == network['ssid']:
+            network_found = True
+            select_network(network['network id'])
+            return True
+    #Then, if it's an open network, just connecting
+    if is_open_network(network_info):
+        network_id = add_network()
+        logger.info(set_network(network_id, 'ssid', '"'+network_info['ssid']+'"'))
+        set_network(network_id, 'key_mgmt', 'NONE')
+        select_network(network_id)
+        return True
+    #Else, there's not enough implemented as for now
+    if not network_found:
+        logger.warning("Hell, I dunno.")
+        return False  
+
+def is_open_network(network_info):
+    #Might be an approach which doesn't take some things into account
+    return not is_wpa_enabled(network_info)
+
+def is_wpa_enabled(network_info):
+    flags = parse_network_flags(network_info['flags'])
+    wpa_enabled = False
+    for flag in flags:
+        if flag.startswith('WPA'):
+            wpa_enabled = True
+    return wpa_enabled
+
+def parse_network_flags(flag_string):
+    #Flags go each after another, enclosed in "[]" braces
+    flags = [flag.strip('[]') for flag in flag_string.split('][')] #If anybody knows a better way, do commit
+    return flags
+        
+#wpa_cli commands
+
+def get_interfaces():
+    output = process_output(wpa_cli_command("interface"))
+    output = output[1:] #First line removed by process_output, second line says "Available interfaces"
+    return output
+
+def set_active_interface(interface_name):
+    #TODO output check
+    output = process_output(wpa_cli_command("interface", interface_name))
+    #if output == "Connected to interface '{}'".format(interface_name):
+        
+def get_current_interface():
+    #TODO: check without wireless adapter plugged in
+    output = process_output(wpa_cli_command("ifname"))
+    return output[0]
+
+def connection_status():
+    #TODO: check without wireless adapter plugged in
+    parameters = {}
+    output = process_output(wpa_cli_command("status"))
+    for line in output:
+        if '=' not in line:
+           continue
+        else:
+           param, value = line.split('=',1)
+           parameters[param] = value
+    return parameters
+
+def list_configured_networks():
+    #Gives a nice table with first row as header and tab-separated elements, so I'll use process_table function
+    output = process_output(wpa_cli_command("list_networks"))
+    #As of wpa_supplicant 2.3-1, header elements are ['network id', 'ssid', 'bssid', 'flags']
+    networks = process_table(output[0], output[1:])
+    return networks
+
+def select_network(network_id):
+    return ok_fail_command("select_network", str(network_id))
+
+def enable_network(network_id):
+    return ok_fail_command("enable_network", str(network_id))
+
+def remove_network(network_id):
+    return ok_fail_command("remove_network", str(network_id))
+
+def save_config():
+    return ok_fail_command("save_config")
+
+def disable_network(network_id):
+    return ok_fail_command("disable_network", str(network_id))
+    
+def initiate_scan():
+    return ok_fail_command("scan")
+    
+def get_scan_results():
+    #Currently I know of no way to know if the scan results got updated since last time scan was initiated
+    output = process_output(wpa_cli_command("scan_results"))
+    #As of wpa_supplicant 2.3-1, header elements are ['bssid', 'frequency', 'signal level', 'flags', 'ssid']
+    networks = process_table(output[0], output[1:])
+    return networks
+
+def add_network():
+    return int_fail_command("add_network")
+
+def set_network(network_id, param_name, value):
+    #Might fail if the wireless dongle gets unplugged or something
+    return ok_fail_command("set_network", str(network_id), param_name, value)
+
+
+#Helper commands
+def ok_fail_command(command_name, *args):
+    #Wrapper around commands which return either "OK" or "FAIL"
+    #Might fail if the wireless dongle gets unplugged or something
+    output = process_output(wpa_cli_command(command_name, *[str(arg) for arg in args]))
+    if output[0] == "OK":
+        return True
+    else:
+        raise WPAException(command_name, output[0], args)
+    
+def int_fail_command(command_name, *args):
+    output = process_output(wpa_cli_command(command_name, *[str(arg) for arg in args]))
+    try:
+        return int(output[0])
+    except:
+        raise WPAException(command_name, output[0], args)
+    
+def process_table(header, contents):
+    #Takes a tab-separated table and returns a list of dicts, each dict representing a row and having column_name:value mappings
+    table = []
+    #I'm going to split the header to column names and use those for dictionary keys so that there's no need to hard-code values
+    column_names = [name.strip(' ') for name in header.split(' / ')]
+    for line in contents:
+        row = {}
+        values = line.split('\t')
+        for i, value in enumerate(values):
+            column_name = column_names[i]
+            row[column_name] = value
+        table.append(row)
+    return table
+
+def process_output(output):
+    #First line of output of wpa_cli (almost?) always says "Selected interface: $INT"
+    #In future, we might need to keep that value somewhere, so this function could be a perfect hook to update that.
+    #Not now.
+    lines = output.split('\n')
+    #print(lines)
+    lines = lines[1:] #First line has the "Selected interface: $INT"
+    return [line.strip(' ') for line in lines if line] #Removing all whitespace and not counting empty lines
+
+
+if __name__ == "__main__":
+    print(get_current_interface())
+    print(get_interfaces())
+    print(list_configured_networks())
+    print(connection_status())
+    print(initiate_scan())
+    for i in range(7):
+        sleep(1)
+        print(get_scan_results())
+    print(initiate_scan())
+    print(initiate_scan())
+    
+
diff --git a/zpui/apps/personal/__init__.py b/zpui/apps/personal/__init__.py
new file mode 100644
index 0000000..2af4e94
--- /dev/null
+++ b/zpui/apps/personal/__init__.py
@@ -0,0 +1 @@
+_menu_name = "Personal"
diff --git a/zpui/apps/personal/contacts/__init__.py b/zpui/apps/personal/contacts/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/personal/contacts/address_book.py b/zpui/apps/personal/contacts/address_book.py
new file mode 100644
index 0000000..49a36de
--- /dev/null
+++ b/zpui/apps/personal/contacts/address_book.py
@@ -0,0 +1,261 @@
+import os
+import pickle
+
+from helpers import Singleton, flatten
+from helpers import setup_logger
+
+logger = setup_logger(__name__, "warning")
+
+
+class AddressBook(Singleton):
+    def __init__(self):
+        """
+        Adds a single contact
+        >>> a = AddressBook()
+        >>> c1 = Contact(name="john", org="wikipedia")
+        >>> a.add_contact(c1)
+        >>> len(a.contacts)
+        1
+
+        Adds another contact so similar it will be merged with the previous
+        >>> c2 = Contact()
+        >>> c2.name = ["john"]
+        >>> c2.telephone = ["911"]
+        >>> a.add_contact(c2)
+
+        the updated contact is retrieved
+        >>> a.find(name="john").telephone
+        ['911']
+        >>> a.find(name="john").org
+        ['wikipedia']
+        >>> len(a.contacts)
+        1
+
+        Add a third similar contact, without auto_merge
+        >>> c3 = Contact(name="John", telephone="911")
+        >>> a.add_contact(c3, auto_merge=False)
+        >>> len(a.contacts)
+        2
+
+
+        """
+        # todo : encrypt ?
+        self._contacts = []
+
+    @property
+    def contacts(self):
+        # type: () -> list
+        return self._contacts
+
+    def add_contact(self, contact, auto_merge=True):
+        # type: (Contact, bool) -> None
+        if not auto_merge or not len(self.contacts):
+            self._contacts.append(contact)
+            return
+
+        duplicate = self.find_best_duplicate(contact)
+        if duplicate:
+            duplicate.merge(contact)
+        else:
+            self._contacts.append(contact)
+
+    def load_from_file(self):
+        save_path = self.get_save_file_path()
+        if not os.path.exists(save_path):
+            logger.error("Could not load. File {} not found".format(save_path))
+            return
+        with open(self.get_save_file_path(), 'r') as f_save:
+            self._contacts = pickle.load(f_save)
+
+    def save_to_file(self):
+        for c in self.contacts:
+            c.consolidate()
+        with open(self.get_save_file_path(), 'w') as f_save:
+            pickle.dump(self._contacts, f_save)
+
+    @staticmethod
+    def get_save_file_path():
+        path = os.environ.get("XDG_DATA_HOME")
+        if path:
+            return os.path.join(path, SAVE_FILENAME)
+        return os.path.join(os.path.expanduser(ZPUI_HOME), SAVE_FILENAME)
+
+    def find(self, **kwargs):
+        # type: (dict) -> Contact
+        # simple wrapper around find_best_duplicate
+        c = Contact(**kwargs)
+        return self.find_best_duplicate(c)
+
+    def get_contacts_with(self, attribute_name):
+        # type: (str) -> list
+        return [c for c in self.contacts if len(getattr(c, attribute_name))]
+
+    def find_best_duplicate(self, contact):
+        # type: (Contact) -> Contact
+        match_score_contact_list = self.find_duplicates(contact)
+        if match_score_contact_list[0][0] > 0:
+            return match_score_contact_list[0][1]
+
+    def find_duplicates(self, contact):
+        # type: (Contact) -> list
+        if contact in self._contacts:
+            return [1, contact]
+        match_score_contact_list = [(c.match_score(contact), c) for c in self.contacts]
+
+        def cmp(a1, a2):
+            # type: (tuple, tuple) -> int
+            return a1[0] > a2[0]
+
+        return sorted(match_score_contact_list, cmp=cmp)
+
+
+class Contact(object):
+    """
+    >>> c = Contact()
+    >>> c.name
+    []
+    >>> c = Contact(name="John")
+    >>> c.name
+    ['John']
+    """
+
+    def __init__(self, **kwargs):
+        self.name = []
+        self.address = []
+        self.telephone = []
+        self.email = []
+        self.url = []
+        self.note = []
+        self.org = []
+        self.photo = []
+        self.title = []
+        self.from_kwargs(kwargs)
+
+    def from_kwargs(self, kwargs):
+        provided_attrs = {attr: kwargs[attr] for attr in self.get_all_attributes() if attr in kwargs.keys()}
+        for attr_name in provided_attrs:
+            attr_value = provided_attrs[attr_name]
+            if isinstance(attr_value, list):
+                setattr(self, attr_name, attr_value)
+            else:
+                setattr(self, attr_name, [attr_value])
+
+    def match_score(self, other):
+        # type: (Contact) -> int
+        """
+        Computes how many element matches with other and self
+        >>> c1 = Contact(name="John", telephone="911")
+        >>> c2 = Contact(name="Johnny")
+        >>> c1.match_score(c2)
+        0
+        >>> c2.telephone = ["123", "911"] # now the contacts have 911 in common
+        >>> c1.match_score(c2)
+        1
+
+        Now add a common nickname to them, ignoring case
+        >>> c1.name.append("deepthroat")
+        >>> c2.name.append("DeepThroat")
+        >>> c1.match_score(c2)
+        2
+        """
+        common_attrs = set(self.get_filled_attributes()).intersection(other.get_filled_attributes())
+        return sum([self.common_attribute_count(getattr(self, attr), getattr(other, attr)) for attr in common_attrs])
+
+    def consolidate(self):
+        """
+        Merge duplicate attributes
+        >>> john = Contact()
+        >>> john.name = ['John', 'John Doe', '   John Doe', 'Darling']
+        >>> john.consolidate()
+        >>> 'Darling' in john.name
+        True
+        >>> 'John Doe' in john.name
+        True
+        >>> len(john.name)
+        2
+        >>> john.org = [['whatever org']]
+        >>> john.consolidate()
+        >>> john.org
+        ['whatever org']
+        """
+        my_attributes = self.get_filled_attributes()
+        for name in my_attributes:  # removes exact duplicates
+            self.consolidate_attribute(name)
+
+    def get_filled_attributes(self):
+        """
+        >>> c = Contact()
+        >>> c.name = ["John", "Johnny"]
+        >>> c.note = ["That's him !"]
+        >>> c.get_filled_attributes()
+        ['name', 'note']
+        """
+        return [a for a in dir(self)
+                if not callable(getattr(self, a)) and not a.startswith("__") and len(getattr(self, a))]
+
+    def get_all_attributes(self):
+        return [a for a in dir(self) if not callable(getattr(self, a)) and not a.startswith("__")]
+
+    def consolidate_attribute(self, attribute_name):
+        # type: (str) -> None
+        attr_value = getattr(self, attribute_name)
+        attr_value = flatten(attr_value)
+        attr_value = list(set([i.strip() for i in attr_value if isinstance(i, basestring)]))  # removes exact duplicates
+
+        attr_value[:] = [x for x in attr_value if not self._is_contained_in_other_element_of_the_list(x, attr_value)]
+
+        setattr(self, attribute_name, list(set(attr_value)))
+
+    def merge(self, other):
+        # type: (Contact) -> None
+        """
+        >>> c1 = Contact()
+        >>> c1.name = ["John"]
+        >>> c2 = Contact()
+        >>> c2.name = ["John"]
+        >>> c2.telephone = ["911"]
+        >>> c1.merge(c2)
+        >>> c1.telephone
+        ['911']
+        """
+        attr_sum = self.get_filled_attributes() + other.get_filled_attributes()
+        for attr_name in attr_sum:
+            attrs_sum = getattr(self, attr_name) + getattr(other, attr_name)
+            setattr(self, attr_name, attrs_sum)
+        self.consolidate()
+
+    def short_name(self):
+        for attr_name in self.get_filled_attributes():
+            for attribute in getattr(self, attr_name):
+                if not isinstance(attribute, basestring) and not isinstance(attribute, list):
+                    continue
+                if isinstance(attribute, list):
+                    for entry_str in attribute:
+                        if not isinstance(entry_str, basestring):
+                            continue
+                else:
+                    return attribute
+        return "unknown"
+
+    @staticmethod
+    def common_attribute_count(a1, a2):
+        # type: (list, list) -> int
+        a1_copy = [i.lower() for i in a1 if isinstance(i, basestring)]
+        a2_copy = [i.lower() for i in a2 if isinstance(i, basestring)]
+        return len(set(a1_copy).intersection(a2_copy))
+
+    @staticmethod
+    def _is_contained_in_other_element_of_the_list(p_element, the_list):
+        """
+        """
+        # type: (object, list) -> bool
+        copy = list(the_list)
+        copy.remove(p_element)
+        for element in copy:
+            if p_element in element:
+                return True
+        return False
+
+
+SAVE_FILENAME = "contacts.pickle"
+ZPUI_HOME = "~/.phone/"
diff --git a/zpui/apps/personal/contacts/main.py b/zpui/apps/personal/contacts/main.py
new file mode 100644
index 0000000..70e7975
--- /dev/null
+++ b/zpui/apps/personal/contacts/main.py
@@ -0,0 +1,70 @@
+# coding=utf-8
+import argparse
+import doctest
+
+import os
+
+from address_book import AddressBook, ZPUI_HOME, Contact
+from apps import ZeroApp
+from helpers import setup_logger
+from ui import NumberedMenu, Listbox
+from vcard_converter import VCardContactConverter
+
+logger = setup_logger(__name__, "info")
+
+
+class ContactApp(ZeroApp):
+    def __init__(self, i, o):
+        super(ContactApp, self).__init__(i, o)
+        self.menu_name = "Contacts"
+        self.address_book = AddressBook()
+        self.menu = None
+
+    def on_start(self):
+        self.address_book.load_from_file()
+        self.menu = NumberedMenu(self.create_menu_content(), self.i, self.o, prepend_numbers=False)
+        self.menu.activate()
+
+    def create_menu_content(self):
+        all_contacts = self.address_book.contacts
+        return [[c.short_name(), lambda x=c: self.create_contact_page(x)] for c in all_contacts]
+
+    def create_contact_page(self, contact):
+        # type: (Contact) -> None
+        contact_attrs = [getattr(contact, a) for a in contact.get_filled_attributes()]
+        Listbox(i=self.i, o=self.o, contents=contact_attrs).activate()
+
+
+def find_contact_files(folder):
+    # type: (str) -> list(str)
+    home = os.path.expanduser(folder)
+    if not os.path.exists(home):
+        os.mkdir(home)
+    contact_card_files = [os.path.join(home, f) for f in os.listdir(home) if f.lower().endswith("vcf")]
+    return contact_card_files
+
+
+def load_vcf(folder):
+    # type: (str) -> None
+    contact_card_files = find_contact_files(folder)
+    contacts = VCardContactConverter.from_vcards(contact_card_files)
+
+    address_book = AddressBook()
+    for contact in contacts:
+        address_book.add_contact(contact)
+    address_book.save_to_file()
+    logger.info("Saved to {}".format(address_book.get_save_file_path()))
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('-i', '--src-folder', dest='src_folder', action='store', metavar="DIR",
+                        help='Folder to read vcard from', default=ZPUI_HOME)
+    parser.add_argument('-t', '--run-tests', dest='test', action='store_true', default=False)
+    arguments = parser.parse_args()
+
+    if arguments.test:
+        logger.info("Running tests...")
+        doctest.testmod()
+
+    load_vcf(arguments.src_folder)
diff --git a/zpui/apps/personal/contacts/vcard_converter.py b/zpui/apps/personal/contacts/vcard_converter.py
new file mode 100644
index 0000000..d8d13d0
--- /dev/null
+++ b/zpui/apps/personal/contacts/vcard_converter.py
@@ -0,0 +1,54 @@
+from helpers import setup_logger
+logger = setup_logger(__name__, "warning")
+
+import vobject
+
+from address_book import Contact
+
+
+class VCardContactConverter(object):
+    vcard_mapping = {
+        'fn': 'name',
+        'n': 'name',
+        'adr': 'address',
+        'tel': 'telephone',
+        'email': 'email',
+        'url': 'url',
+        'note': 'note',
+        'org': 'org',
+        'title': 'title'
+    }
+
+    @staticmethod
+    def to_zpui_contact(v_contact):
+        # type: (vobject.base.Component) -> Contact
+        contact = Contact()
+        for key in v_contact.contents.keys():
+            if key not in VCardContactConverter.vcard_mapping: continue
+            attr = getattr(contact, VCardContactConverter.vcard_mapping[key])
+            assert type(attr) == list
+            attr += [v.value for v in v_contact.contents[key]]
+        return contact
+
+    @staticmethod
+    def parse_vcard_file(file_path):
+        # type: (str) -> list
+        file_content = VCardContactConverter.read_file_content(file_path)
+        contacts = [c for c in vobject.readComponents(file_content, ignoreUnreadable=True)]
+        logger.info("Found {} contact in file {}", len(contacts), file_path)
+        return contacts
+
+    @staticmethod
+    def read_file_content(file_path):
+        with open(file_path, 'r') as f:
+            file_content = f.read()
+            return file_content
+
+    @staticmethod
+    def from_vcards(contact_card_files):
+        # type: (list) -> list
+        contacts = []
+        for file_path in contact_card_files:
+            contacts += VCardContactConverter.parse_vcard_file(file_path)
+        logger.info("finished : {} contacts loaded", len(contacts))
+        return [VCardContactConverter.to_zpui_contact(c) for c in contacts]
diff --git a/zpui/apps/personal/lecture_helper/__init__.py b/zpui/apps/personal/lecture_helper/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/personal/lecture_helper/main.py b/zpui/apps/personal/lecture_helper/main.py
new file mode 100644
index 0000000..31b17f2
--- /dev/null
+++ b/zpui/apps/personal/lecture_helper/main.py
@@ -0,0 +1,94 @@
+menu_name = "Lecture helper"
+
+import os
+from datetime import datetime
+
+from ui import Menu, Printer, Refresher, IntegerAdjustInput, PathPicker, ellipsize
+
+
+i = None
+o = None
+
+file_path = None
+interval = 0
+
+def setup_lecture():
+    def get_contents():
+        return [
+        [ellipsize("File: {}".format(file_path), o.cols), change_file],
+        ["Interval: {}".format(interval), change_interval],
+        ["Start", start_lecture]]
+    Menu([], i, o, "Lecture helper menu", contents_hook=get_contents).activate()
+
+def change_file():
+    global file_path
+    file_path = PathPicker('/', i, o).activate()
+
+def change_interval():
+    global interval
+    interval = IntegerAdjustInput(interval, i, o, message="Length in min.:").activate()
+
+def start_lecture():
+    if not file_path:
+        Printer("File path not set!", i, o, skippable=True)
+    if not interval:
+        Printer("Interval not set!", i, o, skippable=True)
+    if not file_path or not interval:
+        return
+    helper = LectureHelper(file_path, interval)
+    helper.start()
+    
+    
+class LectureHelper(object):
+    refresher = None
+    position = 0
+    started_at = None
+
+    def __init__(self, file, interval):
+        self.filename = file
+        with open(self.filename, 'r') as f:
+            self.contents = [line.rstrip('\n') for line in f.readlines() if line.rstrip('\n')]
+        self.contents.append("STOP")
+        self.interval = interval #In minutes
+
+    def move_left(self):
+        if self.position == 0:
+            self.refresher.deactivate()
+            return
+        self.position -= 1
+
+    def move_right(self):
+        if self.position == len(self.contents) - 1:
+            return
+        self.position += 1
+
+    def get_keymap(self):
+        keymap = {
+          "KEY_LEFT":self.move_left,
+          "KEY_RIGHT":self.move_right}
+        return keymap
+
+    def get_displayed_data(self):
+        data = []
+        data_rows = o.rows - 1
+        current_data = self.contents[self.position]
+        for i in range(data_rows):
+            data.append(current_data[o.cols*i:][:o.cols*(i+1)])
+        total_seconds_since_start = (datetime.now() - self.started).total_seconds()
+        total_seconds_till_end = self.interval*60 - total_seconds_since_start
+        minutes_till_end, seconds_till_end = map(int, (total_seconds_till_end/60, total_seconds_till_end%60))
+        time_str = "{}:{}".format(minutes_till_end, seconds_till_end).center(o.cols)
+        data.append(time_str)
+        return data
+
+    def start(self):
+        self.started = datetime.now() 
+        self.refresher = Refresher(self.get_displayed_data, i, o, 1, self.get_keymap())
+        self.refresher.activate()
+
+callback = setup_lecture
+
+def init_app(input, output):
+    global i, o, callback
+    i = input
+    o = output
diff --git a/zpui/apps/personal/pomodorod/__init__.py b/zpui/apps/personal/pomodorod/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/personal/pomodorod/main.py b/zpui/apps/personal/pomodorod/main.py
new file mode 100755
index 0000000..c713a50
--- /dev/null
+++ b/zpui/apps/personal/pomodorod/main.py
@@ -0,0 +1,60 @@
+menu_name = "Pomodoro"
+
+i = None
+o = None
+
+from time import sleep
+
+from ui import Menu, MenuExitException, Printer, IntegerAdjustInput, Refresher, DialogBox
+
+from utils import RPCClient, RPCCommError
+server = RPCClient('localhost', 4515)
+
+def e_wr(func):
+    def wrapper(*args, **kwargs):
+        try:
+            return func(*args, **kwargs)
+        except RPCCommError:
+            Printer(["Can't connect", "to pomodorod!"], i, o, 1)
+    return wrapper
+
+def status_refresher_data():
+    try:
+        status_str = server.get_status()
+    except RPCCommError:
+        return ["Can't connect", "to pomodorod!"]
+    else:
+        return status_str
+
+def callback():
+    keymap = {"KEY_ENTER":pomodoro_options_menu}
+    refresher = Refresher(status_refresher_data, i, o, 1, keymap, "Pomodoro monitor")
+    refresher.activate()
+
+def start_monitoring():
+    server.start_work()
+    raise MenuExitException
+
+def start_break():
+    server.start_break()
+    raise MenuExitException
+
+def stop_monitoring():
+    server.break_work()
+    raise MenuExitException
+
+def ack_notification():
+    server.acknowledge_notification()
+    raise MenuExitException
+
+def pomodoro_options_menu():
+    menu_contents = [
+    ["Acknowledge", e_wr(ack_notification)],
+    ["Start", e_wr(start_monitoring)],
+    ["Start break", e_wr(start_break)],
+    ["Stop", e_wr(stop_monitoring)]]
+    Menu(menu_contents, i, o, "Pomodoro options menu").activate()
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
diff --git a/zpui/apps/personal/todo_txt/__init__.py b/zpui/apps/personal/todo_txt/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/personal/todo_txt/main.py b/zpui/apps/personal/todo_txt/main.py
new file mode 100644
index 0000000..af5235d
--- /dev/null
+++ b/zpui/apps/personal/todo_txt/main.py
@@ -0,0 +1,97 @@
+menu_name = "TODO.txt"
+
+import tasklib
+
+from ui import Menu, Printer
+
+import re
+
+tasklist_filename = "/root/todo.txt"
+
+i = None
+o = None
+
+storage = None
+
+class TaskStorage(object):
+    
+    tasks = []
+    file_contents = None
+    projects = []
+    contexts = []
+ 
+    def __init__(self, filename):
+        self.load_tasks(filename)
+
+    def load_tasks(self, filename):
+        f = open(filename, 'r')
+        self.projects = []
+        self.contexts = []
+        for line in f.readlines():
+            task = tasklib.Task(line.strip('\n'))
+            for project in task.projects:
+                self.projects.append(project)
+            for context in task.contexts:
+                self.contexts.append(context)
+            self.tasks.append(task)
+        self.projects = list(set(self.projects))
+        self.contexts = list(set(self.contexts))
+        f.seek(0)
+        self.file_contents = f.read()
+
+def uncomplete_task(task):
+    task.setPending()
+    Printer("Task not complete!", i, o, 1)
+
+def complete_task(task):
+    task.setCompleted()
+    Printer("Task complete!", i, o, 1)
+
+def make_task_menu(task):
+    task_contents = []
+    task_contents.append(["Description", lambda: Printer(re.sub('<[^<]+?>', '', task.description), i, o)])
+    if task.is_complete:
+        task_contents.append(["Completed", lambda x=task: uncomplete_task(x)])
+    else:
+        task_contents.append(["Pending", lambda x=task: complete_task(x)])
+    Menu(task_contents, i, o, "Task menu").activate()
+    
+def tasks_menu(uncompleted=False):
+    menu_contents = []
+    for task in storage.tasks:
+        description = re.sub('<[^<]+?>', '', task.description)
+        if uncompleted:
+            if not task.is_complete:
+                menu_contents.append([description, lambda x=task: make_task_menu(x)])
+        else:
+            menu_contents.append([description, lambda x=task: make_task_menu(x)])
+    Menu(menu_contents, i, o, "Tasks menu").activate()
+
+def projects_menu():
+    menu_contents = []
+    for project in storage.projects:
+        description = re.sub('<[^<]+?>', '', task.description)
+        menu_contents.append([description, lambda x=task: make_task_menu(x)])
+    Menu(menu_contents, i, o, "Tasks menu").activate()
+
+def launch():
+    global storage
+    try:
+        storage = TaskStorage(tasklist_filename)
+    except IOError:
+        Printer(["TODO.txt file","not found!"], i, o, 1)
+        return
+    main_menu_contents = []
+    main_menu_contents.append(["Uncompleted tasks", lambda: tasks_menu(uncompleted=True)])
+    main_menu_contents.append(["All tasks", tasks_menu])
+    main_menu_contents.append(["Projects", projects_menu])
+    Menu(main_menu_contents, i, o, "Main menu").activate()
+
+callback = launch
+
+def init_app(input, output):
+    global i, o
+    i = input
+    o = output
+
+#['_highest_priority', '_lowerCompleteness', '_lowest_priority', '_parseDate', '_parseWord', '_reset', 'completion_date', 'creation_date', 'decreasePriority', 'due', 'due_error', 'increasePriority', 'is_complete', 'is_future', 'keywords', 'priority', 'threshold', 'threshold_error']
diff --git a/zpui/apps/personal/todo_txt/tasklib.py b/zpui/apps/personal/todo_txt/tasklib.py
new file mode 100644
index 0000000..9622ce2
--- /dev/null
+++ b/zpui/apps/personal/todo_txt/tasklib.py
@@ -0,0 +1,190 @@
+
+from datetime import datetime, date
+import re
+
+#from qtodotxt.lib.task_htmlizer import TaskHtmlizer
+from helpers import setup_logger
+
+logger = setup_logger(__name__, "warning")
+
+class Task(object):
+    """
+    Represent a task as defined in todo.txt format
+    Take a line in todo.txt format as argument
+    Arguments are read-only, reparse string to modify them or
+    use one the modification methods such as setCompleted()
+    """
+
+    def __init__(self, line):
+        self._highest_priority = 'A'
+        self._lowest_priority = 'D' 
+
+        self.parseLine(line)
+
+    def __str__(self):
+        return self.text
+
+    def __repr__(self):
+        return "Task({})".format(self.text)
+
+    def _reset(self):
+        self.contexts = []
+        self.projects = []
+        self.priority = ""
+        self.is_complete = False
+        self.completion_date = None
+        self.creation_date = None
+        self.is_future = False
+        self.threshold_error = ""
+        self.text = ''
+        self.description = ''
+        self.due = None
+        self.due_error = ""
+        self.threshold = None
+        self.keywords = {}
+
+    def parseLine(self, line):
+        """
+        parse a task formated as string in todo.txt format
+        """
+        self._reset()
+        words = line.split(' ')
+        if words[0] == "x":
+            self.is_complete = True
+            words = words[1:]
+            # parse next word as a completion date
+            # required by todotxt but often not here
+            self.completion_date = self._parseDate(words[0])
+            if self.completion_date:
+                words = words[1:]
+        elif re.search(r'^\([A-Z]\)$', words[0]):
+            self.priority = words[0][1:-1]
+            words = words[1:]
+
+        dato = self._parseDate(words[0])
+        if dato:
+            self.creation_date = dato
+            words = words[1:]
+
+        self.description = " ".join(words)
+        for word in words:
+            self._parseWord(word)
+        self.text = line
+
+    def _parseWord(self, word):
+        if len(word) > 1:
+            if word.startswith('@'):
+                self.contexts.append(word[1:])
+            elif word.startswith('+'):
+                self.projects.append(word[1:])
+            elif ":" in word:
+                key, val = word.split(":", 1)
+                self.keywords[key] = val
+                if word.startswith('due:'):
+                    self.due = self._parseDate(word[4:])
+                    if not self.due:
+                        logger.error("Error parsing due date '{}'".format(word))
+                        self.due_error = word[4:]
+                elif word.startswith('t:'):
+                    self.threshold = self._parseDate(word[2:])
+                    if not self.threshold:
+                        logger.error("Error parsing threshold '{}'".format(word))
+                        self.threshold_error = word[2:]
+                    else:
+                        if self.threshold > date.today():
+                            self.is_future = True
+
+    def _parseDate(self, string):
+        try:
+            return datetime.strptime(string, '%Y-%m-%d').date()
+        except ValueError:
+            return None
+
+    def setCompleted(self):
+        """
+        Set a task as completed by inserting a x and current date at the beginning of line
+        """
+        if self.is_complete:
+            return
+        self.completion_date = date.today()
+        date_string = self.completion_date.strftime('%Y-%m-%d')
+        self.text = 'x %s %s' % (date_string, self.text)
+        self.is_complete = True
+
+    def setPending(self):
+        """
+        Unset completed flag from task
+        """
+        if not self.is_complete:
+            return
+        words = self.text.split(" ")
+        d = self._parseDate(words[1])
+        if d:
+            self.text = " ".join(words[2:])
+        else:
+            self.text = " ".join(words[1:])
+        self.is_complete = False
+        self.completion_date = None
+
+    def increasePriority(self):
+        if self.is_complete:
+            return
+        if not self.priority:
+            self.priority = self._lowest_priority
+            self.text = "({}) {}".format(self.priority, self.text)
+        elif self.priority != self._highest_priority:
+            self.priority = chr(ord(self.priority) - 1)
+            self.text = "({}) {}".format(self.priority, self.text[4:])
+
+    def decreasePriority(self):
+        if self.is_complete:
+            return
+        if self.priority >= self._lowest_priority:
+            self.priority = ""
+            self.text = self.text[4:]
+            self.text = self.text.replace("({})".format(self.priority), "", 1)
+        elif self.priority:
+            oldpriority = self.priority
+            self.priority = chr(ord(self.priority) + 1)
+            self.text = self.text.replace("({})".format(oldpriority), "({})".format(self.priority), 1)
+
+    def __eq__(self, other):
+        return self.text == other.text
+
+    def __lt__(self, other):
+        if self.is_complete != other.is_complete:
+            return self._lowerCompleteness(other)
+        if self.priority != other.priority:
+            if not self.priority:
+                return True
+            if not other.priority:
+                return False
+            return self.priority > other.priority
+        # order the other tasks alphabetically
+        return self.text > other.text
+
+    def _lowerCompleteness(self, other):
+        if self.is_complete and not other.is_complete:
+            return True
+        if not self.is_complete and other.is_complete:
+            return False
+        raise RuntimeError("Could not compare completeness of 2 tasks, please report")
+
+def filterTasks(filters, tasks):
+    if None in filters:  # FIXME: why??? if a filter is None we can just ignore it
+        return tasks
+
+    filteredTasks = []
+    for task in tasks:
+        for myfilter in filters:
+            if myfilter.isMatch(task):
+                filteredTasks.append(task)
+                break
+    return filteredTasks
+
+"""def toHtml(self):
+        return a task as an html block which is a pretty display of a line in todo.txt format
+        htmlizer = TaskHtmlizer()
+        return htmlizer.task2html(self)
+"""
+
diff --git a/zpui/apps/personal/totp_2fa/__init__.py b/zpui/apps/personal/totp_2fa/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/personal/totp_2fa/main.py b/zpui/apps/personal/totp_2fa/main.py
new file mode 100644
index 0000000..2fe9619
--- /dev/null
+++ b/zpui/apps/personal/totp_2fa/main.py
@@ -0,0 +1,79 @@
+menu_name = "2FA TOTP"
+
+import pyotp
+ 
+from ui import Menu, PrettyPrinter as Printer, UniversalInput, Canvas, Refresher, DialogBox
+from helpers import read_or_create_config, local_path_gen, save_config_gen
+
+local_path = local_path_gen(__name__)
+config_path = local_path("config.json")
+config = read_or_create_config(config_path, '{"secrets":[]}', menu_name)
+save_config = save_config_gen(config_path)
+
+i = None
+o = None
+
+def init_app(input, output):
+    global i, o
+    i = input
+    o = output
+
+# Showing TOTP entries
+
+def show_totp(name, secret):
+    display_func = lambda: render_totp(name, secret)
+    r = Refresher(display_func, i, o, 1)
+    delete_func = lambda: delete_config_entry(name, secret, r)
+    r.set_keymap({"KEY_RIGHT":delete_func})
+    r.activate()
+
+def render_totp(name, secret):
+    c = Canvas(o)
+    totp_font = ("Fixedsys62.ttf", 32)
+    try:
+        totp_value = pyotp.TOTP(secret).now()
+    except TypeError:
+        totp_font = ("Fixedsys62.ttf", 16)
+        totp_value = "Incorrect\nsecret!"
+    c.centered_text(totp_value, font=totp_font)
+    left_coord = c.get_centered_text_bounds(name).left
+    c.text(name, (left_coord, 5))
+    return c.get_image()
+
+# Config management
+
+def add_secret():
+    global config
+    name = UniversalInput(i, o, message="Name").activate()
+    if name is None:
+        return
+    secret = UniversalInput(i, o, message="Secret").activate()
+    if secret is None:
+        return
+    config["secrets"].append([name, secret])
+    save_config(config)
+
+def delete_config_entry(name, secret, r):
+    global config
+    # Need to match both name and secret to find the right entry that needs to be deleted
+    do_delete = DialogBox("yn", i, o, message="Delete \"{}\"?".format(name)).activate()
+    if not do_delete:
+        return
+    try:
+        config["secrets"].remove([name, secret])
+    except:
+        Printer("Could not delete!", i, o)
+        raise
+    else:
+        save_config(config)
+        r.deactivate()
+
+# Main menu
+    
+def contents_hook():
+    contents = [[name, lambda x=name, y=secret: show_totp(x, y)] for name, secret in config["secrets"]]
+    contents.append(["Add TOTP...", add_secret])
+    return contents
+
+def callback():
+    Menu([], i, o, "TOTP app main menu", contents_hook=contents_hook).activate()
diff --git a/zpui/apps/phone/TODO b/zpui/apps/phone/TODO
new file mode 100644
index 0000000..e14758b
--- /dev/null
+++ b/zpui/apps/phone/TODO
@@ -0,0 +1,27 @@
+First iteration:
+
+Phone, SMS and some misc functions
+The simplest interface, connects directly to serial from the app and parses things
+Can handle unexpected AT messages to some extent, supports RING and SMS callbacks
+Only tested on SIM800L
+
+Second iteration:
+
+Separate daemon for comms with modem (installed separately)
+    ofono?
+ZPUI app connects to daemon, sets callbacks on events and can also use AT commands
+
+Daemon:
+	State machine
+	Accepts RPC calls and AT commands through a separate socket
+ZPUI app:
+	Connects to the daemon
+	Talks to the modem abstraction, receives callbacks
+
+Benefits of second iteration:
+	Fault-proofing monitoring
+	Flexibility
+	Stability
+	No race conditions
+	Better layer separation
+	Less threads in one Python app = more responsive
diff --git a/zpui/apps/phone/__init__.py b/zpui/apps/phone/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/phone/main.py b/zpui/apps/phone/main.py
new file mode 100755
index 0000000..2011652
--- /dev/null
+++ b/zpui/apps/phone/main.py
@@ -0,0 +1,138 @@
+
+
+from helpers import setup_logger
+
+menu_name = "Phone"
+
+from subprocess import call as os_call
+from time import sleep
+import traceback
+
+from ui import Refresher, Menu, Printer, PrettyPrinter, DialogBox, ffs
+from ui.experimental import NumberKeypadInputLayer
+from helpers import BackgroundRunner, ExitHelper
+
+from phone import Phone, Modem, ATError
+
+
+logger = setup_logger(__name__, "warning")
+
+i = None
+o = None
+init = None
+phone = None
+
+def answer():
+    #No context switching as for now, so all we can do is 
+    #answer call is there's an active one
+    try:
+        phone.answer()
+    except ATError:
+        pass
+
+def hangup():
+    try:
+        phone.hangup()
+    except ATError:
+        pass
+
+def phone_status():
+    data = []
+    status = phone.get_status()
+    callerid = {}
+    if status["state"] != "idle":
+        callerid = phone.get_caller_id()
+    for key, value in status.iteritems():
+        if value:
+            data.append("{}: {}".format(key, value))
+    for key, value in callerid.iteritems():
+        data.append("{}: {}".format(key, value))
+    return data
+
+def call(number):
+    Printer("Calling {}".format(number), i, o, 0)
+    try:
+        phone.call(number)
+    except ATError as e:
+        Printer(ffs("Calling fail! "+repr(e), o.cols), i, o, 0)
+    logger.error("Function stopped executing")
+ 
+def call_view():
+    keymap = {"KEY_ANSWER":[call, "value"]}
+    NumberKeypadInputLayer(i, o, "Call number", keymap, name="Phone call layer").activate()
+
+def status_refresher():
+    Refresher(phone_status, i, o).activate()
+
+
+def init_hardware():
+    try:
+        global phone
+        phone = Phone()
+        modem = Modem()
+        phone.attach_modem(modem)
+    except:
+        deinit_hardware()
+        raise
+
+def deinit_hardware():
+    phone.detach_modem()
+
+def wait_for_connection():
+    eh = ExitHelper(i).start()
+    while eh.do_run() and init.running and not init.failed:
+        sleep(1)
+    eh.stop()
+
+def check_modem_connection():
+    if init.running:
+        return False
+    elif init.finished:
+        return True
+    elif init.failed:
+        raise Exception("Modem connection failed!")
+    else:
+        raise Exception("Phone app init runner is in invalid state! (never ran?)")
+
+def init_app(input, output):
+    global i, o, init
+    i = input; o = output 
+    i.set_maskable_callback("KEY_ANSWER", answer)
+    i.set_nonmaskable_callback("KEY_HANGUP", hangup)
+    try:
+        #This not good enough - either make the systemctl library system-wide or add more checks
+        os_call(["systemctl", "stop", "serial-getty@ttyAMA0.service"])
+    except Exception as e:
+        logger.exception(e)
+        #import pdb;pdb.set_trace()
+    init = BackgroundRunner(init_hardware)
+    init.run()
+
+def offer_retry(counter):
+    do_reactivate = DialogBox("ync", i, o, message="Retry?").activate()
+    if do_reactivate:
+        PrettyPrinter("Connecting, try {}...".format(counter), i, o, 0)
+        init.reset()
+        init.run()
+        wait_for_connection()
+        callback(counter)
+
+def callback(counter=0):
+    try:
+        counter += 1
+        status = check_modem_connection()
+    except:
+        if counter < 3:
+            PrettyPrinter("Modem connection failed =(", i, o)
+            offer_retry(counter)
+        else:
+            PrettyPrinter("Modem connection failed 3 times", i, o, 1)
+    else:
+        if not status:
+            PrettyPrinter("Connecting...", i, o, 0)
+            wait_for_connection()
+            callback(counter)
+        else:
+            contents = [["Status", status_refresher],
+                        ["Call", call_view]]
+            Menu(contents, i, o).activate()
diff --git a/zpui/apps/phone/phone.py b/zpui/apps/phone/phone.py
new file mode 100755
index 0000000..9f873d5
--- /dev/null
+++ b/zpui/apps/phone/phone.py
@@ -0,0 +1,578 @@
+from threading import Event, Thread, Timer
+from Queue import Queue, Empty
+from datetime import datetime
+from serial import Serial
+from time import sleep
+from copy import copy
+
+import string
+import shlex
+
+import smspdu
+
+from helpers import setup_logger
+
+logger = setup_logger(__name__, "warning")
+
+#Personal data protection technique:
+#All the logging statements&prints that can contain private data
+#are to be marked with PDATA. If the data is to be sent to developers,
+#this would make it easier for the users to clean it if they want to.
+#(though it could, of course, make the debugging harder.)
+
+def has_nonascii(s):
+    ascii_chars = string.ascii_letters+string.digits+"!@#$%^&*()_+\|{}[]-_=+'\",.<>?:; "
+    return any([char for char in ascii_chars if char not in ascii_chars])
+
+def is_csv(s):
+    #Is this stupid or KISS? I wrote it, and now I can't tell =(
+    return "," in s
+
+class ATError(Exception):
+    def __init__(self, expected=None, received=None):
+        self.received = received
+        self.expected = expected
+        message = "Expected {}, got {}".format(expected, repr(received))
+        Exception.__init__(self, message)
+
+class Phone(object):
+    
+    modem = None
+    modem_state = {}
+    missed_calls = []
+
+    def __init__(self):
+        pass
+
+    def attach_modem(self, modem):
+        self.detach_modem()
+        self.modem = modem
+        self.modem.update_state_cb = self.state_update_cb
+        self.modem_state = copy(self.modem.status)
+        logger.debug(self.modem_state)
+        self.modem.init()
+        self.modem.start_monitor()
+
+    def detach_modem(self):
+        if self.modem is not None:
+            self.modem.update_state_cb = None
+            self.modem.stop_monitor()
+            self.modem.deinit()
+            self.modem = None
+
+    def state_update_cb(self, key, value):
+        self.modem_state[key] = value
+        if key == "state":
+            if value == "incoming":
+                self.signal_incoming_call()
+            elif value == "talking":
+                self.signal_call_started()
+            elif value == "missed_call":
+                callerid = self.modem.current_callerid
+                callerid["timestamp"] = datetime.now().strftime("%H:%M:%S %Y-%m-%d")
+                self.missed_calls.append(callerid)
+
+    def get_status(self):
+        return self.modem_state
+    
+    def send_message(self, recipient, text):
+        raise NotImplementedError
+
+    def get_caller_id(self):
+        return self.modem.current_callerid
+
+    def get_call_duration(self):
+        pass
+
+    def signal_incoming_call(self):
+        pass
+
+    def signal_call_started(self):
+        pass
+
+    def signal_missed_call(self):
+        pass
+
+    def signal_message_received(self):
+        pass
+
+    def get_new_messages(self):
+        pass
+
+    def get_hardware_info(self):
+        return self.modem.get_manufacturer(), self.modem.get_model(), self.modem.get_imei()
+
+    def __getattr__(self, name):
+        if hasattr(self.modem, name):
+            return getattr(self.modem, name)
+        else:
+            raise AttributeError
+
+
+class Modem(object):
+    #Serial port settings
+    read_buffer_size = 1024
+
+    #Some constants
+    linesep = '\r\n'
+    ok_response = 'OK'
+    error_response = 'ERROR'
+    clcc_header = "+CLCC:"
+    clip_header = "+CLIP:"
+    clcc_enabled = False
+
+    #Status storage variables
+    status = {"state":"idle",
+              "type":None}
+
+    #The Caller ID variable - is set when a call is received and cleard when a call ends
+    #When set, it looks like this:
+    #current_callerid = {"number":"something", "type":"unknown"/"international"/"national"/"network-specific"}
+    current_callerid = None
+
+    def __init__(self, serial_path="/dev/ttyAMA0", serial_timeout=0.5, read_timeout=0.2):
+        self.serial_path = serial_path
+        self.serial_timeout = serial_timeout
+        self.read_timeout = read_timeout
+        self.executing_command = Event()
+        self.should_monitor = Event()
+        self.unexpected_queue = Queue()
+
+    def init(self):
+        self.port = Serial(self.serial_path, 115200, timeout=self.serial_timeout)
+        self.at()
+        self.enable_verbosity()
+        logger.debug("Battery voltage is: {}".format(self.get_voltage()))
+        self.enable_clcc()
+        self.enable_clip()
+        self.set_message_mode("pdu")
+        #self.at_command("AT+CSSN=1,1")
+        self.save_settings()
+
+    def deinit(self):
+        try:
+            self.port.close()
+        except: #Could be not created or already closed
+            pass
+
+   #Functions that the user will be calling
+
+    def call(self, number):
+         #ATD in CLCC is going to generate CLCC data straight away,
+         #so that's going into the queue to be processed separately
+         response = self.at_command("ATD{};".format(number), nook=True)
+         self.queue_unexpected_data(response)
+         return True
+
+    def ussd(self, string):
+        result = self.at_command('AT+CUSD=1,"{}"'.format(string))
+
+    def hangup(self):
+        return self.at_command("ATH", noresponse=True)
+
+    def answer(self):
+        return self.at_command("ATA")
+
+    #Debugging helpers
+
+    def pprint_status(self):
+        print("--------------------------")
+        print("New state: {}".format(self.status["state"]))
+        if self.current_callerid:
+            print("Caller ID: {}, type: {}".format(self.current_callerid["number"],
+                                                   self.current_callerid["type"]))
+
+    def print_callerid(self, callerid):
+        if self.current_callerid:
+            print("Incoming: {} ({})".format(self.current_callerid["number"], self.current_callerid["type"]))
+
+    #Call state set function - that also calls a callback 
+
+    def set_state(self, key, value):
+        self.status[key] = value
+        if callable(self.update_state_cb):
+            self.update_state_cb(key, value)
+
+    #Callbacks that change the call state and clean state variables
+    #Not to be overridden directly as they might have desirable side effects
+    #Also, they're called in a hackish way and overriding would fail anyway
+
+    #Call-specific callbacks
+
+    #  "0":on_talking,
+    def on_talking(self):
+        #Call answered, voice comms established
+        self.set_state("state", "talking")
+        #self.pprint_status()
+
+    #  "1":on_held,
+    def on_held(self):
+        #Held call signal
+        if self.status["type"] == "incoming":
+            self.set_state("state", "held")
+        else:
+            self.set_state("state", "holding")
+        #self.pprint_status()
+
+    #  "2":on_dialing,
+    def on_dialing(self):
+        assert(self.status["type"] == "outgoing")
+        self.set_state("state", "dialing")
+        #self.pprint_status()
+
+    #  "3":on_alerting,
+    def on_alerting(self):
+        assert(self.status["type"] == "outgoing")
+        self.set_state("state", "alerting")
+        #self.pprint_status()
+
+    #  "4":on_incoming,
+    def on_incoming(self):
+        assert(self.status["type"] == "incoming")
+        self.set_state("state", "incoming_call")
+        #self.pprint_status()
+
+    #  "5":on_waiting,
+    def on_waiting(self):
+        assert(self.status["type"] == "incoming")
+        self.set_state("state", "incoming")
+        #self.pprint_status()
+
+    #  "6":on_disconnect
+    def on_disconnect(self, incoming=True):
+        #Either finished or missed call
+        if self.status["type"] == "incoming" and self.status["state"] not in ["held", "talking"]:
+            self.set_state("state", "missed_call")
+        else:
+            self.set_state("state", "finished")
+        Timer(3, self.on_idle).start()
+        #self.pprint_status()
+
+    def on_idle(self):
+        #Cleans up variables and sets state to "idle"
+        #Only runs from threading.Timer since modem sends no "idle" CLCC message
+        #Safety check to ensure this doesn't run during a call 
+        #if call happens right after previous call ends:
+        if self.status["state"] not in ["active_call", "held"]:
+            self.current_callerid = None
+            self.set_state("state", "idle")
+            self.set_state("type", None)
+            #self.pprint_status()
+
+    #SMS callbacks
+
+    def on_incoming_message(self, cmti_line):
+        #New message signal
+        logger.debug("You've got mail! Line: {}".format(cmti_line[len("+CMTI:"):]).strip())
+        self.read_all_messages()
+
+    def read_all_messages(self):
+        prev_timeout = self.serial_timeout
+        self.serial_timeout = 1 #TODO: get message count and base timeout on that
+        output = self.at_command("AT+CMGL")
+        self.serial_timeout = prev_timeout
+        if len(output) % 2 == 1:
+            logger.warning("CMGL output lines not in pairs?")
+            logger.debug("PDATA: {}".format(repr(output)))
+            return False
+        cmgl_header = "+CMGL: "
+        for i in range(len(output)/2):
+            header = output[i*2]
+            if not header.startswith(cmgl_header):
+                logger.warning("Line presumed to be CMGL doesn't start with CMGL header!")
+                continue
+            id, x, x, pdu_len = header[len(cmgl_header):].split(",")
+            smsc_pdu_str = output[(i*2)+1]
+            self.decode_message(smsc_pdu_str, pdu_len, id)
+
+    def decode_message(self, smsc_pdu_str, pdu_len, id):
+        logger.debug("Reading message {}".format(id))
+        pdu_len = int(pdu_len) #Just in case
+        smsc_len = len(smsc_pdu_str) - pdu_len*2 #We get PDU length in octets
+        if smsc_len == 0:
+            logger.warning("No SMSC in PDU - seems like it can happen!")
+        pdu_str = smsc_pdu_str[smsc_len:] #Discarding SMSC info
+        #SMSC info might actually be useful in the future - maybe its spoofing could be detected? Does it even happen?
+        smspdu.pdu.dump(pdu_str)
+
+    #Non-CLCC exclusive callbacks
+    #(the non-CLCC path might not even work that well, for what I know)
+    def on_ring(self):
+        logger.debug("Ring ring ring bananaphone!")
+
+    #AT command-controlled modem settings and simple functions
+
+    def get_manufacturer(self):
+        return self.at_command("AT+CGMI")
+
+    def get_model(self):
+        return self.at_command("AT+CGMM")
+
+    def get_imei(self):
+        return self.at_command("AT+GSN")
+
+    def save_settings(self):
+        self.at_command("AT&W")
+
+    def enable_verbosity(self):
+        return self.at_command('AT+CMEE=1')
+
+    def enable_clcc(self):
+        self.clcc_enabled = True
+        return self.at_command('AT+CLCC=1')
+
+    def set_message_mode(self, mode_str):
+        if mode_str.lower() == "text":
+            return self.at_command('AT+CMGF=1')
+        elif mode_str.lower() == "pdu":
+            return self.at_command('AT+CMGF=0')
+        else:
+            raise ValueError("Wrong message mode: {}".format(mode_str))
+
+    def enable_clip(self):
+        return self.at_command('AT+CLIP=1')
+
+    def at(self):
+        response = self.at_command('AT')
+        if response is True: return
+        raise ATError(expected=self.ok_response, received=response)
+
+    #Auxiliary functions that aren't related to phone functionality
+    #TODO: Expose this to an external API of sorts
+
+    def get_voltage(self):
+        answer = self.at_command('AT+CBC')
+        if not answer.startswith('+CBC'): return 0.0 #TODO - this needs to be better!
+        voltage_str = answer.split(':')[1].split(',')[2]
+        voltage = round(int(voltage_str)/1000.0, 2)
+        return voltage
+
+    #Call status and Caller ID message processing code
+    #This is where we get call information info
+
+    def process_clcc(self, clcc_line):
+        clcc_line = clcc_line[len(self.clcc_header):]
+        clcc_line = clcc_line.strip()
+        elements = clcc_line.split(',')
+        if len(elements) < 5:
+            logger.debug("Unrecognized number of CLCC elements!")
+            logger.debug("PDATA: "+repr(elements))
+            return
+        elif len(elements) > 8:
+            logger.warning("Too much CLCC elements!")
+            logger.warning("PDATA: "+repr(elements))
+            elements = elements[:8]
+        if len(elements) > 7: #Elements 5 and 6 are present
+            self.set_callerid(elements[5], elements[6])
+        call_type = elements[1]
+        call_status = elements[2]
+        new_state = "incoming" if call_type=="1" else "outgoing" 
+        self.set_state("type", new_state)
+        self.clcc_mapping[call_status](self)
+
+    def process_clip(self, line):
+        clip_line = line[len(self.clip_header):]
+        clip_line = clip_line.strip()
+        elements = clip_line.split(',')
+        if len(elements) < 2:
+            raise ATError(expected="valid CLIP string with >2 elements", received=line)
+        elif len(elements) < 6:
+            logger.warning("Less than 6 CLIP elements, noting")
+            logger.warning("PDATA: "+repr(elements))
+        elif len(elements) > 6:
+            logger.error("Too much CLIP elements, what's wrong?!")
+            logger.error("PDATA: "+repr(elements))
+            elements = elements[:6]
+        number = elements[0]
+        type_id = elements[1]
+        self.set_callerid(number, type_id)
+
+    def set_callerid(self, number, type_id):
+        clip_type_mapping = {"129":"unknown",
+                             "161":"national",
+                             "145":"international",
+                             "177":"network-specific"}
+        if type_id not in clip_type_mapping.keys():
+            logger.error("PDATA: CLIP type id {} not found in type mapping!".format(type_id))
+            type = "unknown"
+        else:
+            type = clip_type_mapping[type_id]
+        #Setting status variable
+        self.current_callerid = {"number":number.strip('\"'), "type":type}
+        
+    clcc_mapping = { 
+      "0":on_talking,
+      "1":on_held,
+      "2":on_dialing,
+      "3":on_alerting,
+      "4":on_incoming,
+      "5":on_waiting,
+      "6":on_disconnect
+    }
+
+    def on_clcc(self, clcc_line):
+        for i in range(4):
+            if not has_nonascii(clcc_line) or not is_csv(clcc_line): 
+                break
+            logger.error("Garbled call info line! Try {}, line: {}".format(i, clcc_line))
+            sleep(1)
+            clcc_response = self.at_command("AT+CLCC", nook=True)
+            logger.error(repr(lines))
+            for line in lines:
+                if line.startswith(self.clcc_header):
+                    clcc_line = line
+                else:
+                    self.queue_unexpected_data(line)
+        if has_nonascii(clcc_line) or not is_csv(clcc_line):
+            logger.error("Still garbled CLCC line!"); return
+        logger.info("Call info OK, line: {}".format(repr(clcc_line[len(self.clcc_header):])).strip())
+        self.process_clcc(clcc_line)
+
+    def on_clip(self, line):
+        self.process_clip(line)
+
+    #Low-level functions
+
+    def check_input(self):
+        input = self.port.read(self.read_buffer_size)
+        if input:
+            self.queue_unexpected_data(input)
+
+    def at_command(self, command, noresponse=False, nook=False):
+        self.executing_command.set()
+        self.check_input()
+        self.port.write(command+self.linesep)
+        echo = self.port.read(len(command)) #checking for command echo
+        if echo != command:
+            raise ATError(received=echo, expected=command)
+        #print(repr(self.port.read(len(self.linesep)+1))) 
+        self.port.read(len(self.linesep)+1) #shifting through the line separator - that +1 seems to be necessary when we're reading right after the echo
+        if noresponse: return True #one of commands that doesn't need a response
+        answer = self.port.read(self.read_buffer_size)
+        self.executing_command.clear()
+        lines = filter(None, answer.split(self.linesep))
+        #print(lines)
+        if nook: return lines
+        if self.ok_response not in lines: #expecting OK as one of the elements 
+            raise ATError(expected=self.ok_response, received=lines)
+        #We can have a sudden undervoltage warning, though
+        #I'll assume the OK always goes last in the command
+        #So we can pass anything after OK to the unexpected line parser
+        ok_response_index = lines.index(self.ok_response)
+        if ok_response_index+1 < len(lines):
+            self.queue_unexpected_data(lines[(ok_response_index+1):])
+            lines = lines[:(ok_response_index+1)]
+        if len(lines) == 1: #Single-line response
+            if lines[0] == self.ok_response: 
+                return True
+            else:
+                return lines[0]
+        else: 
+            lines = lines[:-1]
+            if len(lines) == 1:
+                return lines[0]
+            else:
+                return lines
+
+    #Functions for background monitoring of any unexpected input
+
+    def queue_unexpected_data(self, data):
+        self.unexpected_queue.put(data) 
+
+    def process_incoming_data(self, data):
+        logger.debug("Incoming data: {}".format(repr(data)))
+        if isinstance(data, str):
+            data = data.split(self.linesep)            
+        lines = filter(None, data)
+        for line in lines:
+            #print(line)
+            #Now onto the callbacks
+            #We should ignore some messages if we're using CLIP
+            #As those messages will appear anyway, but processing them 
+            #would be redundant. It could be much prettier, though.
+            if line == "OK":
+                continue
+            if line == "RING":
+                if not self.clcc_enabled:
+                    self.on_ring()
+                continue
+            if line == "BUSY":
+                if not self.clcc_enabled:
+                    self.on_busy()
+                continue
+            if line == "HANGUP":
+                if not self.clcc_enabled:
+                    self.on_hangup()
+                continue
+            if line == "NO ANSWER":
+                if not self.clcc_enabled:
+                    self.on_noanswer()
+                continue
+            if line == "NO CARRIER":
+                if not self.clcc_enabled:
+                    self.on_nocarrier()
+                continue
+            if line in ["SMS Ready", "Call Ready"]:
+                continue #Modem just reset
+            if line.startswith("+CMTI:"):
+                self.on_incoming_message(line); continue
+            if line.startswith(self.clcc_header):
+                self.on_clcc(line); continue
+            if line.startswith(self.clip_header):
+                self.on_clip(line); continue
+            self.parse_unexpected_message(line)
+        
+    def parse_unexpected_message(self, data):
+        #haaaax
+        if self.linesep[::-1] in "".join(data):
+            lines = "".join(data).split(self.linesep[::-1])
+        logger.debug("Unexpected line: {}".format(data))
+
+    #The monitor thread - it receives data from the modem and calls callbacks
+
+    def monitor(self):
+        while self.should_monitor.isSet():
+            logger.info("Monitoring...")
+            if not self.executing_command.isSet():
+                #First, the serial port
+                #print("Reading data through serial!")
+                data = self.port.read(self.read_buffer_size)
+                if data: 
+                    logger.debug("Got data through serial!")
+                    self.process_incoming_data(data)
+                #Then, the queue of unexpected messages received from other commands
+                #print("Reading data from queue!")
+                try:
+                    data = self.unexpected_queue.get_nowait()
+                except Empty:
+                    pass
+                else:
+                    logger.debug("Got data from queue!")
+                    self.process_incoming_data(data)
+            #print("Got to sleep")
+            sleep(self.serial_timeout)
+            #print("Returned from sleep")
+            #try:
+            #    print(modem.at_command("AT+CPAS"))
+            #except:
+            #    print("CPAS exception")
+        logger.info("Stopped monitoring!")
+
+    def start_monitor(self):
+        self.should_monitor.set()
+        self.thread = Thread(target=self.monitor)
+        self.thread.daemon=True
+        self.thread.start()
+
+    def stop_monitor(self):
+        self.should_monitor.clear()
+
+
+if __name__ == "__main__":
+    modem = Modem()
+    modem.init()
+    modem.start_monitor()
+    def dial():
+        modem.call("25250034")
+    def cpas():
+        print(modem.at_command("AT+CPAS"))
diff --git a/zpui/apps/privacy_apps/__init__.py b/zpui/apps/privacy_apps/__init__.py
new file mode 100644
index 0000000..ef897cb
--- /dev/null
+++ b/zpui/apps/privacy_apps/__init__.py
@@ -0,0 +1 @@
+_menu_name = "Privacy apps"
diff --git a/zpui/apps/privacy_apps/tor/__init__.py b/zpui/apps/privacy_apps/tor/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/privacy_apps/tor/main.py b/zpui/apps/privacy_apps/tor/main.py
new file mode 100755
index 0000000..d4e70fa
--- /dev/null
+++ b/zpui/apps/privacy_apps/tor/main.py
@@ -0,0 +1,94 @@
+menu_name = "Tor control app"
+
+from subprocess import call
+from time import sleep
+
+from ui import Menu, Printer, Refresher
+import tor
+
+i = None
+o = None
+
+def toggle_status():
+    if tor.tor_is_available():
+        call(["systemctl", "stop", "tor.service"])
+    else:
+        call(["systemctl", "start", "tor.service"])
+    sleep(2)
+
+def get_status():
+    status_list = []
+    enabled = tor.tor_is_available()
+    try:
+        external_ip = tor.get_external_ip()
+    except:
+        external_ip = str(None)
+    if enabled:
+        status_list.append("Tor is enabled")
+        bytes_read, bytes_written = tor.get_traffic_info()
+        status_list.append("External IP:")
+        status_list.append(external_ip)
+        status_list.append("Sent: {}B".format(bytes_written))
+        status_list.append("Received: {}B".format(bytes_read))
+    else:
+        status_list.append("Tor is disabled?")
+        status_list.append("External IP:")
+        status_list.append(external_ip)
+    return [s.center(o.cols) for s in status_list]
+    
+def status_refresher():
+    Printer("Getting Tor status...", i, o, 0, skippable=True)
+    Refresher(get_status, i, o, 10).activate()
+
+def check_conn():
+    Printer("Getting DuckDuckGo", i, o, 0, skippable=True)
+    try:
+        response = tor.get_duckduckgo()
+    except:
+        Printer(["Getting DuckDuckGo", "Failed!"], i, o, 2, skippable=True)
+    else:
+        if response.status_code == 200:
+            Printer(["Getting DuckDuckGo", "Success!"], i, o, 2, skippable=True)
+        else:
+            Printer(["Getting DuckDuckGo", "HTTP code "+str(response.status_code)], i, o, 2, skippable=True)
+
+def renew_connection():
+    Printer("Renewing connection...", i, o, 0, skippable=True)
+    try:
+        tor.renew_connection()
+    except:
+        Printer(["Renewing connection", "Failed!"], i, o, 2, skippable=True)
+    else:
+        Printer(["Renewing connection", "Success!"], i, o, 2, skippable=True)
+
+def show_entry_nodes():
+    Refresher(entry_node_info, i, o, 50).activate()
+
+def entry_node_info():
+    node_info = []
+    node_info_dict = tor.get_entry_ips()
+    for node_id in sorted(node_info_dict.keys()):
+        node_info.append("{}: {}".format(node_id, node_info_dict[node_id]))
+    return node_info
+
+
+def main_menu_contents():
+    #Allows to get a nice menu where labels autoupdate when status changes
+    is_available = tor.tor_is_available()
+    contents = [ 
+    ["Refresh", lambda: True], #Just invoking any callback from a menu can refresh it
+    ["Status: {}".format("enabled" if is_available else "disabled"), status_refresher],
+    ["Turn off" if is_available else "Turn on", toggle_status],
+    ["See entry nodes", show_entry_nodes],
+    ["Renew connection", renew_connection],
+    ["Check Tor connection", check_conn]
+    ]
+    return contents
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
+def callback():
+    Menu([], i, o, "Tor app menu", contents_hook=main_menu_contents).activate()
+
diff --git a/zpui/apps/privacy_apps/tor/tor.py b/zpui/apps/privacy_apps/tor/tor.py
new file mode 100644
index 0000000..c193735
--- /dev/null
+++ b/zpui/apps/privacy_apps/tor/tor.py
@@ -0,0 +1,120 @@
+""" This module is made for proof-of-concept purposes only.
+It will be re-written and its security will be tested.
+
+It doesn't guarantee your privacy and wasn't tested for leaks in any way.
+It just shows a working Tor control app to demo ZeroPhone capabilities,
+as well as to discuss application UX."""
+
+#TODO:
+#-Compile new Tor version for Raspbian
+#- Find a usable Tor-supporting request module for Python that doesn't require monkeypatching
+
+#You mgith want to do pip install requests -U and pip install pysocks stem, if the script doesn't work for you.
+
+#Snippets taken from:
+#STEM Pyhon library
+#https://github.com/jamesacampbell/python-examples/
+#http://stackoverflow.com/questions/18561778/how-do-i-get-the-ip-address-of-the-tor-entry-node-in-use
+#... some other places - lost links =(
+
+
+from stem.control import Controller
+from stem import Signal, CircStatus
+import requests
+import socks
+import socket
+
+from helpers import setup_logger
+
+logger = setup_logger(__name__, "info")
+
+socks.set_default_proxy(socks.SOCKS5, "127.0.0.1", 9050)
+
+def getaddrinfo(*args):
+  return [(socket.AF_INET, socket.SOCK_STREAM, 6, '', (args[0], args[1]))]
+
+def monkeypatch_socket(func):
+  def wrapper(*args, **kwargs):
+    socket._socket_ = socket.socket
+    socket.socket = socks.socksocket
+    result = func(*args, **kwargs)
+    socket.socket = socket._socket_
+    return result
+  return wrapper
+
+def monkeypatch_getaddrinfo(func):
+  def wrapper(*args, **kwargs):
+    socket._getaddrinfo_ = socket.getaddrinfo
+    socket.getaddrinfo = getaddrinfo
+    result = func(*args, **kwargs)
+    socket.getaddrinfo = socket._getaddrinfo_
+    return result
+  return wrapper
+
+
+#Python - even monkeypatching is beautiful.
+
+
+@monkeypatch_socket
+def get_external_ip():
+  proxies = {
+    'http': 'socks5://localhost:9050',
+    'https': 'socks5://localhost:9050'
+  }
+  r = requests.Session()
+  response = r.get("http://httpbin.org/ip", proxies=proxies)
+  ip_str = response.json()['origin']
+  return ip_str
+
+@monkeypatch_socket
+@monkeypatch_getaddrinfo
+def get_duckduckgo():
+  ddg = requests.get('http://3g2upl4pq6kufc4m.onion')
+  return ddg
+
+def get_entry_ips():
+  with Controller.from_socket_file(path = "/tmp/tor/socket") as controller:
+    controller.authenticate()  
+    circ_descriptions = {}
+    for circ in controller.get_circuits():
+      if circ.status != CircStatus.BUILT:
+        continue  # skip circuits that aren't yet usable
+      entry_fingerprint = circ.path[0][0]
+      entry_descriptor = controller.get_network_status(entry_fingerprint, None)
+      if entry_descriptor:
+        circ_descriptions[circ.id] = str(entry_descriptor.address)
+  return circ_descriptions
+
+def renew_connection():
+    with Controller.from_socket_file(path = "/tmp/tor/socket") as controller:
+        controller.authenticate()
+        controller.signal(Signal.NEWNYM)	
+
+def get_traffic_info():
+    with Controller.from_socket_file(path = "/tmp/tor/socket") as controller:
+      controller.authenticate()  
+      bytes_read = controller.get_info("traffic/read")
+      bytes_written = controller.get_info("traffic/written")
+    return (bytes_read, bytes_written)
+
+def tor_is_available():
+    try:
+        Controller.from_socket_file(path = "/tmp/tor/socket")
+    except:
+        return False
+    else:
+        return True
+
+def main():
+    info = get_traffic_info
+    logger.info("My Tor relay has read %s bytes and written %s." % info )
+    logger.info(get_external_ip())
+    logger.info(get_entry_ips())
+    ddg = get_duckduckgo()	
+    logger.debug(ddg.content[:100])
+
+    #desc = controller.get_hidden_service_descriptor('3g2upl4pq6kufc4m') #not supported in Raspbian Tor
+  
+
+if __name__ == "__main__":
+    main()
diff --git a/zpui/apps/raspberrypi/__init__.py b/zpui/apps/raspberrypi/__init__.py
new file mode 100644
index 0000000..f3052e9
--- /dev/null
+++ b/zpui/apps/raspberrypi/__init__.py
@@ -0,0 +1 @@
+_menu_name = "Raspberry apps"
diff --git a/zpui/apps/raspberrypi/tvservice/__init__.py b/zpui/apps/raspberrypi/tvservice/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/raspberrypi/tvservice/main.py b/zpui/apps/raspberrypi/tvservice/main.py
new file mode 100755
index 0000000..680e6ef
--- /dev/null
+++ b/zpui/apps/raspberrypi/tvservice/main.py
@@ -0,0 +1,128 @@
+menu_name = "TVService"
+#Some globals for LCS
+callback = None
+#Some globals for us
+main_menu = None
+i = None
+o = None
+
+from time import sleep
+
+from ui import Menu, Printer, MenuExitException
+
+from subprocess import check_output, CalledProcessError
+
+import tvservice
+
+def show_status():
+    try:
+        status = tvservice.status()
+    except IndexError, KeyError:
+        Printer(["Unknown mode", "open GH issue"], i, o)
+        return False
+    mode = status['mode']
+    status_menu_contents = [[["mode:", mode]]] #State is an element that's always there, let's see possible states
+    if mode == 'UNKNOWN':
+        Printer(["Unknown mode", "open GH issue"], i, o)
+        return False
+    if mode == 'NONE':
+        Printer(["No video out", "active"], i, o)
+        return False
+    #Adding elements that are there both in HDMI and TV mode
+    x, y = status["resolution"]
+    refresh_rate = status["refresh_rate"]
+    status_menu_contents.append([["Resolution&rate", "{}x{}, {}".format(x, y, refresh_rate)]])
+    if mode == 'HDMI':
+        group, mode, drive = status["gmd"]
+        status_menu_contents.append([["GroupModeDrive", "{}, {}, {}".format(group, mode, drive)]])
+    elif mode == 'TV':
+        status_menu_contents.append([["TV mode: ", status["tv_mode"]]])
+    status_menu_contents.append([["Ratio:", status["ratio"]]])
+    status_menu_contents.append(["Show flags", lambda: Printer(status["flags"], i, o, skippable=True)])
+    status_menu = Menu(status_menu_contents, i, o, "Tvservice status menu", entry_height=2)
+    status_menu.activate()
+
+def select_hdmi_mode():
+    menu_contents = []
+    try:
+        current_group = tvservice.status()['gmd'][0]
+    except KeyError, IndexError:
+        Printer(["Error, is HDMI", "enabled?"], i, o)
+        return False
+    modes = tvservice.get_modes(current_group)
+    for mode in modes:
+        width = mode["width"]
+        height = mode["height"]
+        rate = mode["rate"]
+        menu_contents.append(["{}x{}@{}".format(width, height, rate), lambda x=mode: set_mode(x)])
+    mode_menu = Menu(menu_contents, i, o, "Mode change menu")
+    mode_menu.activate()
+
+def set_mode(mode_desc):
+    group, mode, drive = tvservice.status()['gmd']
+    mode = mode_desc["code"]
+    tvservice.set_mode(group, mode, drive)
+    Printer(['Changed to', "{},{},{}".format(group, mode, drive)], i, o, skippable=True)
+    status = tvservice.status()
+    try:
+        x, y = status["resolution"]
+    except KeyError:
+        Printer(["Can't get", "resolution!"], i, o, skippable=True)
+    else:
+        try:
+            check_output(["fbset", "-depth", "8"])        
+            check_output(["fbset", "-g", x, y, x, y, "16"])
+            check_output(["chvt", "1"]) #HAAAAAAAAAX - we need to switch VTs for changes to appear
+            check_output(["chvt", "7"]) #This relies on the fact that GUI is mostly on VT7 and most people will want GUI resolutionto change.
+            #TODO: Restart X... Maybe?
+        except:
+            Printer(["Refresh failed!", "Try Ctrl-Alt-F1", "and Ctrl-Alt-F7"], i, o, skippable=True)
+        else:
+            raise MenuExitException #Alright, post-resolution-change triggers executed, nothing to do here
+        
+def display_off():
+    tvservice.display_off()
+    Printer(['Disabled display'], i, o, skippable=True)
+        
+def display_on():
+    tvservice.display_on()
+    Printer(['Enabled display', 'with defaults'], i, o, skippable=True)
+    status = tvservice.status()
+    try:
+        x, y = status["resolution"]
+    except KeyError:
+        Printer(["Can't get", "resolution!"], i, o, skippable=True)
+    else:
+        try:
+            check_output(["fbset", "-depth", "8"])        
+            check_output(["fbset", "-g", x, y, x, y, "16"])
+            check_output(["chvt", "1"]) #HAAAAAAAAAX - we need to switch VTs for changes to appear
+            check_output(["chvt", "7"]) #This relies on the fact that GUI is mostly on VT7
+        except:
+            Printer(["Refresh failed!", "Try Ctrl-Alt-F1", "and Ctrl-Alt-F7"], i, o, skippable=True)
+        else:
+            pass #All successful.
+
+def launch():
+    try:
+       status = tvservice.status()
+    except OSError as e:
+       if e.errno == 2:
+           Printer(["Do you have", "tvservice?"], i, o, 3, skippable=True)
+           return
+       else:
+           raise e
+    else:
+        main_menu_contents = [
+        ["Status", show_status],
+        ["Choose HDMI mode", select_hdmi_mode],
+        ["Display on", display_on],
+        ["Display off", display_off]]
+        main_menu = Menu(main_menu_contents, i, o, "tvservice main menu")
+        main_menu.activate()
+
+
+def init_app(input, output):
+    global callback, i, o
+    i = input; o = output
+    callback = launch
diff --git a/zpui/apps/raspberrypi/tvservice/tvservice.py b/zpui/apps/raspberrypi/tvservice/tvservice.py
new file mode 100644
index 0000000..1127c80
--- /dev/null
+++ b/zpui/apps/raspberrypi/tvservice/tvservice.py
@@ -0,0 +1,146 @@
+import json
+from subprocess import check_output, CalledProcessError
+from time import sleep
+from helpers import setup_logger
+logger = setup_logger(__name__, "info")
+"""
+#Not yet implemented:
+  -t, --ntsc                        Use NTSC frequency for HDMI mode (e.g. 59.94Hz rather than 60Hz)
+  -c, --sdtvon="MODE ASPECT"        Power on SDTV with MODE (PAL or NTSC) and ASPECT (4:3 14:9 or 16:9)
+  -M, --monitor                     Monitor HDMI events
+  -a, --audio                       Get supported audio information
+  -d, --dumpedid <filename>         Dump EDID information to file
+"""
+
+def tvservice_command(*command):
+    try:
+        return check_output(['tvservice'] + list(command))
+    except CalledProcessError as e:
+        raise
+
+def get_modes(group):
+    """-m, --modes=GROUP                 Get supported modes for GROUP (CEA, DMT)"""
+    output = tvservice_command("-j", "-m", group)
+    modes = json.loads(output)
+    return modes
+
+def get_name():
+    """-n, --name                        Print the device ID from EDID"""
+    output = tvservice_command("-n")
+    name = output.strip('\n').split('=', 1)[1].strip(' ')
+    return name
+
+def set_mode(group, mode, drive):
+    """-e, --explicit="GROUP MODE DRIVE" Power on HDMI with explicit GROUP (CEA, DMT, CEA_3D_SBS, CEA_3D_TB, CEA_3D_FP, CEA_3D_FS), MODE (see --modes) and DRIVE (HDMI, DVI)"""
+    if type(mode) == int: mode = str(mode)
+    output = tvservice_command("-e", "{} {} {}".format(group, mode, drive))
+
+def status():
+    """-s, --status                      Get HDMI status"""
+    output = tvservice_command("-s") #See example outputs at the bottom
+    output = output.strip('\n').strip(' ')
+    #First, we get the state flags and then parse everything according to which flags are set (since tvservice -s output is a little flag-specific)
+    state = output.split('[')[0]
+    state_value_str = state.split(' ')[1].strip(' ')
+    flags = get_state_flags(state_value_str)
+    hdmi_port_active = "VC_HDMI_DVI" in flags or "VC_HDMI_HDMI" in flags
+    tv_out_active = "VC_SDTV_NTSC" in flags or "VC_SDTV_PAL" in flags
+    if not hdmi_port_active and not tv_out_active: #Neither HDMI nor TV-out active
+        result = {"state":state_value_str, "flags":flags, "mode":"NONE"}
+        return result
+    #Now parsing things common to both HDMI and TV modes
+    state_str, resolution, scan_type = [part.strip(' ') for part in output.split(',')]
+    state_params = state_str.split('[')[1].strip(']')
+    resolution, refresh_rate = [part.strip(' ') for part in resolution.split('@')]
+    x, y = resolution.split('x')
+    result = {"state":state_value_str, "flags":flags, "resolution":(x, y), "scan_type":scan_type, "refresh_rate": refresh_rate}
+    #Now going through mode-specific parameters
+    if hdmi_port_active:
+       result["mode"] = "HDMI"
+       drive, group, mode_str, color_scheme, something, ratio = state_params.split(" ", 5)
+       result["ratio"] = ratio
+       mode = mode_str.strip("()")
+       result["gmd"] = (group, mode, drive)
+    elif tv_out_active:
+       result["mode"] = "TV"
+       mode, ratio = state_params.split(" ", 2)
+       result["tv_mode"] = mode
+       result["ratio"] = ratio
+    else:
+       logger.warning("Unexpected tvservice -s output: {}".format(output))
+       result["mode"] = "UNKNOWN"
+    return result
+
+def display_off():
+    """-o, --off                         Power off the display"""
+    tvservice_command("-o")
+    
+def display_on():
+    """-p, --preferred                   Power on HDMI with preferred settings"""
+    tvservice_command("-p")
+    
+def get_state_flags(state_str):
+    state_flags = {
+    "VC_HDMI_UNPLUGGED"          : 0,  #HDMI cable is detached
+    "VC_HDMI_ATTACHED"           : 1,  #HDMI cable is attached but not powered on
+    "VC_HDMI_DVI"                : 2,  #HDMI is on but in DVI mode (no audio)
+    "VC_HDMI_HDMI"               : 3,  #HDMI is on and HDMI mode is active
+    "VC_HDMI_HDCP_UNAUTH"        : 4,  #HDCP authentication is broken (e.g. Ri mismatched) or not active
+    "VC_HDMI_HDCP_AUTH"          : 5,  #HDCP is active
+    "VC_HDMI_HDCP_KEY_DOWNLOAD"  : 6,  #HDCP key download successful/fail
+    "VC_HDMI_HDCP_SRM_DOWNLOAD"  : 7,  #HDCP revocation list download successful/fail
+    "VC_HDMI_CHANGING_MODE"      : 8,  #HDMI is starting to change mode, clock has not yet been set
+    "VC_SDTV_UNPLUGGED"          : 16, #SDTV cable unplugged, subject to platform support
+    "VC_SDTV_ATTACHED"           : 17, #SDTV cable is plugged in
+    "VC_SDTV_NTSC"               : 18, #SDTV is in NTSC mode
+    "VC_SDTV_PAL"                : 19, #SDTV is in PAL mode
+    "VC_SDTV_CP_INACTIVE"        : 20, #Copy protection disabled
+    "VC_SDTV_CP_ACTIVE"          : 21  #Copy protection enabled
+    }
+    state_value = int(state_str, 0)
+    flags_set = []
+    for flag_name in state_flags:
+        if state_value & 1 << state_flags[flag_name]:
+            flags_set.append(flag_name)
+    return flags_set
+
+
+if __name__ == "__main__":
+    print(get_modes("DMT"))
+    print(status())
+    print(get_name())
+    #display_off()
+    #sleep(5)
+    #display_on()
+
+
+"""
+
+#Tvservice status strings & flags:
+
+state 0x120006 [DVI DMT (35) RGB full 5:4], 1280x1024 @ 60.00Hz, progressive
+['VC_HDMI_ATTACHED', 'VC_SDTV_ATTACHED', 'VC_HDMI_DVI', 'VC_SDTV_CP_INACTIVE']
+
+state 0x120006 [DVI DMT (35) RGB full 5:4], 1280x1024 @ 60.00Hz, progressive
+['VC_HDMI_ATTACHED', 'VC_SDTV_ATTACHED', 'VC_HDMI_DVI', 'VC_SDTV_CP_INACTIVE']
+
+state 0x120002 [TV is off]
+['VC_HDMI_ATTACHED', 'VC_SDTV_ATTACHED', 'VC_SDTV_CP_INACTIVE']
+
+state 0x40001 [NTSC 4:3], 720x480 @ 60.00Hz, interlaced
+['VC_SDTV_NTSC', 'VC_HDMI_UNPLUGGED']
+
+state 0x40002 [NTSC 4:3], 720x480 @ 60.00Hz, interlaced
+['VC_HDMI_ATTACHED', 'VC_SDTV_NTSC']
+
+state 0x120006 [DVI DMT (35) RGB full 5:4], 1280x1024 @ 60.00Hz, progressive
+['VC_HDMI_ATTACHED', 'VC_SDTV_ATTACHED', 'VC_HDMI_DVI', 'VC_SDTV_CP_INACTIVE']
+
+state 0x120006 [DVI DMT (35) RGB full 5:4], 1280x1024 @ 60.00Hz, progressive
+['VC_HDMI_ATTACHED', 'VC_SDTV_ATTACHED', 'VC_HDMI_DVI', 'VC_SDTV_CP_INACTIVE']
+
+state 0x120005 [DVI DMT (35) RGB full 5:4], 1280x1024 @ 60.00Hz, progressive
+['VC_SDTV_ATTACHED', 'VC_HDMI_DVI', 'VC_HDMI_UNPLUGGED', 'VC_SDTV_CP_INACTIVE']
+
+
+"""
diff --git a/zpui/apps/scripts/__init__.py b/zpui/apps/scripts/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/scripts/main.py b/zpui/apps/scripts/main.py
new file mode 100755
index 0000000..c54c887
--- /dev/null
+++ b/zpui/apps/scripts/main.py
@@ -0,0 +1,113 @@
+import os
+from subprocess import check_output, CalledProcessError, STDOUT
+
+from helpers import read_or_create_config, local_path_gen
+from ui import Menu, Printer, PrettyPrinter, DialogBox, PathPicker, UniversalInput, TextReader
+
+menu_name = "Scripts"  # App name as seen in main menu while using the system
+
+scripts_dir = "s/"
+config_filename = "config.json"
+default_config = """
+[
+ {"path":"./s/login.sh",
+  "name":"Hotspot login"},
+ {"path":"./s/dmesg.sh",
+  "name":"Last 100 dmesg lines"},
+ {"path":"/root/backup.sh",
+  "name":"Backup things",
+  "args":["--everything", "--now"]},
+ {"path":"mount",
+  "name":"'mount' with -a",
+  "args":["-a"]},
+ {"path":"wget",
+  "name":"wget google main page",
+  "args":["http://www.google.com"]}
+]"""
+
+local_path = local_path_gen(__name__)
+config_path = local_path(config_filename)
+config = read_or_create_config(config_path, default_config, menu_name + " app")
+
+
+def call_external(script_list, shell=False):
+    if shell:
+        script_path = script_list.split(' ')[0]
+    else:
+        script_path = os.path.split(script_list[0])[1]
+    Printer("Calling {}".format(script_path), i, o, 1)
+
+    output = None
+    try:
+        output = check_output(script_list, stderr=STDOUT, shell=shell)
+    except OSError as e:
+        if e.errno == 2:
+            Printer("File not found!", i, o, 1)
+        elif e.errno == 13:
+            Printer(["Permission", "denied!"], i, o, 1)
+        elif e.errno == 8:
+            Printer(["Unknown format,", "forgot header?"], i, o, 1)
+        else:
+            error_message = "Unknown error! \n \n {}".format(e)
+            PrettyPrinter(error_message, i, o, 3)
+        output = ""
+    except CalledProcessError as e:
+        Printer(["Failed with", "code {}".format(e.returncode)], i, o, 1)
+        output = e.output
+    else:
+        Printer("Success!", i, o, 1)
+    finally:
+        if not output:
+            return
+        answer = DialogBox("yn", i, o, message="Show output?").activate()
+        if answer:
+            TextReader(output, i, o, autohide_scrollbars=True, h_scroll=True).activate()
+
+
+def call_by_path():
+    path = PathPicker("/", i, o).activate()
+    if path is None:
+        return
+    args = UniversalInput(i, o, message="Arguments:", name="Script argument input").activate()
+    if args is not None:
+        path = path + " " + args
+    call_external(path, shell=True)
+
+
+def call_command():
+    command = UniversalInput(i, o, message="Command:", name="Script command input").activate()
+    if command is None:
+        return
+    call_external(command, shell=True)
+
+
+def callback():
+    script_menu_contents = [["Script by path", call_by_path],
+                            ["Custom command", call_command]]
+    scripts_in_config = []
+    for script_def in config:
+        script_path = script_def["path"]
+        if script_path.startswith('./'):
+            script_path = script_path.lstrip('.').lstrip('/')
+            script_path = local_path(script_path)
+            scripts_in_config.append(script_path)
+        args = script_def["args"] if "args" in script_def else []
+        script_name = script_def["name"] if "name" in script_def else os.path.split(script_path)[1]
+        script_list = [script_path] + args
+        script_menu_contents.append([script_name, lambda x=script_list: call_external(x)])
+    other_scripts = os.listdir(local_path(scripts_dir))
+    for script in other_scripts:
+        relpath = local_path(scripts_dir, script)
+        if relpath not in scripts_in_config:
+            script_menu_contents.append([os.path.join(scripts_dir, script), lambda x=relpath: call_external([x])])
+    Menu(script_menu_contents, i, o, "Script menu").activate()
+
+
+i = None
+o = None
+
+
+def init_app(input_obj, output_obj):
+    global i, o
+    i = input_obj
+    o = output_obj
diff --git a/zpui/apps/scripts/s/dmesg.sh b/zpui/apps/scripts/s/dmesg.sh
new file mode 100755
index 0000000..2ce23dc
--- /dev/null
+++ b/zpui/apps/scripts/s/dmesg.sh
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+set -euo pipefail
+
+dmesg | tail -n 100
diff --git a/zpui/apps/scripts/s/example.sh b/zpui/apps/scripts/s/example.sh
new file mode 100755
index 0000000..c9222d9
--- /dev/null
+++ b/zpui/apps/scripts/s/example.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+set -euo pipefail
+
+logger "Hello world!"
+echo "Hello and welcome to Aperture Science computer-aided enrichment center"
diff --git a/zpui/apps/scripts/s/login.sh b/zpui/apps/scripts/s/login.sh
new file mode 100755
index 0000000..6bd01e1
--- /dev/null
+++ b/zpui/apps/scripts/s/login.sh
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+set -euo pipefail
+
+USERNAME="username"
+PASSWORD="password"
+WEBPAGE="rbt2.wifi.cs.rtu.lv/rtu_web.html"
+
+curl "$WEBPAGE" -Lv --data "username=$USERNAME&key=$PASSWORD&fname=wba_login"
diff --git a/zpui/apps/scripts/s/rpi_photo.sh b/zpui/apps/scripts/s/rpi_photo.sh
new file mode 100755
index 0000000..1ced967
--- /dev/null
+++ b/zpui/apps/scripts/s/rpi_photo.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+set -euo pipefail
+
+DATE=$(date +"%Y-%m-%d_%H%M%S")
+raspistill -o "/root/photos/image_$DATE.jpg" -hf -vf -n -t 30
diff --git a/zpui/apps/settings/__init__.py b/zpui/apps/settings/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/settings/logging_ui.py b/zpui/apps/settings/logging_ui.py
new file mode 100644
index 0000000..0fb37e6
--- /dev/null
+++ b/zpui/apps/settings/logging_ui.py
@@ -0,0 +1,74 @@
+i = None
+o = None
+
+from collections import OrderedDict
+import logging
+
+import helpers.logger as log_system
+
+logger_alias_map = (("root","Main launcher"),
+                    ("input.input","Input system"),
+                    ("apps.app_manager","App manager"),
+                    ("context_manager","Context manager"),
+                    ("emulator","Emulator"),
+                    ("helpers.logger","Logging system"))
+
+logger_alias_map = OrderedDict(logger_alias_map)
+
+from ui import Menu, Listbox
+
+def get_logger_names():
+    return log_system.get_logger_names()
+
+def prettify_logger_names(names):
+    name_mapping = OrderedDict()
+    for name in names:
+        if name in logger_alias_map:
+            # We have a defined name for this logger
+            name_mapping[name] = logger_alias_map[name]
+        elif name.startswith("ui."):
+            # This is an UI logger
+            element_name = name[len("ui."):].capitalize()
+            name_mapping[name] = "UI - {}".format(element_name)
+        elif name.startswith("apps."):
+            # This is an app logger
+            app_name, module_name = name.rsplit(".", 2)[1:]
+            app_name = app_name.capitalize().replace("_", " ")
+            name_mapping[name] = '{} app - {}'.format(app_name, module_name)
+        elif name.startswith("input.drivers") or name.startswith("output.drivers"):
+            # This is a driver logger
+            driver_name = name.rsplit(".", 1)[1].capitalize().replace("_", " ")
+            name_mapping[name] = '{} driver'.format(driver_name)
+        else:
+            # Fallback - name is not know and we can't yet prettify it
+            name_mapping[name] = name
+    return name_mapping
+
+def get_available_levels():
+    return [ key.lower() for key in logging._levelNames.keys() if isinstance(key, basestring) ]
+
+def select_loglevel(current):
+    available_levels = get_available_levels()
+    lb_contents = [[level.capitalize(), level] for level in available_levels]
+    lb = Listbox(lb_contents, i, o, "Loglevel selection listbox")
+    lb.start_pointer = available_levels.index(current.lower())
+    return lb.activate()
+
+def change_loglevel(logger_name, current_level):
+    new_level = select_loglevel(current_level)
+    if new_level is not None:
+        assert (new_level in get_available_levels())
+        log_system.LoggingConfig().set_level(logger_name, new_level)
+        log_system.LoggingConfig().reload_config()
+
+def get_menu_contents():
+    logger_names = get_logger_names()
+    pretty_logger_names = prettify_logger_names(logger_names)
+    sorted_names = sorted(pretty_logger_names.items(), key=lambda x: x[1])
+    for i, (name, pname) in enumerate(sorted_names):
+        l = log_system.get_log_level_for_logger(name)
+        sorted_names[i] = (name, pname, l)
+    return [["{}:{}".format(l[:1], pname), lambda x=name, y=l:change_loglevel(x, y)] for name, pname, l in sorted_names]
+
+def config_logging():
+    Menu([], i, o, contents_hook=get_menu_contents).activate()
diff --git a/zpui/apps/settings/main.py b/zpui/apps/settings/main.py
new file mode 100755
index 0000000..8517121
--- /dev/null
+++ b/zpui/apps/settings/main.py
@@ -0,0 +1,270 @@
+import os
+import signal
+from subprocess import check_output, STDOUT, CalledProcessError
+from time import sleep
+
+try:
+    import httplib
+except:
+    import http.client as httplib
+
+from ui import Menu, PrettyPrinter, DialogBox, ProgressBar, Listbox
+from helpers.logger import setup_logger
+
+import logging_ui
+
+menu_name = "Settings"
+logger = setup_logger(__name__, "info")
+
+
+class GitInterface(object):
+
+    @classmethod
+    def git_available(cls):
+        try:
+            cls.command("--help")
+        except OSError:
+            return False
+        return True
+
+    @staticmethod
+    def command(command):
+        commandline = "git {}".format(command)
+        logger.debug("Executing: {}".format(commandline))
+        return check_output(commandline, shell=True, stderr=STDOUT)
+
+    @classmethod
+    def get_head_for_branch(cls, branch):
+        output = cls.command("rev-parse {}".format(branch)).strip()
+        return output
+
+    @classmethod
+    def get_current_branch(cls):
+        return cls.get_head_for_branch("--abbrev-ref HEAD").strip()
+
+    @classmethod
+    def checkout(cls, reference):
+        return cls.command("checkout {}".format(reference))
+
+    @classmethod
+    def pull(cls, source = "origin", branch = "master", opts="--no-edit"):
+        try:
+            return cls.command("pull {2} {0} {1}".format(source, branch, opts))
+        except CalledProcessError as e:
+            lines = iter(e.output.split('\n'))
+            logger.debug("Parsing output")
+            marker1 = "following untracked working tree files would be overwritten by merge"
+            marker2 = "local changes to the following files would be overwritten by merge"
+            for line in lines:
+                logger.debug(repr(line))
+                if marker1 in line or marker2 in line:
+                    logger.info("Found interfering files!")
+                    line = next(lines)
+                    while line.startswith('\t'):
+                        line = line.strip()
+                        if not line.endswith('/'):
+                            try:
+                                logger.info("Removing interfering file: {}".format(line))
+                                os.remove(line)
+                            except OSError:
+                                logger.warning("Couldn't remove an interfering file {} while pulling!".format(line))
+                        line = next(lines)
+            return cls.command("pull {2} {0} {1}".format(source, branch, opts))
+
+
+class UpdateUnnecessary(Exception):
+    pass
+
+
+class GenericUpdater(object):
+    steps = []
+    progressbar_messages = {}
+    failed_messages = {}
+
+    def run_step(self, step_name):
+        logger.info("Running update step: '{}'".format(step_name))
+        getattr(self, "do_" + step_name)()
+        logger.debug("Update step '{}' completed!".format(step_name))
+
+    def revert_step(self, step_name):
+        if hasattr(self, "revert_" + step_name):
+            logger.info("Reverting update step: '{}'".format(step_name))
+            getattr(self, "revert_" + step_name)()
+            logger.debug("Update step '{}' reverted!".format(step_name))
+        else:
+            logger.debug("Can't revert step {} - no reverter available.".format(step_name))
+
+    def update(self):
+        logger.info("Starting update process")
+        pb = ProgressBar(i, o, message="Updating ZPUI")
+        pb.run_in_background()
+        progress_per_step = 100 / len(self.steps)
+
+        completed_steps = []
+        try:
+            for step in self.steps:
+                pb.set_message(self.progressbar_messages.get(step, "Loading..."))
+                sleep(0.5)  # The user needs some time to read the message
+                self.run_step(step)
+                completed_steps.append(step)
+                pb.progress += progress_per_step
+        except UpdateUnnecessary:
+            logger.info("Update is unnecessary!")
+            pb.stop()
+            PrettyPrinter("ZPUI already up-to-date!", i, o, 2)
+        except:
+            # Name of the failed step is contained in `step` variable
+            failed_step = step
+            logger.exception("Failed on step {}".format(failed_step))
+            failed_message = self.failed_messages.get(failed_step, "Failed on step '{}'".format(failed_step))
+            pb.pause()
+            PrettyPrinter(failed_message, i, o, 2)
+            pb.set_message("Reverting update")
+            pb.resume()
+            try:
+                logger.info("Reverting the failed step: {}".format(failed_step))
+                self.revert_step(failed_step)
+            except:
+                logger.exception("Can't revert failed step {}".format(failed_step))
+                pb.pause()
+                PrettyPrinter("Can't revert failed step '{}'".format(step), i, o, 2)
+                pb.resume()
+            logger.info("Reverting the previous steps")
+            for step in completed_steps:
+                try:
+                    self.revert_step(step)
+                except:
+                    logger.exception("Failed to revert step {}".format(failed_step))
+                    pb.pause()
+                    PrettyPrinter("Failed to revert step '{}'".format(step), i, o, 2)
+                    pb.resume()
+                pb.progress -= progress_per_step
+            sleep(1) # Needed here so that 1) the progressbar goes to 0 2) run_in_background launches the thread before the final stop() call
+            #TODO: add a way to pause the Refresher
+            pb.stop()
+            logger.info("Update failed")
+            PrettyPrinter("Update failed, try again later?", i, o, 3)
+        else:
+            logger.info("Update successful!")
+            sleep(0.5)  # showing the completed progressbar
+            pb.stop()
+            PrettyPrinter("Update successful!", i, o, 3)
+            self.suggest_restart()
+
+    def suggest_restart(self):
+        needs_restart = DialogBox('yn', i, o, message="Restart ZPUI?").activate()
+        if needs_restart:
+            os.kill(os.getpid(), signal.SIGTERM)
+
+
+class GitUpdater(GenericUpdater):
+    branch = "master"
+
+    steps = ["check_connection", "check_git", "check_revisions", "pull", "install_requirements", "pretest_migrations", "tests"]
+    progressbar_messages = {
+        "check_connection": "Connection check",
+        "check_git": "Running git",
+        "check_revisions": "Comparing code",
+        "pull": "Fetching code",
+        "install_requirements": "Installing packages",
+        "pretest_migrations": "Running migrations",
+        "tests": "Running tests"
+    }
+    failed_messages = {
+        "check_connection": "No Internet connection!",
+        "check_git": "Git binary not found!",
+        "check_revisions": "Exception while comparing revisions!",
+        "pull": "Couldn't get new code!",
+        "install_requirements": "Failed to install new packages!",
+        "pretest_migrations": "Failed to run migrations!",
+        "tests": "Tests failed!"
+    }
+
+    def do_check_git(self):
+        if not GitInterface.git_available():
+            logger.exception("Couldn't execute git - not found?")
+            raise OSError()
+
+    def do_check_revisions(self):
+        GitInterface.command("fetch")
+        current_branch_name = GitInterface.get_current_branch()
+        current_revision = GitInterface.get_head_for_branch(current_branch_name)
+        remote_revision = GitInterface.get_head_for_branch("origin/"+current_branch_name)
+        if current_revision == remote_revision:
+            raise UpdateUnnecessary
+        else:
+            self.previous_revision = current_revision
+
+    def do_check_connection(self):
+        conn = httplib.HTTPConnection("github.com", timeout=10)
+        try:
+            conn.request("HEAD", "/")
+        except:
+            raise
+        finally:
+            conn.close()
+
+    def do_install_requirements(self):
+        output = check_output(["pip", "install", "-r", "requirements.txt"])
+        logger.debug("pip output:")
+        logger.debug(output)
+
+    def do_pull(self):
+        current_branch_name = GitInterface.get_current_branch()
+        GitInterface.pull(branch = current_branch_name)
+
+    def do_pretest_migrations(self):
+        import pretest_migration
+        pretest_migration.main()
+
+    def revert_pretest_migrations(self):
+        import pretest_migration
+        if hasattr(pretest_migration, 'revert'):
+            pretest_migration.revert()
+
+    def do_tests(self):
+        with open('test_commandline', 'r') as f:
+            commandline = f.readline().strip()
+        output = check_output(commandline.split(" "))
+        logger.debug("pytest output:")
+        logger.debug(output)
+
+    def revert_pull(self):
+        # do_check_revisions already ran, we now have the previous revision's
+        # commit hash in self.previous_revision
+        GitInterface.command("reset --hard {}".format(self.previous_revision))
+        # requirements.txt now contains old requirements, let's install them back
+        self.do_install_requirements()
+
+    def pick_branch(self):
+        #TODO: add branches dynamically instead of having a whitelist
+        available_branches = [["master"], ["devel"]]
+        branch = Listbox(available_branches, i, o, name="Git updater listbox").activate()
+        if branch:
+            try:
+                GitInterface.checkout(branch)
+            except:
+                PrettyPrinter("Couldn't check out the {} branch! Try resolving the conflict through the command-line.".format(branch), i, o, 3)
+            else:
+                PrettyPrinter("Now on {} branch!".format(branch), i, o, 2)
+                self.suggest_restart()
+                #TODO: run tests?
+
+
+i = None  # Input device
+o = None  # Output device
+
+def init_app(input, output):
+    global i, o
+    i = input
+    o = output
+    logging_ui.i = i
+    logging_ui.o = o
+
+def callback():
+    git_updater = GitUpdater()
+    c = [["Update ZPUI", git_updater.update],
+         ["Select branch", git_updater.pick_branch],
+         #["Submit logs", logging_ui.submit_logs],
+         ["Logging settings", logging_ui.config_logging]]
+    Menu(c, i, o, "ZPUI settings menu").activate()
diff --git a/zpui/apps/settings/pretest_migration.py b/zpui/apps/settings/pretest_migration.py
new file mode 100644
index 0000000..e943b2d
--- /dev/null
+++ b/zpui/apps/settings/pretest_migration.py
@@ -0,0 +1,2 @@
+def main():
+    print("Migrating")
diff --git a/zpui/apps/stopwatch/__init__.py b/zpui/apps/stopwatch/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/stopwatch/main.py b/zpui/apps/stopwatch/main.py
new file mode 100644
index 0000000..72584b6
--- /dev/null
+++ b/zpui/apps/stopwatch/main.py
@@ -0,0 +1,33 @@
+# coding=utf-8
+
+from apps.zero_app import ZeroApp
+from ui import Refresher
+from ui.utils import Chronometer
+
+
+class StopwatchApp(ZeroApp):
+    def __init__(self, i, o):
+        super(StopwatchApp, self).__init__(i, o)
+        self.menu_name = "Stopwatch"
+        self.counter = Chronometer()
+        self.refresher = None
+        self.__instructions = ["", "UP/ENTER to start/pause", "RIGHT : restart", "DOWN : reset"]
+
+    def on_start(self):
+        super(StopwatchApp, self).on_start()
+        self.refresher = Refresher(self.refresh_function, self.i, self.o, .1, {
+            "KEY_UP": self.counter.toggle,
+            "KEY_RIGHT": self.counter.start,
+            "KEY_ENTER": self.counter.toggle,
+            "KEY_DOWN": self.counter.stop
+        })
+        self.refresher.activate()
+
+    def refresh_function(self):
+        self.counter.update()
+        text_rows = ["{} {}".format(self.get_char(), round(self.counter.elapsed, 2)).center(self.o.cols)]
+        text_rows.extend([instruction.center(self.o.cols) for instruction in self.__instructions])
+        return text_rows
+
+    def get_char(self):
+        return "|>" if self.counter.active else "||"
diff --git a/zpui/apps/system_apps/__init__.py b/zpui/apps/system_apps/__init__.py
new file mode 100644
index 0000000..ba1fa51
--- /dev/null
+++ b/zpui/apps/system_apps/__init__.py
@@ -0,0 +1,7 @@
+_menu_name = "System"
+_ordering = [
+"system",
+"lsusb",
+"systemctl",
+"partitions",
+"shutdown"]
diff --git a/zpui/apps/system_apps/lsusb/__init__.py b/zpui/apps/system_apps/lsusb/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/system_apps/lsusb/lsusb.py b/zpui/apps/system_apps/lsusb/lsusb.py
new file mode 100644
index 0000000..a455295
--- /dev/null
+++ b/zpui/apps/system_apps/lsusb/lsusb.py
@@ -0,0 +1,41 @@
+#!/usr/bin/env python
+
+from subprocess import check_output
+
+"""
+
+Bus 001 Device 015: ID 045e:00db Microsoft Corp. Natural Ergonomic Keyboard 4000 V1.0
+Bus 001 Device 014: ID 046d:c52f Logitech, Inc. Unifying Receiver
+Bus 001 Device 013: ID 0b95:772a ASIX Electronics Corp. AX88772A Fast Ethernet
+Bus 001 Device 012: ID 0d8c:0105 C-Media Electronics, Inc. CM108 Audio Controller
+Bus 001 Device 011: ID 17e9:0117 DisplayLink 
+Bus 001 Device 010: ID 1a40:0201 Terminus Technology Inc. FE 2.1 7-port Hub
+Bus 001 Device 016: ID 04d9:1603 Holtek Semiconductor, Inc. Keyboard
+Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter
+Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. 
+Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
+
+"""
+
+
+def lsusb():
+    lsusb_entries = []
+    output = check_output(["lsusb"])
+    for line in [line.strip(' ') for line in output.split('\n') if line.strip(' ')]:
+        location, description = line.split(':', 1)
+        id_str, vid_pid, name = description.strip(' ').split(' ', 2)
+        bus_str, bus, device_str, device = location.split(' ', 3)
+        bus = str(int(bus, 10))
+        device = str(int(device, 10))
+        lsusb_entries.append([bus, device, vid_pid, name])
+    return lsusb_entries
+
+
+if __name__ == "__main__":
+    print(lsusb())
+
+
+
+
+
+
diff --git a/zpui/apps/system_apps/lsusb/main.py b/zpui/apps/system_apps/lsusb/main.py
new file mode 100755
index 0000000..5c3079f
--- /dev/null
+++ b/zpui/apps/system_apps/lsusb/main.py
@@ -0,0 +1,28 @@
+menu_name = "USB devices"
+
+from ui import Menu, Printer, PrettyPrinter, ellipsize
+
+import lsusb
+
+def show_devices():
+    menu_contents = []
+    try:
+        usb_devices = lsusb.lsusb()
+    except OSError:
+        PrettyPrinter("Do you have lsusb?", i, o, 2)
+        return False
+    for bus, dev, vid_pid, name in usb_devices:   
+        ell_name = ellipsize(name, o.cols)
+        info = "{}\n{}".format(vid_pid, name)
+        menu_contents.append([["D{},B{},{}".format(bus, dev, vid_pid), ell_name], lambda x=info: PrettyPrinter(x, i, o, skippable=True)])
+    Menu(menu_contents, i, o, entry_height=2).activate()
+
+callback = show_devices
+i = None
+o = None
+
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
diff --git a/zpui/apps/system_apps/partitions/__init__.py b/zpui/apps/system_apps/partitions/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/system_apps/partitions/device_info.py b/zpui/apps/system_apps/partitions/device_info.py
new file mode 100755
index 0000000..b8360da
--- /dev/null
+++ b/zpui/apps/system_apps/partitions/device_info.py
@@ -0,0 +1,55 @@
+#!/usr/bin/env python
+
+import shlex
+import os
+
+def get_partitions():
+    partitions = []
+    labels = {}
+    dbu_dir = "/dev/disk/by-uuid/"
+    dbl_dir = "/dev/disk/by-label/"
+    try:
+        parts_by_label = os.listdir(dbl_dir)
+    except OSError:
+        parts_by_label = [] 
+    parts_by_uuid = os.listdir(dbu_dir)
+    for label in parts_by_label:
+        #Getting the place where symlink points to - that's the needed "/dev/sd**"
+        path = os.path.realpath(os.path.join(dbl_dir, label)) 
+        if label:
+            labels[path] = label
+        #Makes dict like {"/dev/sda1":"label1", "/dev/sdc1":"label2"}
+    for uuid in parts_by_uuid:
+        path = os.path.realpath(os.path.join(dbu_dir, uuid))
+        details_dict = {"uuid":uuid, "path":path}
+        details_dict["label"] = labels[path] if path in labels else None
+        partitions.append(details_dict)
+        #partitions is now something like 
+        #[{"uuid":"5OUU1DMUCHUNIQUEW0W", "path":"/dev/sda1"}, {"label":"label1", "uuid":"MANYLETTER5SUCH1ONGWOW", "path":"/dev/sdc1"}]
+    return partitions
+
+def get_mounted_partitions():
+    #Good source of information about mounted partitions is /etc/mtab
+    mtab_file = "/etc/mtab" 
+    with open(mtab_file, "r") as f:
+        lines = f.readlines()
+    mounted_partitions = {}
+    for line in lines:
+        line = line.strip().strip("\n")
+        if line: #Empty lines? Well, who knows what happens... =)
+            elements = shlex.split(line) #Avoids splitting where space character is enclosed in ###########
+            if len(elements) != 6:
+                break
+            path = elements[0] 
+            mountpoint = elements[1] 
+            #mtab is full of entries that aren't any kind of partitions we're interested in - that is, physical&logical partitions of disk drives
+            #That's why we need to filter entries by path
+            if path.startswith("/dev"):
+                #Seems to be a legit disk device. It's either /dev/sd** or a symlink to that. If it's a symlink, we resolve it.
+                dev_path = os.path.realpath(path)
+                mounted_partitions[dev_path] = mountpoint
+    return mounted_partitions
+
+if __name__ == "__main__":
+    print(get_mounted_partitions())    
+    print(scan_partitions())
diff --git a/zpui/apps/system_apps/partitions/main.py b/zpui/apps/system_apps/partitions/main.py
new file mode 100755
index 0000000..5c45966
--- /dev/null
+++ b/zpui/apps/system_apps/partitions/main.py
@@ -0,0 +1,93 @@
+menu_name = "Partitions"
+
+import sys, os
+from subprocess import Popen, PIPE
+import time #Wish I could import some more time...
+
+from ui import Menu, Printer, MenuExitException
+
+import device_info
+
+timeout = 3
+
+pending_umounts = {}
+
+def list_mounts():
+    menu_contents = []
+    mounts = device_info.get_mounted_partitions()
+    for device in mounts:
+        mountpoint = mounts[device]
+        menu_contents.append([mountpoint, lambda x=mountpoint, y=device: view_mount(x, y)])
+    Menu(menu_contents, i, o).activate()
+
+def view_mount(mountpoint, device):
+    menu_contents = [
+    [["Device:", device]],
+    [["Mountpoint:", mountpoint]],
+    ["Unmount", lambda x=mountpoint: umount(x)],
+    ["Unmount (lazy)", lambda x=mountpoint: umount(x, lazy=True)],
+    ["Eject", lambda x=device: eject(x)]]
+    Menu(menu_contents, i, o, entry_height=2, catch_exit=False).activate()
+
+def eject(device):
+    command = ["eject", device]
+    p = Popen(command, stdout=PIPE, stdin=PIPE, stderr=PIPE)
+    counter = timeout/0.1
+    while p.poll() is None:
+        if counter == 0:
+           break
+        time.sleep(0.1)
+        counter -= 1
+    print(p.poll())
+    if p.poll() is not None:
+        code = p.returncode
+        if code == 0:
+            Printer("Ejected!", i, o)
+        else:
+            Printer(["Can't eject!", "code {}".format(code)], i, o)
+    else:
+        Printer("Timeouted", i, o)
+    raise MenuExitException
+
+def umount(path, lazy=False):
+    global pending_umounts
+    command = ["umount"]
+    if lazy: command.append("-l")
+    command.append(path)
+    p = Popen(command, stdout=PIPE, stdin=PIPE, stderr=PIPE)
+    counter = timeout/0.1
+    while p.poll() is None:
+        if counter == 0:
+           break
+        time.sleep(0.1)
+        counter -= 1
+    print(p.poll())
+    if p.poll() is not None:
+        code = p.returncode
+        if code == 0:
+            Printer("Unmounted!", i, o)
+        else:
+            Printer(["Can't unmount!", "code {}".format(code)], i, o)
+    else:
+        Printer(["Timeouted", "added to pending"], i, o)
+        pending_umounts[path] = p
+    raise MenuExitException
+ 
+def status_menu():
+    pass
+
+callback = None
+i = None
+o = None
+
+def init_app(input, output):
+    global i, o, callback
+    i = input; o = output
+    menu_contents = [
+    #["Partitions", list_partitions],
+    ["Mounts", list_mounts]
+    #["Drives", list_drives],
+    #["Status", status_menu]]
+    ]
+    callback = Menu(menu_contents, i, o).activate
+
diff --git a/zpui/apps/system_apps/shutdown/__init__.py b/zpui/apps/system_apps/shutdown/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/system_apps/shutdown/main.py b/zpui/apps/system_apps/shutdown/main.py
new file mode 100755
index 0000000..0a0579b
--- /dev/null
+++ b/zpui/apps/system_apps/shutdown/main.py
@@ -0,0 +1,35 @@
+menu_name = "Shutdown&reboot"
+
+from subprocess import call
+from ui import Menu
+
+
+def shutdown():
+    o.clear()
+    o.display_data("Shutting down")
+    call(['shutdown', '-h', 'now'])
+
+def reboot():
+    o.clear()
+    o.display_data("Rebooting")
+    call(['reboot'])
+
+#Some globals for LCS
+main_menu = None
+callback = None
+#Some globals for us
+i = None
+o = None
+
+main_menu_contents = [
+["Shutdown", shutdown],
+["Reboot", reboot],
+["Exit", 'exit']
+]
+
+def init_app(input, output):
+    global main_menu, callback, i, o
+    i = input; o = output
+    main_menu = Menu(main_menu_contents, i, o, "Shutdown menu")
+    callback = main_menu.activate
+
diff --git a/zpui/apps/system_apps/system/__init__.py b/zpui/apps/system_apps/system/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/system_apps/system/main.py b/zpui/apps/system_apps/system/main.py
new file mode 100755
index 0000000..bca60eb
--- /dev/null
+++ b/zpui/apps/system_apps/system/main.py
@@ -0,0 +1,77 @@
+"""
+    print(cpu_info())
+{'CPU implementer': '0x41', 'Features': 'half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32', 'CPU architecture': '7', 'BogoMIPS': '76.80', 'Hardware': 'BCM2709', 'CPU revision': '4', 'CPU part': '0xd03', 'model name': 'ARMv7 Processor rev 4 (v7l)', 'Serial': '00000000f6570ff1', 'processor': '3', 'CPU variant': '0x0', 'Revision': 'a02082'}
+    print(is_raspberry_pi())
+True
+    print(free())
+{'UsedBC': 203, 'Used': 672, 'SwapTotal': 99, 'Cached': 431, 'SwapFree': 99, 'Free': 253, 'FreeBC': 722, 'SwapUsed': 0, 'Shared': 17, 'Total': 925, 'Buffers': 38}
+    print(linux_info())
+(0.0, 0.01, 0.05)
+"""
+
+menu_name = "System info"
+
+from subprocess import call
+from ui import Menu, Printer, Refresher
+
+import sys_info
+
+def uptime_load_data():
+    loadavg_string = " ".join([str(number) for number in sys_info.loadavg()])
+    uptime_string = sys_info.uptime()
+    return [uptime_string, loadavg_string]
+
+def uptime_load_monitor():
+    Refresher(uptime_load_data, i, o, 1).activate()
+
+def memory_menu_data():
+    memory_info = sys_info.free()
+    menu_contents = [
+    ["Free {}MB".format(memory_info["Free"])],
+    ["Used {}MB".format(memory_info["Used"])],
+    ["FreeBC {}MB".format(memory_info["FreeBC"])],
+    ["UsedBC {}MB".format(memory_info["UsedBC"])],
+    ["Total {}MB".format(memory_info["Total"])],
+    ["Swap {}MB".format(memory_info["SwapTotal"])],
+    ["SwapUsed {}MB".format(memory_info["SwapUsed"])],
+    ["SwapFree {}MB".format(memory_info["SwapFree"])],
+    ["Cached {}MB".format(memory_info["Cached"])],
+    ["Shared {}MB".format(memory_info["Shared"])],
+    ["Buffers {}MB".format(memory_info["Buffers"])]]
+    return menu_contents
+
+def show_memory():
+    Menu([], i, o, contents_hook=memory_menu_data).activate()
+
+def show_linux_info():
+    linux_info = sys_info.linux_info()
+    menu_contents = [
+    [["Hostname:", linux_info["hostname"]]],
+    [["Kernel version:", linux_info["k_release"]]],
+    [["Architecture:", linux_info["machine"]]],
+    [["Distribution:", " ".join(linux_info["distribution"])]]
+    ]
+    Menu(menu_contents, i, o, entry_height=2).activate()
+
+callback = None
+i = None
+o = None
+
+
+def init_app(input, output):
+    global callback, i, o
+    i = input; o = output
+
+    menu_contents = [
+    ["Uptime&load", uptime_load_monitor],
+    #["CPU", show_cpu],
+    ["Memory", show_memory],
+    ["Linux info", show_linux_info]
+    #["Processes", show_processes]
+    ]
+
+    #if detect_raspberry:
+    #    menu.contents.append("Raspberry Pi", rpi_menu)
+    main_menu = Menu(menu_contents, i, o, "System menu")
+    callback = main_menu.activate
+
diff --git a/zpui/apps/system_apps/system/sys_info.py b/zpui/apps/system_apps/system/sys_info.py
new file mode 100644
index 0000000..6dc61ef
--- /dev/null
+++ b/zpui/apps/system_apps/system/sys_info.py
@@ -0,0 +1,206 @@
+#!/usr/bin/env python
+
+from datetime import timedelta
+from subprocess import check_output
+import platform
+
+def _kb_str_to_mb(string):
+    """Converts a string formatted like "1234 kB" into a string where value given is expressed in megabytes"""
+    value, suffix = string.split(" ")
+    if suffix.lower() == "kb":
+       mb_value = int(value)/1024.0
+       return int(mb_value)
+    else:
+       return Non
+
+def linux_info():
+    info = {}
+    uname = platform.uname()
+    arguments = ["system", "hostname", "k_release", "version", 'machine', 'cpu']
+    for i, element in enumerate(uname):
+        info[arguments[i]] = element
+    info["distribution"] = platform.linux_distribution()    
+    return info
+
+
+"""
+>>>cat /proc/cpuinfo
+  MemTotal:         948012 kB
+  MemFree:          719432 kB
+  MemAvailable:     826740 kB
+  Buffers:           16520 kB
+  Cached:           115056 kB
+SwapCached:            0 kB
+Active:           121120 kB
+Inactive:          72412 kB
+Active(anon):      62448 kB
+Inactive(anon):     7112 kB
+Active(file):      58672 kB
+Inactive(file):    65300 kB
+Unevictable:           0 kB
+Mlocked:               0 kB
+  SwapTotal:        102396 kB
+  SwapFree:         102396 kB
+Dirty:                16 kB
+Writeback:             0 kB
+AnonPages:         61960 kB
+Mapped:            55608 kB
+  Shmem:              7600 kB
+Slab:              16012 kB
+SReclaimable:       7628 kB
+SUnreclaim:         8384 kB
+KernelStack:        1344 kB
+PageTables:         2308 kB
+NFS_Unstable:          0 kB
+Bounce:                0 kB
+WritebackTmp:          0 kB
+CommitLimit:      576400 kB
+Committed_AS:     647044 kB
+VmallocTotal:    1105920 kB
+VmallocUsed:        5132 kB
+VmallocChunk:     878076 kB
+CmaTotal:           8192 kB
+CmaFree:            3476 kB
+"""
+
+def parse_proc_meminfo():
+    """ Parses /proc/meminfo and returns key:value pairs"""
+    meminfo_dict = {}
+    with open("/proc/meminfo") as f:
+        for line in f.readlines():
+            try:
+                key, value = line.split(":")
+            except:
+                continue
+            else:
+                meminfo_dict[key] = int(value.strip('\n').strip(' ').split(" ")[0])
+    return meminfo_dict
+
+
+"""
+>>>free
+             total       used       free     shared    buffers     cached
+Mem:        948012     228680     719332       7600      16520     115056
+-/+ buffers/cache:      97104     850908
+Swap:       102396          0     102396
+"""
+
+def free(in_mb=True):
+    memory_dict = {}    
+    meminfo_dict = parse_proc_meminfo()
+    if in_mb:
+        for key in meminfo_dict:
+            meminfo_dict[key] = meminfo_dict[key]/1024
+    mem_free = meminfo_dict["MemFree"]
+    mem_total = meminfo_dict["MemTotal"]
+    memory_dict["Total"] = mem_total
+    memory_dict["Free"] = mem_free
+    memory_dict["Used"] = mem_total-mem_free
+    mem_buffers = meminfo_dict["Buffers"]
+    mem_cache = meminfo_dict["Cached"]
+    mem_shared = meminfo_dict["Shmem"]
+    memory_dict["Buffers"] = mem_buffers
+    memory_dict["Cached"] = mem_cache
+    memory_dict["Shared"] = mem_shared
+    memory_dict["UsedBC"] = mem_total-mem_free-mem_buffers-mem_cache
+    memory_dict["FreeBC"] = mem_free+mem_buffers+mem_cache
+    swap_free = meminfo_dict["SwapFree"]
+    swap_total = meminfo_dict["SwapTotal"]
+    memory_dict["SwapFree"] = swap_free
+    memory_dict["SwapTotal"] = swap_total
+    memory_dict["SwapUsed"] = swap_total-swap_free
+    return memory_dict
+
+
+"""
+>>>cat /proc/uptime
+5996.67 23683.61
+"""
+
+def uptime_timedelta():
+    """Returns system uptime timedelta"""
+    with open('/proc/uptime', 'r') as f:
+        uptime_seconds = float(f.readline().split()[0])
+        delta = timedelta(seconds = int(uptime_seconds))
+    return delta
+
+
+"""
+>>>uptime 
+ 04:38:56 up  1:38,  2 users,  load average: 0.03, 0.08, 0.08
+"""
+
+def uptime():
+    """Returns str(uptime_timedelta)"""
+    return str(uptime_timedelta())
+    
+
+"""
+>>>cat /proc/loadavg
+0.03 0.08 0.08 2/189 1502
+"""
+
+def loadavg():
+    with open('/proc/loadavg', 'r') as f:
+        load1, load5, load15, ksch, last_pid = f.readline().strip('\n').split(" ")
+    load1, load5, load15 = (float(var) for var in [load1, load5, load15])
+    return (load1, load5, load15)
+           
+
+"""
+processor	: 0
+model name	: ARMv7 Processor rev 4 (v7l)
+BogoMIPS	: 38.40
+Features	: half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32 
+CPU implementer	: 0x41
+CPU architecture: 7
+CPU variant	: 0x0
+CPU part	: 0xd03
+CPU revision	: 4
+
+processor	: 1
+#...
+
+Hardware	: BCM2709
+Revision	: a02082
+Serial		: 00000000f6570ff1
+
+"""
+
+def cpu_info():
+    """Parses /proc/cpuinfo and returns a dictionary made from its contents.
+    Bug: for multiple processor definitions, returns only definition for the last processor."""
+    info_dict = {}
+    with open("/proc/cpuinfo", 'r') as f:
+        contents = f.readlines()
+        for line in contents:
+            line = line.strip('\n').strip(' ')
+            if line:
+                key, value = [element.strip(' ').strip('\t') for element in line.split(":", 1)]
+                info_dict[key] = value
+    return info_dict
+
+def is_raspberry_pi(cpuinfo = None):
+    if not cpuinfo:
+        cpuinfo = cpu_info()
+        if "BCM270" in cpuinfo["Hardware"]:
+            return True
+    return False
+
+
+
+if __name__ == "__main__":
+    print(linux_info())
+    print(cpu_info())
+    print(is_raspberry_pi())
+    print(free())
+    print(uptime())
+    print(loadavg())
+
+
+
+
+
+
+
+
diff --git a/zpui/apps/system_apps/systemctl/__init__.py b/zpui/apps/system_apps/systemctl/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/system_apps/systemctl/main.py b/zpui/apps/system_apps/systemctl/main.py
new file mode 100755
index 0000000..caab0a7
--- /dev/null
+++ b/zpui/apps/system_apps/systemctl/main.py
@@ -0,0 +1,180 @@
+menu_name = "Systemctl"
+
+config_filename = "config.json"
+default_config = '{"allowed_types":["service","target"], "pinned_units":["zpui.service"]}'
+
+callback = None
+i = None
+o = None
+
+from time import sleep
+
+from ui import Menu, Printer, PrettyPrinter, Checkbox, MenuExitException
+
+try:
+    import systemctl
+except ImportError as e:
+    try: # Are we missing gi.repository?
+        import gi.repository
+    except ImportError: # Yep, that's the case - let's disable the library so we can notify the user
+        systemctl = None
+    else: # Nope, it's something else - re-raising
+        raise e
+
+from helpers import read_or_create_config, write_config, local_path_gen
+local_path = local_path_gen(__name__)
+config_path = local_path(config_filename)
+config = read_or_create_config(config_path, default_config, menu_name+" app")
+
+#Migrating config in case it's preserved from older app versions
+if "pinned_units" not in config:
+    config["pinned_units"] = ["zpui.service"]
+    write_config(config, config_path)
+
+def change_filters():
+    global config
+    all_types = [
+    ["Slices", 'slice'],
+    ["Sockets", 'socket'],
+    ["Services", 'service'],
+    ["Automounts", 'automount'],
+    ["Mounts", 'mount'],
+    ["Timers", 'timer'],
+    ["Paths", 'path'],
+    ["Devices", 'device'],
+    ["Scopes", 'scope'],
+    ["Targets", 'target']]
+    checkbox_contents = []
+    for type in all_types:
+        checkbox_contents.append([type[0], type[1], type[1] in config["allowed_types"]])
+    states = Checkbox(checkbox_contents, i, o, final_button_name="Save").activate()
+    if states is None: return None
+    config["allowed_types"] = [state for state in states if states[state]]
+    write_config(config, config_path)
+
+def all_units():
+    menu_contents = []
+    units = systemctl.list_units()
+    for unit in units:
+        menu_contents.append([unit["name"], lambda x=unit: unit_menu(x)])
+    Menu(menu_contents, i, o, "Systemctl: all unit list menu").activate()
+
+def pinned_units():
+    menu_contents = []
+    units = systemctl.list_units("name", config["pinned_units"])
+    for unit in units:
+        menu_contents.append([unit["name"], lambda x=unit["name"]: unit_menu({"name":x}, in_pinned=True)])
+    Menu(menu_contents, i, o, "Pinned unit list menu").activate()
+
+def filtered_units():
+    menu_contents = []
+    units = systemctl.list_units("unit_type", config["allowed_types"])
+    for unit in units:
+        menu_contents.append([unit["name"], lambda x=unit: unit_menu(x)])
+    Menu(menu_contents, i, o, "Systemctl: filtered unit list menu").activate()
+
+def unit_menu(unit, in_pinned=False):
+    name = unit["name"]
+    unit_menu_contents = [
+    ["Full name", lambda x=name: Printer(x, i, o)],
+    ["Start unit", lambda x=name: start_unit(x)],
+    ["Stop unit", lambda x=name: stop_unit(x)],
+    ["Restart unit", lambda x=name: restart_unit(x)],
+    ["Reload unit", lambda x=name: reload_unit(x)],
+    ["Enable unit", lambda x=name: enable_unit(x)],
+    ["Disable unit", lambda x=name: disable_unit(x)]]
+    if in_pinned:
+        unit_menu_contents.append(["Unpin unit", lambda x=name: unpin_unit(x)])
+    else:
+        unit_menu_contents.append(["Pin unit", lambda x=name: pin_unit(x)])
+    Menu(unit_menu_contents, i, o, "{} unit menu".format(name)).activate()
+
+def pin_unit(name):
+    global config
+    config["pinned_units"].append(name)
+    write_config(config, config_path)
+    PrettyPrinter("Pinned unit {}".format(name), i, o, 1)
+
+def unpin_unit(name):
+    global config
+    if name in config["pinned_units"]:
+        config["pinned_units"].remove(name)
+        write_config(config, config_path)
+        PrettyPrinter("Unpinned unit {}".format(name), i, o, 1)
+    else:
+        PrettyPrinter("Error: unit {} not pinned!".format(name), i, o, 1)
+
+#Those functions might benefit from being turned into one generic function, I think
+
+def start_unit(name):
+    status = systemctl.action_unit("start", name)
+    if status:
+        PrettyPrinter("Started unit {}".format(name), i, o, 1)
+    else:
+        PrettyPrinter("Can't start {}".format(name), i, o, 1)
+    raise MenuExitException
+
+def stop_unit(name):
+    status = systemctl.action_unit("stop", name)
+    if status:
+        PrettyPrinter("Stopped unit {}".format(name), i, o, 1)
+    else:
+        PrettyPrinter("Can't stop {}".format(name), i, o, 1)
+    raise MenuExitException
+
+def restart_unit(name):
+    status = systemctl.action_unit("restart", name)
+    if status:
+        PrettyPrinter("Restarted unit {}".format(name), i, o, 1)
+    else:
+        PrettyPrinter("Can't restart {}".format(name), i, o, 1)
+    raise MenuExitException
+
+def reload_unit(name):
+    status = systemctl.action_unit("reload", name)
+    if status:
+        PrettyPrinter("Reloaded unit {}".format(name), i, o, 1)
+    else:
+        PrettyPrinter("Can't reload {}".format(name), i, o, 1)
+    raise MenuExitException
+
+def enable_unit(name):
+    status = systemctl.action_unit("enable", name)
+    if status:
+        PrettyPrinter("Enabled unit {}".format(name), i, o, 1)
+    else:
+        PrettyPrinter("Can't enable {}".format(name), i, o, 1)
+    raise MenuExitException
+
+def disable_unit(name):
+    status = systemctl.action_unit("disable", name)
+    if status:
+        PrettyPrinter("Disabled unit {}".format(name), i, o, 1)
+    else:
+        PrettyPrinter("Can't disable {}".format(name), i, o, 1)
+    raise MenuExitException
+
+
+def callback():
+    if systemctl is None:
+       PrettyPrinter("python-gi not found! Please install it using 'apt-get install python-gi' ", i, o, 5)
+       return
+    try:
+       systemctl.list_units()
+    except OSError as e:
+       if e.errno == 2:
+           PrettyPrinter("Do you use systemctl?", i, o, 3, skippable=True)
+           return
+       else:
+           raise e
+    main_menu_contents = [
+    ["Pinned units", pinned_units],
+    ["Units (filtered)", filtered_units],
+    ["All units", all_units],
+    ["Change filters", change_filters]]
+    main_menu = Menu(main_menu_contents, i, o, "systemctl main menu")
+    main_menu.activate()
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
diff --git a/zpui/apps/system_apps/systemctl/systemctl.py b/zpui/apps/system_apps/systemctl/systemctl.py
new file mode 100644
index 0000000..8bf1c7e
--- /dev/null
+++ b/zpui/apps/system_apps/systemctl/systemctl.py
@@ -0,0 +1,97 @@
+from helpers import setup_logger
+from pydbus import SystemBus
+
+from operator import itemgetter
+
+logger = setup_logger(__name__, "warning")
+
+# See D-Bus documentation here:
+#     https://www.freedesktop.org/wiki/Software/systemd/dbus/
+
+bus = SystemBus()
+systemd = bus.get(".systemd1")
+
+def list_units(unit_filter_field = None, unit_filter_values = []):
+    """
+    This function lists units, optionally filtering them by a certain parameter.
+    It returns a list of dictionaries, with following fields:
+
+    * ``"name"``: Full unit name, in the "name.type" format - i.e. "zpui.service"
+    * ``"basename"``: Unit name without unit type - i.e. "zpui"
+    * ``"unit_type"``: Unit type - i.e. "service", "socket" or "target"
+    * ``"description"``: Unit's human-readable description
+    * ``"active"``: Whether the unit is now active - i.e. "active", "failed", "inactive"
+    * ``"load"``: Whether the unit is now loaded - i.e. "loaded", "masked", "not found"
+    * ``"sub"``: Type-specific unit state - i.e.  "running", "listening", "mounted"
+    * ``"follower"``: A unit that is being followed in its state by this unit, if there is any, otherwise an empty string.
+    * ``"unit_object_path"``: The unit object path
+    * ``"job_queued"``: If there is a job queued for the job unit - the numeric job id, 0 otherwise
+    * ``"job_object_path"``: The job object path
+    * ``"job_type"``: The job type as string
+
+    Arguments:
+
+      * ``unit_filter_field``: a field which to filter the units by.
+      * ``unit_filter_values``: a list of values for the given field that are acceptable
+    """
+
+    units = []
+
+    unit_params = ["name", "description", "load", "active", "sub", "follower", "unit_object_path", "job_queued", "job_type", "job_object_path"]
+    additional_params = ["basename", "unit_type"]
+
+    if unit_filter_field and unit_filter_field not in unit_params+additional_params:
+        logger.error("Set unit_filter_field '{}' not one of '{}'".format(unit_filter_field, available_unit_filter_fields))
+        return False
+
+    for unit in systemd.ListUnits():
+        unit_dict = {}
+        assert (len(unit) == len(unit_params)), "Can't unpack the unit list - wrong number of arguments!"
+        for i, param in enumerate(unit_params):
+            unit_dict[param] = unit[i]
+
+        unit_dict["basename"], unit_dict["unit_type"] = unit_dict["name"].rsplit('.', 1)
+
+        if unit_filter_field is None or unit_dict[unit_filter_field] in unit_filter_values:
+            units.append(unit_dict)
+
+    units = sorted(units, key=itemgetter('name'))
+
+    return units
+
+
+def action_unit(action, unit):
+    # See D-Bus documentation (linked above) for argument explanation
+    job = False
+
+    try:
+        if action is "start":
+            job = systemd.StartUnit(unit, "fail")
+        elif action is "stop":
+            job = systemd.StopUnit(unit, "fail")
+        elif action is "restart":
+            job = systemd.RestartUnit(unit, "fail")
+        elif action is "reload":
+            job = systemd.ReloadUnit(unit, "fail")
+        elif action is "reload-or-restart":
+            job = systemd.ReloadOrRestartUnit(unit, "fail")
+        else:
+            logger.error("Unknown action '{}' attempted on unit '{}'".format(action, unit))
+    except Exception as e:
+        logger.exception("Exception while trying to run '{}' on unit '{}'".format(action, unit))
+
+    return job
+
+if __name__ == "__main__":
+    units_loaded = list_units('load', ['loaded'])
+    units_active = list_units('active', ['active'])
+    units_sub    = list_units('sub', ['sub'])
+
+    for unit in units_loaded:
+        print(unit["name"])
+
+    for unit in units_active:
+        print(unit["name"])
+
+    for unit in units_sub:
+        print(unit["name"])
diff --git a/zpui/apps/test_hardware/.gitignore b/zpui/apps/test_hardware/.gitignore
new file mode 100644
index 0000000..33b8a9e
--- /dev/null
+++ b/zpui/apps/test_hardware/.gitignore
@@ -0,0 +1 @@
+test.mp3
diff --git a/zpui/apps/test_hardware/__init__.py b/zpui/apps/test_hardware/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/test_hardware/key_test.py b/zpui/apps/test_hardware/key_test.py
new file mode 100755
index 0000000..67466d7
--- /dev/null
+++ b/zpui/apps/test_hardware/key_test.py
@@ -0,0 +1,39 @@
+menu_name = "Refresher app" 
+
+from ui import Refresher, PrettyPrinter
+
+counter = 0
+keys_called = []
+
+def process_key(key, *args):
+    global counter, keys_called
+    if len(keys_called) >= o.rows:
+        keys_called = keys_called[1:]
+    keys_called.append([counter, key])
+    counter += 1
+    ltk = [k for c, k in keys_called][-3:]
+    if len(ltk) >= 3 and ltk[0]==ltk[1]==ltk[2]:
+        refresher.deactivate()
+    else:
+        refresher.refresh() #Makes changes appear faster
+
+def get_keys():
+    return ["{}:{}".format(num, key) for num, key in keys_called]
+
+refresher = None
+i = None #Input device
+o = None #Output device
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output 
+
+def callback():
+    global refresher, keys_called
+    keys_called = []
+    i.set_streaming(process_key)
+    refresher = Refresher(get_keys, i, o, 1, name="Key monitor")
+    refresher.keymap.pop("KEY_LEFT") #Removing deactivate callback to show KEY_LEFT
+    PrettyPrinter("To exit this app, press the same key 3 times", i, o)
+    refresher.activate()
+    i.remove_streaming()
diff --git a/zpui/apps/test_hardware/main.py b/zpui/apps/test_hardware/main.py
new file mode 100755
index 0000000..9f5aa27
--- /dev/null
+++ b/zpui/apps/test_hardware/main.py
@@ -0,0 +1,129 @@
+
+
+from helpers import setup_logger
+
+menu_name = "Hardware test"
+
+from threading import Event, Thread
+from traceback import format_exc
+from subprocess import call
+from time import sleep
+import sys
+import os
+
+from ui import Menu, Printer, PrettyPrinter, GraphicsPrinter
+from helpers import ExitHelper, local_path_gen
+
+logger = setup_logger(__name__, "warning")
+
+i = None
+o = None
+
+#Code from downloading a song from http://freemusicarchive.org/
+downloaded = Event()
+url = "http://wiki.zerophone.org/images/b/b5/Otis_McMusic.mp3"
+
+music_filename = "test.mp3"
+local_path = local_path_gen(__name__)
+music_path = local_path(music_filename)
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+    if music_filename not in os.listdir(local_path('.')):
+        def download():
+            downloaded.clear()
+            logger.debug("Downloading music for hardware test app!")
+            call(["wget", url, "-O", music_path])
+            downloaded.set()
+        t = Thread(target=download)
+        t.daemon=True
+        t.start()
+    else:
+        downloaded.set()
+
+def callback():
+    try:
+        #Testing I2C - 0x12 should answer, 0x20 should raise IOError with busy errno
+        from smbus import SMBus
+        bus = SMBus(1)
+        try:
+            bus.read_byte(0x12)
+        except IOError:
+            PrettyPrinter("Keypad does not respond!", i, o)
+        else:
+            PrettyPrinter("Keypad found!", i, o)
+        #Checking IO expander
+        expander_ok = False
+        try:
+            bus.read_byte(0x20)
+        except IOError as e:
+            if e.errno == 16:
+                PrettyPrinter("IO expander OK!", i, o)
+                expander_ok = True
+            elif e.errno == 121:
+                PrettyPrinter("IO expander not found!", i, o)
+        else:
+            PrettyPrinter("IO expander driver not loaded!", i, o)
+        #Launching splashscreen
+        GraphicsPrinter("splash.png", i, o, 2)
+        #Launching key_test app from app folder, that's symlinked from example app folder
+        PrettyPrinter("Testing keypad", i, o, 1)
+        import key_test
+        key_test.init_app(i, o)
+        key_test.callback()
+        #Following things depend on I2C IO expander,
+        #which might not be present:
+        if expander_ok:
+            #Testing charging detection
+            PrettyPrinter("Testing charger detection", i, o, 1)
+            from zerophone_hw import is_charging
+            eh = ExitHelper(i, ["KEY_LEFT", "KEY_ENTER"]).start()
+            if is_charging():
+                PrettyPrinter("Charging, unplug charger to continue \n Enter to bypass", None, o, 0)
+                while is_charging() and eh.do_run():
+                    sleep(1)
+            else:
+                PrettyPrinter("Not charging, plug charger to continue \n Enter to bypass", None, o, 0)
+                while not is_charging() and eh.do_run():
+                    sleep(1)
+            #Testing the RGB LED
+            PrettyPrinter("Testing RGB LED", i, o, 1)
+            from zerophone_hw import RGB_LED
+            led = RGB_LED()
+            for color in ["red", "green", "blue"]:
+                led.set_color(color)
+                Printer(color.center(o.cols), i, o, 3)
+            led.set_color("none")
+        #Testing audio jack sound
+        PrettyPrinter("Testing audio jack", i, o, 1)
+        if not downloaded.isSet():
+            PrettyPrinter("Audio jack test music not yet downloaded, waiting...", i, o)
+            downloaded.wait()
+        disclaimer = ["Track used:" "", "Otis McDonald", "-", "Otis McMusic", "YT AudioLibrary"]
+        Printer([s.center(o.cols) for s in disclaimer], i, o, 3)
+        PrettyPrinter("Press C1 to restart music, C2 to continue testing", i, o)
+        import pygame
+        pygame.mixer.init()
+        pygame.mixer.music.load(music_path)
+        pygame.mixer.music.play()
+        continue_event = Event()
+        def restart():
+            pygame.mixer.music.stop()
+            pygame.mixer.init()
+            pygame.mixer.music.load(music_path)
+            pygame.mixer.music.play()
+        def stop():
+            pygame.mixer.music.stop()
+            continue_event.set()
+        i.clear_keymap()
+        i.set_callback("KEY_F1", restart)
+        i.set_callback("KEY_F2", stop)
+        i.set_callback("KEY_ENTER", stop)
+        continue_event.wait()
+        #Self-test passed, it seems!
+    except:
+        exc = format_exc()
+        PrettyPrinter(exc, i, o, 10)
+    else:
+        PrettyPrinter("Self-test passed!", i, o, 3, skippable=False)
diff --git a/zpui/apps/utils/__init__.py b/zpui/apps/utils/__init__.py
new file mode 100644
index 0000000..83ad23b
--- /dev/null
+++ b/zpui/apps/utils/__init__.py
@@ -0,0 +1 @@
+_menu_name = "Utilities"
diff --git a/zpui/apps/utils/file_browser/__init__.py b/zpui/apps/utils/file_browser/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/utils/file_browser/main.py b/zpui/apps/utils/file_browser/main.py
new file mode 100755
index 0000000..54a48e4
--- /dev/null
+++ b/zpui/apps/utils/file_browser/main.py
@@ -0,0 +1,27 @@
+menu_name = "File browser" 
+
+from ui import PathPicker, Printer
+import os
+
+callback = None
+
+i = None
+o = None
+
+def init_app(input, output):
+    global callback, i, o
+    i = input; o = output
+    callback = browse
+
+def print_path(path):
+    if os.path.isdir(path):
+        Printer("Dir: {}".format(path), i, o, 5)
+    elif os.path.isfile(path):
+        Printer("File: {}".format(path), i, o, 5)
+    else:
+        Printer("WTF: {}".format(path), i, o, 5) # ;-P
+
+def browse():
+    #"File options" menu yet to be added
+    path_picker = PathPicker("/", i, o, callback=print_path)
+    path_picker.activate() 
diff --git a/zpui/apps/utils/spinner/__init__.py b/zpui/apps/utils/spinner/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/utils/spinner/main.py b/zpui/apps/utils/spinner/main.py
new file mode 100755
index 0000000..7e9b709
--- /dev/null
+++ b/zpui/apps/utils/spinner/main.py
@@ -0,0 +1,22 @@
+menu_name = "Spinner"
+
+from ui import Throbber
+from helpers import ExitHelper
+
+i = None
+o = None
+
+def init_app(input, output):
+    global i, o
+    i = input; o = output
+
+class InputlessThrobber(Throbber):
+    def activate_keymap(self):
+        pass
+
+def callback():
+    eh = ExitHelper(i)
+    th = InputlessThrobber(i, o, message="Idle spinner")
+    eh.set_callback(th.stop)
+    eh.start()
+    th.activate()
diff --git a/zpui/apps/zero_app.py b/zpui/apps/zero_app.py
new file mode 100644
index 0000000..386c639
--- /dev/null
+++ b/zpui/apps/zero_app.py
@@ -0,0 +1,28 @@
+class ZeroApp(object):
+    """
+    A template class for a Zerophone App. Presents default functions that are called by the app manager.
+    Keeps a pointer to the input and output devices
+    """
+
+    def __init__(self, i, o):
+        """ctor : called when the ZPUI boots. Avoid loading too many objects here. The application is not yet
+        opened. Without knowing if you app will be used, do not burden the poor CPU with unused stuff."""
+        # type: (InputListener, object) -> ZeroApp
+        self.__output = o
+        self.__input = i
+        if not hasattr(self, "menu_name"):
+            self.menu_name = "ZeroApp template"  # Name as presented in the menu
+
+    @property
+    def i(self):
+        return self.__input
+
+    @property
+    def o(self):
+        return self.__output
+
+    def on_start(self):
+        """
+        Called ONCE when the app is selected FOR THE FIRST TIME in the menu
+        """
+        pass
diff --git a/zpui/apps/zeromenu/__init__.py b/zpui/apps/zeromenu/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/apps/zeromenu/main.py b/zpui/apps/zeromenu/main.py
new file mode 100644
index 0000000..7ab8347
--- /dev/null
+++ b/zpui/apps/zeromenu/main.py
@@ -0,0 +1,52 @@
+menu_name = "ZeroMenu"
+
+from apps.flashlight import main as flashlight
+from zerophone_hw import USB_DCDC
+from datetime import datetime
+from threading import Event
+from ui import Menu, PrettyPrinter
+import os
+i = None; o = None
+
+context = None
+zeromenu = None
+
+screenshot_folder = "screenshots"
+
+dcdc = USB_DCDC()
+
+def take_screenshot():
+    image = context.get_previous_context_image()
+    if image != None:
+        timestamp = datetime.now().strftime("%y%m%d-%H%M%S")
+        filename = "screenshot_{}.png".format(timestamp)
+        path = os.path.join(screenshot_folder, filename)
+        image.save(path, "PNG")
+        PrettyPrinter("Screenshot saved to {}".format(path), i, o)
+
+def toggle_flashlight():
+    flashlight.callback()
+
+def usb_on():
+    dcdc.on()
+
+def usb_off():
+    dcdc.off()
+
+def set_context(received_context):
+    global context
+    context = received_context
+    context.request_global_keymap({"KEY_PROG2":context.request_switch})
+    context.set_target(zeromenu.activate)
+
+def init_app(input, output):
+    global i, o, zeromenu
+    i = input; o = output
+    menu_contents = [["Flashlight", toggle_flashlight],
+                     ["USB on", usb_on],
+                     ["USB off", usb_off],
+                     ["Take screenshot", take_screenshot] ]
+    if screenshot_folder not in os.listdir("."):
+        os.mkdir(screenshot_folder)
+    zeromenu = Menu(menu_contents, i, o, name="ZeroMenu main menu")
+
diff --git a/context_manager.py b/zpui/context_manager.py
similarity index 100%
rename from context_manager.py
rename to zpui/context_manager.py
diff --git a/zpui/docs/Makefile b/zpui/docs/Makefile
new file mode 100644
index 0000000..dd54252
--- /dev/null
+++ b/zpui/docs/Makefile
@@ -0,0 +1,216 @@
+# Makefile for Sphinx documentation
+#
+
+# You can set these variables from the command line.
+SPHINXOPTS    =
+SPHINXBUILD   = sphinx-build
+PAPER         =
+BUILDDIR      = _build
+
+# User-friendly check for sphinx-build
+ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)
+$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)
+endif
+
+# Internal variables.
+PAPEROPT_a4     = -D latex_paper_size=a4
+PAPEROPT_letter = -D latex_paper_size=letter
+ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+# the i18n builder cannot share the environment and doctrees with the others
+I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
+
+.PHONY: help
+help:
+	@echo "Please use \`make <target>' where <target> is one of"
+	@echo "  html       to make standalone HTML files"
+	@echo "  dirhtml    to make HTML files named index.html in directories"
+	@echo "  singlehtml to make a single large HTML file"
+	@echo "  pickle     to make pickle files"
+	@echo "  json       to make JSON files"
+	@echo "  htmlhelp   to make HTML files and a HTML help project"
+	@echo "  qthelp     to make HTML files and a qthelp project"
+	@echo "  applehelp  to make an Apple Help Book"
+	@echo "  devhelp    to make HTML files and a Devhelp project"
+	@echo "  epub       to make an epub"
+	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
+	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
+	@echo "  latexpdfja to make LaTeX files and run them through platex/dvipdfmx"
+	@echo "  text       to make text files"
+	@echo "  man        to make manual pages"
+	@echo "  texinfo    to make Texinfo files"
+	@echo "  info       to make Texinfo files and run them through makeinfo"
+	@echo "  gettext    to make PO message catalogs"
+	@echo "  changes    to make an overview of all changed/added/deprecated items"
+	@echo "  xml        to make Docutils-native XML files"
+	@echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
+	@echo "  linkcheck  to check all external links for integrity"
+	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
+	@echo "  coverage   to run coverage check of the documentation (if enabled)"
+
+.PHONY: clean
+clean:
+	rm -rf $(BUILDDIR)/*
+
+.PHONY: html
+html:
+	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."
+
+.PHONY: dirhtml
+dirhtml:
+	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
+	@echo
+	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."
+
+.PHONY: singlehtml
+singlehtml:
+	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
+	@echo
+	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."
+
+.PHONY: pickle
+pickle:
+	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
+	@echo
+	@echo "Build finished; now you can process the pickle files."
+
+.PHONY: json
+json:
+	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
+	@echo
+	@echo "Build finished; now you can process the JSON files."
+
+.PHONY: htmlhelp
+htmlhelp:
+	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
+	@echo
+	@echo "Build finished; now you can run HTML Help Workshop with the" \
+	      ".hhp project file in $(BUILDDIR)/htmlhelp."
+
+.PHONY: qthelp
+qthelp:
+	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
+	@echo
+	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
+	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
+	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/ZPUI.qhcp"
+	@echo "To view the help file:"
+	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/ZPUI.qhc"
+
+.PHONY: applehelp
+applehelp:
+	$(SPHINXBUILD) -b applehelp $(ALLSPHINXOPTS) $(BUILDDIR)/applehelp
+	@echo
+	@echo "Build finished. The help book is in $(BUILDDIR)/applehelp."
+	@echo "N.B. You won't be able to view it unless you put it in" \
+	      "~/Library/Documentation/Help or install it in your application" \
+	      "bundle."
+
+.PHONY: devhelp
+devhelp:
+	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
+	@echo
+	@echo "Build finished."
+	@echo "To view the help file:"
+	@echo "# mkdir -p $$HOME/.local/share/devhelp/ZPUI"
+	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/ZPUI"
+	@echo "# devhelp"
+
+.PHONY: epub
+epub:
+	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
+	@echo
+	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."
+
+.PHONY: latex
+latex:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo
+	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
+	@echo "Run \`make' in that directory to run these through (pdf)latex" \
+	      "(use \`make latexpdf' here to do that automatically)."
+
+.PHONY: latexpdf
+latexpdf:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through pdflatex..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+.PHONY: latexpdfja
+latexpdfja:
+	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
+	@echo "Running LaTeX files through platex and dvipdfmx..."
+	$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
+	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."
+
+.PHONY: text
+text:
+	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
+	@echo
+	@echo "Build finished. The text files are in $(BUILDDIR)/text."
+
+.PHONY: man
+man:
+	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
+	@echo
+	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."
+
+.PHONY: texinfo
+texinfo:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo
+	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
+	@echo "Run \`make' in that directory to run these through makeinfo" \
+	      "(use \`make info' here to do that automatically)."
+
+.PHONY: info
+info:
+	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
+	@echo "Running Texinfo files through makeinfo..."
+	make -C $(BUILDDIR)/texinfo info
+	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."
+
+.PHONY: gettext
+gettext:
+	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
+	@echo
+	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."
+
+.PHONY: changes
+changes:
+	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
+	@echo
+	@echo "The overview file is in $(BUILDDIR)/changes."
+
+.PHONY: linkcheck
+linkcheck:
+	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
+	@echo
+	@echo "Link check complete; look for any errors in the above output " \
+	      "or in $(BUILDDIR)/linkcheck/output.txt."
+
+.PHONY: doctest
+doctest:
+	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
+	@echo "Testing of doctests in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/doctest/output.txt."
+
+.PHONY: coverage
+coverage:
+	$(SPHINXBUILD) -b coverage $(ALLSPHINXOPTS) $(BUILDDIR)/coverage
+	@echo "Testing of coverage in the sources finished, look at the " \
+	      "results in $(BUILDDIR)/coverage/python.txt."
+
+.PHONY: xml
+xml:
+	$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
+	@echo
+	@echo "Build finished. The XML files are in $(BUILDDIR)/xml."
+
+.PHONY: pseudoxml
+pseudoxml:
+	$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
+	@echo
+	@echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."
diff --git a/zpui/docs/_static/ZPUI_Emulator.png b/zpui/docs/_static/ZPUI_Emulator.png
new file mode 100644
index 0000000..2166dbf
Binary files /dev/null and b/zpui/docs/_static/ZPUI_Emulator.png differ
diff --git a/zpui/docs/_static/canvas_test_1.png b/zpui/docs/_static/canvas_test_1.png
new file mode 100644
index 0000000..82cb718
Binary files /dev/null and b/zpui/docs/_static/canvas_test_1.png differ
diff --git a/zpui/docs/_static/canvas_test_2.png b/zpui/docs/_static/canvas_test_2.png
new file mode 100644
index 0000000..5298f07
Binary files /dev/null and b/zpui/docs/_static/canvas_test_2.png differ
diff --git a/zpui/docs/_static/canvas_test_3.png b/zpui/docs/_static/canvas_test_3.png
new file mode 100644
index 0000000..c1add06
Binary files /dev/null and b/zpui/docs/_static/canvas_test_3.png differ
diff --git a/zpui/docs/_static/canvas_test_4.png b/zpui/docs/_static/canvas_test_4.png
new file mode 100644
index 0000000..b6687b4
Binary files /dev/null and b/zpui/docs/_static/canvas_test_4.png differ
diff --git a/zpui/docs/_static/canvas_test_5.png b/zpui/docs/_static/canvas_test_5.png
new file mode 100644
index 0000000..5635843
Binary files /dev/null and b/zpui/docs/_static/canvas_test_5.png differ
diff --git a/zpui/docs/_static/canvas_test_6.png b/zpui/docs/_static/canvas_test_6.png
new file mode 100644
index 0000000..4e51160
Binary files /dev/null and b/zpui/docs/_static/canvas_test_6.png differ
diff --git a/zpui/docs/_static/canvas_test_7.png b/zpui/docs/_static/canvas_test_7.png
new file mode 100644
index 0000000..5952630
Binary files /dev/null and b/zpui/docs/_static/canvas_test_7.png differ
diff --git a/zpui/docs/_static/canvas_test_8.png b/zpui/docs/_static/canvas_test_8.png
new file mode 100644
index 0000000..148dcd8
Binary files /dev/null and b/zpui/docs/_static/canvas_test_8.png differ
diff --git a/zpui/docs/app_mgmt.rst b/zpui/docs/app_mgmt.rst
new file mode 100644
index 0000000..682aa3c
--- /dev/null
+++ b/zpui/docs/app_mgmt.rst
@@ -0,0 +1,50 @@
+.. _app_mgmt:
+                    
+####################################
+Managing and developing applications
+####################################
+
+General information
+===================
+
+* Applications are simply folders which are made importable by Python by adding an ``__init__.py`` file. ZPUI loads ``main.py`` file residing in that folder.
+* You can combine UI elements in many different ways, including making nested menus, which makes apps less cluttered. 
+* ZPUI main menu can have submenus. Submenu is just a folder which has ``__init__.py`` file in it, but doesn't have a ``main.py`` file. It can store both application folders and child submenu folders.
+
+  * To set a main menu name for your submenu, you need to add ``_menu_name = "Pretty name"`` in ``__init__.py`` file of a submenu.
+  * Submenus can be nested - just create another folder inside a submenu folder. However, submenu inside an application folder won't be detected.
+
+* All application modules are loading when ZPUI loads. When choosing an application in the main menu/submenu, its global ``callback`` or ``ZeroApp.on_load()`` is called. It's usually set as the ``activate()`` method of application's main UI element, such as a menu.
+* You can prevent any application from autoloading (but still have an option to load it manually) by placing a ``do_not_load`` file (with any contents) in application's folder (for example, see skeleton application folder).
+
+Getting Started
+===============
+ZPUI enables two way of developping apps. One is function-based, the other one is class-based.
+
+Function-based
+--------------
+Function-based apps need two functions to work : ``init_app`` and ``callback``.
+
+* ``init_app(i, o)`` is called when the app is **loaded**. That is, when the UI boots. Avoid doing any heavy work here, it would slow down everything, and there is no guarantee the app is going to be activated at this point. You may want to keep a reference to the two parameters for later usage. See below.
+* ``callback()`` is called when the app is actually opened and brought to foreground. This is where most of your code should belong.
+* ``menu_name`` is a global variable that can be set to define the name of the application shown in the main menu. If not provided, it will fall back to the name of the parent directory.
+* ``global i, o`` are global variables commonly used to keep a reference to the input and output devices passed in the ``init`` function.
+
+Usage example :  :ref:`skeleton_app <skeleton_app>`
+
+Class-based
+-----------
+Class-based apps need a single ``class`` inheriting from ``ZeroApp`` to work.
+
+* ``__init__(self, i, o)`` is called when the app is **loaded**. That is, when the UI boots. Avoid doing any heavy work here, it would slow down everything, and there is no guarantee the app is going to be activated at this point. You need to call the base class constructor to keep a reference to the input and output devices (``self.i, self.o``).
+* ``on_load(self)`` is called when the app is actually opened and brought to foreground. This is where most of your code should belong.
+* ``menu_name`` is a member variable that can be set to define the name of the application shown in the main menu. If not provided, it will fall back to the name of the parent directory.
+
+You can see :ref:`class skeleton app <class_skeleton_app>` for an example.
+
+Development tips
+================
+
+* For starters, take a look at the :ref:`skeleton app <skeleton_app>` and :ref:`class skeleton app <class_skeleton_app>`
+* You can launch ZPUI in a "single application mode" using ``main.py -a apps/app_folder_path``. There'll be no main menu constructed, and exiting the application exits ZPUI.
+* You should not set input callbacks or output to screen while your application is not the one active. It'll cause screen contents set from another application to be overwritten, which is bad user experience. Make sure your application is the one currently active before outputting things and setting callbacks.
diff --git a/zpui/docs/apps.rst b/zpui/docs/apps.rst
new file mode 100644
index 0000000..e395e3d
--- /dev/null
+++ b/zpui/docs/apps.rst
@@ -0,0 +1,50 @@
+==================
+Applications
+==================
+
+Applications are layer between user's goals and same goals accomplished. ZPUI applications are similar to desktop applications, each of them is mean to perform one function/set of similar functions, and perform it well.
+There can be an application for any task you want to use ZPUI for - in the worst case, you can write one ;-)
+
+Applications bundled with the default install are:
+
+   * :ref:`apps_clock`
+   * :ref:`apps_i2ctools`
+   * :ref:`apps_lsusb`
+   * :ref:`apps_mocp`
+   * :ref:`apps_network`
+   * :ref:`apps_partitions`
+   * :ref:`apps_scripts`
+   * :ref:`apps_shutdown`
+   * :ref:`apps_system_info`
+   * :ref:`apps_systemctl`
+   * :ref:`apps_tvservice`
+   * :ref:`apps_update`
+   * :ref:`apps_volume`
+   * :ref:`apps_wpa_cli`
+
+Some information on maintaining and writing applications:
+
+   * :ref:`Developing and managing applications <app_mgmt>`
+   * :ref:`Skeleton application <skeleton_app>`
+   * :ref:`Class-based skeleton application <class_skeleton_app>`
+
+.. toctree::
+   :maxdepth: 1
+   :hidden:
+
+   apps/clock.rst
+   apps/i2ctools.rst
+   apps/lsusb.rst
+   apps/mocp.rst
+   apps/network.rst
+   apps/partitions.rst
+   apps/scripts.rst
+   apps/shutdown.rst
+   apps/skeleton.rst
+   apps/class_based_skeleton.rst
+   apps/system_info.rst
+   apps/systemctl.rst
+   apps/tvservice.rst
+   apps/update.rst
+   apps/volume.rst
+   apps/wpa_cli.rst
diff --git a/zpui/docs/apps/class_based_skeleton.rst b/zpui/docs/apps/class_based_skeleton.rst
new file mode 100644
index 0000000..388a7a2
--- /dev/null
+++ b/zpui/docs/apps/class_based_skeleton.rst
@@ -0,0 +1,12 @@
+.. _class_skeleton_app:
+
+############
+Skeleton app
+############
+
+This is an `example application`_. It shows basics of initializing your application in a class based fashion, some conventions you need to follow and basics of working with UI elements.
+
+.. _example application: https://github.com/ZeroPhone/ZPUI/tree/master/apps/example_apps/class_based_skeleton
+
+.. include:: ../../apps/example_apps/class_based_skeleton/main.py
+    :code: python
diff --git a/zpui/docs/apps/clock.rst b/zpui/docs/apps/clock.rst
new file mode 100644
index 0000000..2943751
--- /dev/null
+++ b/zpui/docs/apps/clock.rst
@@ -0,0 +1,7 @@
+.. _apps_clock:
+
+#########
+Clock app
+#########
+
+This application gives you a simple clock that refreshes once a second. Time shown is the system time.
diff --git a/zpui/docs/apps/i2ctools.rst b/zpui/docs/apps/i2ctools.rst
new file mode 100644
index 0000000..e22e5c5
--- /dev/null
+++ b/zpui/docs/apps/i2ctools.rst
@@ -0,0 +1,7 @@
+.. _apps_i2ctools:
+
+=======================
+I2C toolkit application
+=======================
+
+As for now, this is a fairly simple application which just scans the I2C bus and lists all the devices that have responded. Plans are to include I2C read and I2C write functionality in it.
diff --git a/zpui/docs/apps/lsusb.rst b/zpui/docs/apps/lsusb.rst
new file mode 100644
index 0000000..31101c2
--- /dev/null
+++ b/zpui/docs/apps/lsusb.rst
@@ -0,0 +1,9 @@
+.. _apps_lsusb:
+
+###################
+USB device info app
+###################
+
+This application gives you information about connected USB devices.
+
+It lists them in format ``["{bus}{dev},{vid_pid}", "name"]``, you can click on an entry to see full name of the device.
diff --git a/zpui/docs/apps/mocp.rst b/zpui/docs/apps/mocp.rst
new file mode 100644
index 0000000..66409e7
--- /dev/null
+++ b/zpui/docs/apps/mocp.rst
@@ -0,0 +1,7 @@
+.. _apps_mocp:
+
+========================
+Music player control app
+========================
+
+This is proof-of-concept application for controlling a music player - in this case, MOCP. It can switch track to next/previous, as well as toggle play/pause. 
diff --git a/zpui/docs/apps/network.rst b/zpui/docs/apps/network.rst
new file mode 100644
index 0000000..803485a
--- /dev/null
+++ b/zpui/docs/apps/network.rst
@@ -0,0 +1,13 @@
+.. _apps_network:
+
+===========================
+Network interface info app
+===========================
+
+This application shows you network connection information. Under the hood, it uses "ip" command.
+
+It shows you:
+
+* Interface state (up/down)
+* IP and IPv6 addresses
+* MAC addresses
diff --git a/zpui/docs/apps/partitions.rst b/zpui/docs/apps/partitions.rst
new file mode 100644
index 0000000..39daab0
--- /dev/null
+++ b/zpui/docs/apps/partitions.rst
@@ -0,0 +1,17 @@
+.. _apps_partitions:
+
+##########################
+Partition unmount&info app
+##########################
+
+This application lets you see the mounted partitions on your system, as well as unmount and eject them. 
+
+It's capable of:
+
+* Listing mounted drives
+* Unmounting them
+* Ejecting them
+* Unmounting them lazily
+
+.. note:: Lazy unmounting means the filesystem is unmounted as soon as it stops being busy
+
diff --git a/zpui/docs/apps/scripts.rst b/zpui/docs/apps/scripts.rst
new file mode 100644
index 0000000..715ca3a
--- /dev/null
+++ b/zpui/docs/apps/scripts.rst
@@ -0,0 +1,29 @@
+.. _apps_scripts:
+
+####################
+Script execution app
+####################
+
+This application lets you run various pre-defined scripts and commands.
+
+.. note:: It isn't yet capable of stopping application's execution or displaying application's output.
+	
+Defining applications is done in ``config.json`` file which is located in the application's directory (currently ``apps/scripts``). Its format is as follows:
+
+.. code:: json
+
+   [
+    {"path":"./s/login.sh", #Defining a script which's located relative to application directory (``apps/scripts``)
+     "name":"Hotspot login"}, #Defining a pretty name which'll be displayed by ZPUI in the application menu
+    {"path":"/root/backup.sh", #Defining a script by absolute path
+     "name":"Backup things",
+     "args":["--everything", "--now"]}, #Giving command-line arguments to a script
+    {"path":"mount", #Calling an external command available from $PATH
+     "name":"'mount' with -a", 
+     "args":["-a"]} #Again, command-line arguments
+   ]
+
+.. note:: #-starting comments aren't accepted in JSON and are provided solely for explanation purposes
+
+It also gets all the scripts in ``s/`` folder in application's directory and adds them to the script menu, if they're not available in ``config.json``.
+If "name" parameter is not provided or is not available, it falls back to using script's filename.
diff --git a/zpui/docs/apps/shutdown.rst b/zpui/docs/apps/shutdown.rst
new file mode 100644
index 0000000..48fb2bb
--- /dev/null
+++ b/zpui/docs/apps/shutdown.rst
@@ -0,0 +1,9 @@
+.. _apps_shutdown:
+
+===================
+Shutdown&reboot app
+===================
+
+This application lets you shutdown and reboot your system cleanly.
+
+
diff --git a/zpui/docs/apps/skeleton.rst b/zpui/docs/apps/skeleton.rst
new file mode 100644
index 0000000..995e397
--- /dev/null
+++ b/zpui/docs/apps/skeleton.rst
@@ -0,0 +1,12 @@
+.. _skeleton_app:
+                    
+############
+Skeleton app
+############
+
+This is an `example application`_. It shows basics of initializing your application, some conventions you need to follow and basics of working with UI elements.
+
+.. _example application: https://github.com/ZeroPhone/ZPUI/tree/master/apps/example_apps/skeleton
+
+.. include:: ../../apps/example_apps/skeleton/main.py
+    :code: python
diff --git a/zpui/docs/apps/system_info.rst b/zpui/docs/apps/system_info.rst
new file mode 100644
index 0000000..f3e412d
--- /dev/null
+++ b/zpui/docs/apps/system_info.rst
@@ -0,0 +1,13 @@
+.. _apps_system_info:
+
+######################
+System information app
+######################
+
+This application gives you information about various system parameters. 
+
+It can list:
+
+* Total, used and free memory amounts - same figures ``free`` command gives you
+* Uptime and load average ratings
+* System information - hostname, kernel version, acrhitecture and distribution information
diff --git a/zpui/docs/apps/systemctl.rst b/zpui/docs/apps/systemctl.rst
new file mode 100644
index 0000000..2a4c582
--- /dev/null
+++ b/zpui/docs/apps/systemctl.rst
@@ -0,0 +1,13 @@
+.. _apps_systemctl:
+
+###################
+Service control app
+###################
+
+This application lists all systemd units available and lets you manage them.
+
+It's capable of:
+
+* Starting/stopping/restarting/reloading units
+* Enabling and disabling units
+* Filtering units by their type (service/target/mount/etc.)
diff --git a/zpui/docs/apps/tvservice.rst b/zpui/docs/apps/tvservice.rst
new file mode 100644
index 0000000..38750e9
--- /dev/null
+++ b/zpui/docs/apps/tvservice.rst
@@ -0,0 +1,18 @@
+.. _apps_tvservice:
+
+#####################################
+Raspberry Pi video settings app
+#####################################
+
+This application lets you change the HDMI/TV display parameters on your Raspberry Pi. Useful when you, for example, want to hot-plug it to a monitor and make RPi recognise it.
+
+It uses a 'tvservice.py' wrapper library to provide a layer between command-line calls and UI (library is included in the application and resides in the application folder).
+
+It's capable of:
+
+* Turning HDMI display on (with preferred settings, see ``tvservice -p``) and off, as well as calling appropriate ``fbset`` triggers afterwards.
+* Choosing resolution from those the display supports
+* Viewing TVService status
+* Parsing and showing TVService flags
+
+TVService is installed by default on Raspbian.
diff --git a/zpui/docs/apps/update.rst b/zpui/docs/apps/update.rst
new file mode 100644
index 0000000..2f5c762
--- /dev/null
+++ b/zpui/docs/apps/update.rst
@@ -0,0 +1,9 @@
+.. _apps_update:
+
+################
+ZPUI update app
+################
+
+This application updates your ZPUI install by pulling the latest commits straight from ZPUI GitHub. 
+
+.. note:: Do remember this updates only the ZPUI install currently running, effectively, doing a ``git pull`` in the current directory. So, if it's launched (it is unless you're launching it manually at the moment) from the install directory (most likely), it'll "git pull" inside the download directory (/opt/zpui by default), and vice-versa.
diff --git a/zpui/docs/apps/volume.rst b/zpui/docs/apps/volume.rst
new file mode 100644
index 0000000..f530d7b
--- /dev/null
+++ b/zpui/docs/apps/volume.rst
@@ -0,0 +1,7 @@
+.. _apps_volume:
+
+==========================
+Volume control application
+==========================
+
+This is a simple application for controlling volume. As for now, it supports turning volume up/down or muting it for a single mixer channel. Under the hood, it uses 'amixer'.
diff --git a/zpui/docs/apps/wpa_cli.rst b/zpui/docs/apps/wpa_cli.rst
new file mode 100644
index 0000000..b7a428f
--- /dev/null
+++ b/zpui/docs/apps/wpa_cli.rst
@@ -0,0 +1,23 @@
+.. _apps_wpa_cli:
+
+########################
+Wireless connections app
+########################
+
+This application lets you connect to wireless networks and manage connections. Under the hood, it uses ``wpa_cli`` to connect to a running ``wpa_supplicant`` instance. 
+
+.. note:: Seriously, wpa_supplicant as wireless management daemon is awesome. Minimalistic and really easy to interface. Also, it's included and running in latest Raspbian versions (from 02.16). 
+
+It uses a 'wpa_cli.py' wrapper library to provide a layer between command-line calls and UI (library is included in the application and resides in the application folder).
+
+It's capable of:
+
+* Scanning wireless networks and displaying scan results
+* Connecting to known and open wireless networks
+* Viewing wireless connection status
+* Managing multiple wireless interfaces
+* Saving configuration changes to wpa_supplicant.conf file
+
+
+If you're not running wpa_supplicant as a daemon and you want to do it, you should follow `this guide <https://learn.sparkfun.com/tutorials/using-pcduinos-wifi-dongle-with-the-pi/edit-interfaces>` for adjusting your /etc/network/interfaces and `this guide<https://learn.sparkfun.com/tutorials/using-pcduinos-wifi-dongle-with-the-pi/edit-wpasupplicantconf>` for creating contents of your /etc/wpa_supplicant/wpa_supplicant.conf.
+
diff --git a/zpui/docs/conf.py b/zpui/docs/conf.py
new file mode 100644
index 0000000..ae54be1
--- /dev/null
+++ b/zpui/docs/conf.py
@@ -0,0 +1,299 @@
+# -*- coding: utf-8 -*-
+#
+# ZPUI documentation build configuration file, created by
+# sphinx-quickstart on Mon Mar 28 01:03:08 2016.
+#
+# This file is execfile()d with the current directory set to its
+# containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import sys
+import os
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+#sys.path.insert(0, os.path.abspath('.'))
+
+# -- General configuration ------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = [
+    'sphinx.ext.autodoc',
+    'sphinx.ext.todo',
+    'sphinx.ext.coverage',
+    'sphinx.ext.viewcode',
+]
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix(es) of source filenames.
+# You can specify multiple suffix as a list of string:
+# source_suffix = ['.rst', '.md']
+source_suffix = '.rst'
+
+# The encoding of source files.
+#source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = u'ZPUI'
+copyright = u'2017, ZeroPhone Project'
+author = u'Arsenijs Picugins (CRImier) and ZeroPhone Project contributors'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+# The short X.Y version.
+version = u'1.0'
+# The full version, including alpha/beta/rc tags.
+release = u'1.0'
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#
+# This is also used if you do content translation via gettext catalogs.
+# Usually you set "language" from the command line for these cases.
+language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+#today = ''
+# Else, today_fmt is used as the format for a strftime call.
+#today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
+
+# The reST default role (used for this markup: `text`) to use for all
+# documents.
+#default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+#add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+#add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+#show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# A list of ignored prefixes for module index sorting.
+#modindex_common_prefix = []
+
+# If true, keep warnings as "system message" paragraphs in the built documents.
+#keep_warnings = False
+
+# If true, `todo` and `todoList` produce output, else they produce nothing.
+todo_include_todos = True
+
+
+# -- Options for HTML output ----------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+html_theme = 'sphinx_rtd_theme'
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+#html_theme_options = {}
+
+# Add any paths that contain custom themes here, relative to this directory.
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<release> documentation".
+#html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+#html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+#html_logo = None
+
+# The name of an image file (relative to this directory) to use as a favicon of
+# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+#html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+# Add any extra paths that contain custom files (such as robots.txt or
+# .htaccess) here, relative to this directory. These files are copied
+# directly to the root of the documentation.
+#html_extra_path = []
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+#html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+#html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+#html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+#html_additional_pages = {}
+
+# If false, no module index is generated.
+#html_domain_indices = True
+
+# If false, no index is generated.
+#html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+#html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+#html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+#html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Language to be used for generating the HTML full-text search index.
+# Sphinx supports the following languages:
+#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'
+#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr'
+#html_search_language = 'en'
+
+# A dictionary with options for the search language support, empty by default.
+# Now only 'ja' uses this config value
+#html_search_options = {'type': 'default'}
+
+# The name of a javascript file (relative to the configuration directory) that
+# implements a search results scorer. If empty, the default will be used.
+#html_search_scorer = 'scorer.js'
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'ZPUIdoc'
+
+# -- Options for LaTeX output ---------------------------------------------
+
+latex_elements = {
+# The paper size ('letterpaper' or 'a4paper').
+#'papersize': 'letterpaper',
+
+# The font size ('10pt', '11pt' or '12pt').
+#'pointsize': '10pt',
+
+# Additional stuff for the LaTeX preamble.
+#'preamble': '',
+
+# Latex figure (float) alignment
+#'figure_align': 'htbp',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title,
+#  author, documentclass [howto, manual, or own class]).
+latex_documents = [
+    (master_doc, 'ZPUI.tex', u'ZPUI Documentation',
+     u'ZeroPhone Project contributors', 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+#latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+#latex_use_parts = False
+
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+#latex_appendices = []
+
+# If false, no module index is generated.
+#latex_domain_indices = True
+
+
+# -- Options for manual page output ---------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    (master_doc, 'ZPUI', u'ZPUI Documentation',
+     [author], 1)
+]
+
+# If true, show URL addresses after external links.
+#man_show_urls = False
+
+
+# -- Options for Texinfo output -------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+    (master_doc, 'ZPUI', u'ZPUI Documentation',
+     author, 'ZPUI', 'One line description of project.',
+     'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+#texinfo_appendices = []
+
+# If false, no module index is generated.
+#texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#texinfo_show_urls = 'footnote'
+
+# If true, do not generate a @detailmenu in the "Top" node's menu.
+#texinfo_no_detailmenu = False
+
+autodoc_member_order = 'bysource'
+autodoc_mock_imports = ['evdev', 'smbus', 'pifacecad', 'RPi', 'RPi.GPIO' 'serial', 'luma', 'luma.core', 'luma.core.render']
+
+sys.path.insert(0,os.path.abspath("../"))
+
+on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
+
+if not on_rtd:  # only import and set the theme if we're building docs locally
+    import sphinx_rtd_theme
+    html_theme = "sphinx_rtd_theme"
+    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
diff --git a/zpui/docs/config.rst b/zpui/docs/config.rst
new file mode 100644
index 0000000..e4db3ca
--- /dev/null
+++ b/zpui/docs/config.rst
@@ -0,0 +1,136 @@
+.. _config:
+
+ZPUI configuration files
+========================
+
+ZPUI ``config.json``
+++++++++++++++++++++++++
+
+.. important::
+
+  By default, ZeroPhone SD card images and ZPUI installs ship with config.json files
+  that are suitable for usage out-of-the-box. Unless you want to tweak your IO drivers'
+  initialization parameters or need to debug ZPUI in case of hardware trouble,
+  you won't need to edit ZPUI configuration files.
+
+ZPUI depends on a ``config.json`` file to initialize the input and output devices. 
+To be exact, it expects a JSON-formatted file in one of the following paths (sorted by order
+in which ZPUI attempts to load them):
+
+* ``/boot/zpui_config.json``
+* ``/boot/pylci_config.json``
+* ``{ZPUI directory}/config.json``
+* ``{ZPUI directory}/config.example.json`` (a fallback file that you shouldn't edit manually)
+
+.. note::
+
+  The ``config.json`` tells ZPUI which output and input hardware it needs to use, so
+  invalid configuration might lock you out of the system. Thus, it's better to make changes
+  in ``/boot/zpui_config.json`` - if you screw up and lock yourself out of ZPUI,
+  it's easier to revert the changes since you can do it by just plugging your microSD
+  card in another computer and editing the file. You can also delete (or rename) the
+  file to make ZPUI fallback on a default config file.
+
+ZPUI config format
+-------------------
+
+Here's the default ZPUI config right now:
+
+.. include:: ../default_config.json
+    :code: json
+
+Here's the config file format: 
+
+.. code:: json
+
+   {
+     "input":
+     [{
+       "driver":"driver_filename",
+       "args":[ "value1", "value2", "value3"...]
+     }],
+   "output":
+     [{
+       "driver":"driver_filename",
+       "kwargs":{ "key":"value", "key2":"value2"}
+     }]
+   }
+
+Documentation for :doc:`input <input>` and :doc:`output <output>` drivers might have
+sample ``config.json`` sections for each driver. ``"args"`` and ``"kwargs"`` get passed
+directly to drivers' ``__init__`` method, so you can read the driver documentation
+or source to see if there are options you could tweak.
+
+
+.. _verify_json:
+
+Verifying your changes
+----------------------
+
+You can use ``jq`` to verify that you didn't make any JSON formatting mistakes:
+
+    ``jq '.' config.json``
+
+If the file is correct, it'll print it back. If there's anything wrong with the JSON
+formatting, it'll print an error message:
+
+    ``pi@zerophone:~/ZPUI#$ jq '.' config.json``
+    ``parse error: Expected separator between values at line 7, column 10``
+
+You might need to install ``jq`` beforehand:
+
+    ``sudo apt-get install jq``
+
+If you're editing the ``config.json`` file externally, you might not have access to the
+command-line. In that case, you can use an online JSON validator, such as `jsonlint.com`_
+- copy-paste contents of ``config.json`` there to see if the syntax is correct.
+
+.. _jsonlint.com: https://jsonlint.com/
+
+App-specific configuration files
+++++++++++++++++++++++++++++++++
+
+.. admonition:: TODO
+   :class: warning
+
+   This section is not yet ready. Sorry for that!
+
+Useful examples
++++++++++++++++
+
+Blacklisting the phone app to get access to UART console
+--------------------------------------------------------
+
+You might find yourself with a cracked screen one day, and needing to connect to your
+ZeroPhone nevertheless. In the unfortunate case you can't connect it to a wireless network
+in order to SSH into it (as the interface is inaccessible with a cracked screen), you
+can use a USB-UART to get to a console accessible on the UART port. 
+
+Unfortunately, console on the UART is disabled by default - because UART is also used
+for the GSM modem. However, you can tell ZPUI to not disable UART by disabling the phone
+app, and thus enabling the USB-UART debugging. To do that, you need to:
+
+1. Power down your ZeroPhone - since you can't access the UI, you have no other choice but
+   to shutdown it unsafely by unplugging the battery.
+2. Unplug the MicroSD card and plug it into another computer - both Windows and Linux will work
+3. On the first partition (the boot partition), locate the ``zpui_config.json`` file
+4. In that file, add an ``"app_manager"`` dictionary (a "collection" in JSON terms)
+5. Add the path to the phone app to a ``"do_not_load"`` list inside of it
+
+The resulting file should look like this, as a result:
+
+.. code:: json
+
+  {
+   "input": ... ,
+   "output": ... ,
+   "app_manager": {
+      "do_not_load":
+         ["apps/phone/"]
+    }
+  }
+
+Now, boot your phone with this config and you should be able to log in over UART!
+
+.. note:: Since you're editing the ``config.json`` file externally, you should
+          make sure it's valid JSON - :ref:`here's a guide for that. <verify_json>`
diff --git a/zpui/docs/contact.rst b/zpui/docs/contact.rst
new file mode 100644
index 0000000..5f3258c
--- /dev/null
+++ b/zpui/docs/contact.rst
@@ -0,0 +1,13 @@
+.. _contact:
+
+Contact us
+##########
+
+ZPUI development discussions happen on IRC, `#ZeroPhone on freenode`_. 
+If you have found a problem with ZPUI, want to suggest something or found
+that something isn't documented well, please open an `issue on GitHub`_.
+You can also `email the main developer`_ if you would like personal assistance.
+
+.. _#ZeroPhone on freenode: http://kiwiirc.com/client/irc.freenode.net/#ZeroPhone
+.. _issue on GitHub: https://github.com/ZeroPhone/ZPUI/issues/new
+.. _email the main developer: mailto:arsenijs@zerophone.org
diff --git a/zpui/docs/copy_enlarge_images.py b/zpui/docs/copy_enlarge_images.py
new file mode 100755
index 0000000..acc3be2
--- /dev/null
+++ b/zpui/docs/copy_enlarge_images.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python
+import os
+from PIL import Image
+
+current_size_assertion = (128, 64)
+desired_size = (256, 128)
+
+output_folder = '_static'
+
+images = [["../ui/tests/canvas_1.png", "canvas_test_1.png"],
+          ["../ui/tests/canvas_2.png", "canvas_test_2.png"],
+          ["../ui/tests/canvas_3.png", "canvas_test_3.png"],
+          ["../ui/tests/canvas_4.png", "canvas_test_4.png"],
+          ["../ui/tests/canvas_5.png", "canvas_test_5.png"],
+          ["../ui/tests/canvas_6.png", "canvas_test_6.png"],
+          ["../ui/tests/canvas_7.png", "canvas_test_7.png"],
+          ["../ui/tests/canvas_8.png", "canvas_test_8.png"]]
+
+for image_path, destination_filename in images:
+    image = Image.open(image_path)
+    assert(image.size == current_size_assertion)
+    new_image = image.resize(desired_size)
+    new_image.save(os.path.join(output_folder, destination_filename))
diff --git a/zpui/docs/debugging.rst b/zpui/docs/debugging.rst
new file mode 100644
index 0000000..2213e84
--- /dev/null
+++ b/zpui/docs/debugging.rst
@@ -0,0 +1,53 @@
+#########################
+Debugging issues
+#########################
+
+====================
+Debugging in general
+====================
+
+.. rubric:: Basic debugging steps:
+
+* Launch system manually and see the error messages. Go to the directory you installed ZPUI from and launch ``python main.py``. Alternatively, use ``journalctl -u zpui.service`` for a system that was running in daemon mode but crashed unexpectedly.
+* Check your connections.
+
+.. rubric:: Hardware/driver issues:
+
+* Check that the I2C/SPI/GPIO interfaces you're trying to use are available in ``/dev/``. You might need to run ``sudo raspi-config`` and enable the interfaces you need (for Raspberry Pi boards) or do other system-specific changes (for other boards, see the manuals the manufacturer should provide).
+* In case of I2C connection, check your I2C device connection with i2cdetect, you should see its address in i2cdetect's output when connected the right way.
+* Check your connections in case you assembled things manually. In case of shields, there shouldn't be any problems.
+
+
+=============
+Output issues
+=============
+
+.. rubric:: Basic debugging steps:
+
+* Launch the output driver manually to display the test sequence. Go to the directory you installed ZPUI from and launch the output driver directly like ``python output/drivers/your_driver.py``. You might need to adjust variables in ``if __name__ == "__main__":`` section.
+* Is the driver you're using even the correct one? See the config.json and documentation for the driver you're using. 
+
+----------
+
+
+Currently, ZPUI uses HD44780-compatible screens as output devices. Minimum screen size is 16x2. There are some known issues when using those. Again, you're not likely to run into hardware problems when using shields.
+
+.. rubric:: Screen displaying garbage
+
+* If using a breakout board, check if it's compatible with the driver. Some breakouts might use same ICs but have different pinouts, and any two pins interchanged can cause problems.
+* Try and tie D0-D3 lines to GND. Those lines floating freely may cause instabilities, though it doesn't happen often. 
+* You can try to tie the R/W line to GND, too. It's even necessary in some cases, like Pi GPIO driver. 
+* Put a ~100pF capacitor between GND and EN. If screen starts quickly filling up with blocks after some time, pull the EN line down with a 10K resistor.
+
+.. rubric:: Screen characters being shifted incorrectly
+
+* Try to set ``"autoscroll":True`` in ``config.json`` in output description (in ``kwargs`` section).
+
+.. rubric:: Only half of the screen is used
+
+* Make sure you didn't set ``"autoscroll":True`` in ``config.json`` in output description (in ``kwargs`` section).
+
+.. rubric:: Nothing on the screen
+
+* Is first row of blocks shown? If not, regulate the contrast with a potentiometer. You can also try to tie the contrast pin to GND.
+* Does screen receive 5V (not 3.3V) as VCC? Unless it's a screen that's capable of doing 3.3V (must be stated in screen's description), that's a no-go.
diff --git a/zpui/docs/docs_development.rst b/zpui/docs/docs_development.rst
new file mode 100644
index 0000000..198c008
--- /dev/null
+++ b/zpui/docs/docs_development.rst
@@ -0,0 +1,53 @@
+#############################
+Working on this documentation
+#############################
+
+If you want to help the project by working on documentation, this is the tutorial on how to start!
+
+==============
+Pre-requisites
+==============
+
+* Fork the `ZPUI repository`_ on GitHub
+* Create a separate branch for your documentation needs
+* Install the necessary Python packages for testing the documentation locally:
+
+    ``pip install sphinx sphinx-autobuild sphinx-rtd-theme``
+
+.. _ZPUI repository: https://github.com/ZeroPhone/ZPUI/
+
+======================
+Find a task to work on
+======================
+
+* Look into `ZPUI GitHub issues`_ and see if there are issues concerning documentation
+* Unleash your inner perfectionist
+* If you're not intimately familiar with reStructuredText markup, feel free to look through the existing documentation to see syntax and solutions that are already used.
+
+.. _ZPUI GitHub issues: https://github.com/ZeroPhone/ZPUI/issues
+
+============================
+Testing your changes locally
+============================
+
+You can build the documentation using ``make html`` from the ``docs/`` folder. Then,
+you can run ``./run_server.py`` to run a HTTP server on localhost, serving the
+documentation on port 8000. If you make changes to the documentation, just run
+``make html`` again to rebuild the documentation - webserver will serve the updated
+documentation once it finishes building.
+
+=========================
+Contributing your changes
+=========================
+
+Send us `a pull request`_!
+
+.. _a pull request: https://github.com/ZeroPhone/ZPUI/compare
+
+============
+Useful links
+============
+
+* `ReadTheDocs "Getting started" guide`_
+
+.. _ReadTheDocs "Getting started" guide: http://docs.readthedocs.io/en/latest/getting_started.html
diff --git a/zpui/docs/faq_contact.rst b/zpui/docs/faq_contact.rst
new file mode 100644
index 0000000..e644dae
--- /dev/null
+++ b/zpui/docs/faq_contact.rst
@@ -0,0 +1,91 @@
+############
+FAQ&contacts
+############
+
+Here are some answers to questions that arise. Don't forget to look through the "Future plans"!
+Got a question that isn't answered here? Try to look through `GitHub issues`_. If not found, create a new one!
+If you have another questions, `e-mail me`_ .
+
+.. _GitHub issues: https://github.com/ZeroPhone/ZPUI/issues
+.. _e-mail me: mailto:crimier@yandex.ru
+
+.. contents::
+    :local:
+    :depth: 2
+
+
+FAQ
+===
+
+.. _interfaces_supported:
+
+Does ZPUI support screen connected via 595/this particular Pi shield/some other input/output device I have?
+------------------------------------------------------------------------------------------------------------
+
+Short answer - it may not, but it's likely easy to add support for it. 
+
+First of all, look through the drivers supported. If you don't understand something, feel free to ask (GitHub issue/e-mail)! I'll be happy to help you, as well as update the docs.
+
+Second thing is - drivers for input/output devices are hella easy to implement. HD44780 screens use a common library, so that only the "sending actual commands/characters" to the character screen has to be implemented, and input devices just have to send "KEY_something" strings to ``InputListener`` when there's a keypress, optionally, do their best to shutdown cleanly (bane of the HID driver for now). You have a shield with a Python library available? Chances are, it's easy to write a driver for it by hooking it up to ZPUI driver structure - look at ``pfcad`` driver, that's exactly the approach used. Or look at the ``output/driver/pi_gpio`` driver, it's a nice example of leveraging the HD44780 abstraction. In short - you can do it yourself, and if you can't, then open an issue on GitHub and you can help develop and test the driver to whatever input device you have so that you can enjoy all the benefits of ZPUI.
+
+.. note:: Well, I have to admit things are still better not using some additional libraries, but they work, and that's the main thing. You need a driver, quick? Great, just take a look at current version of ``output/drivers/pfcad``, it's an example of both how to connect an external library and on various workarounds you might need to use. 
+
+
+.. _screens_supported:
+
+Does ZPUI support graphical/color OLEDs/TFTs, or other non-character non-HD44780 displays?
+-------------------------------------------------------------------------------------------
+
+Short answer - it yet doesn't, but I'm developing everything so that it will.
+
+There's a significant amount of work to be put into it. You need to make fonts for applications/UI elements relying on character output, facilitate display re-draws so that it's not painfully slow because it's redrawing the whole display every time, provide abstraction layers for fallback & other screen types, oh, and document it well enough so that it's usable. And yet, this is something to be included. 
+
+The reasons it's not included now is to be able to focus on applications that need to be developed, and because HD44780 screens are the most popular ones - excluding, maybe, the HDMI-, VGA- and RCA-connected ones, but they're partly the reason ZPUI is developed =) If you lack on-screen place, 20x4 screens are popular and cheap.
+
+
+.. _multiple_screens:
+
+Does ZPUI support multiple output devices, such as 2 or more screens?
+----------------------------------------------------------------------
+
+Short answer - it yet doesn't, but I'll be happy to work on it once there's a user for it and there's a use case.
+
+It's not hard to include this, but there are multiple ways to do it, and each one seems right. For now, many users say they'd just pass different screens to different applications, or use a separate screen for monitoring. This is possible, but would require close collaboration with end users of such a setup so that it's spot on for their applications and adjustable for others - in other words, not a dirty hack for the sake of adding a feature. So - contact me, we can work on it if you need it!
+
+Also, I'd like to remind about ``LCDproc`` project, which is all about displaying relatively static information, such as music player/CPU load info and similar things. It's a well-developed project and ZPUI is not yet claiming its place because they have different use cases, each has their own strengths and weaknesses. It's not hard to imagine using one screen for ZPUI and another - for LCDproc. That said, it's also not hard to use full ZPUI configuration on one screen and ZPUI in single-app mode in another ;-)
+
+
+.. _root_necessary:
+
+Does the system need to run as root?
+------------------------------------
+
+It does not *need* to, but it doesn't make much sense otherwise. ZPUI drivers&apps need all kinds of different privileges for various tasks, and it's run as a single application, so it either needs to be run as root or to be run as a user with enough privileges to do management tasks, which is not that far away from root in terms of danger.
+
+However, from some point there will be a split between ZPUI core and applications, where only core will need to run as a user privileged enough to access input/output devices, and applications will be able to run under separate users. 
+.. _openwrt_possible:
+
+Is it possible to run ZPUI under OpenWRT?
+------------------------------------------
+
+Yes, as OpenWRT is a Linux distribution. It doesn't even really need ``pip`` if you take care of all dependencies. However, it's not tested. Also, you're likely to need extroot because Python takes a lot of space.
+
+.. note:: UCI interface for now is lacking, but shouldn't be difficult to implement.
+
+
+.. _hid_grab:
+
+Why does it grab all the HID events from a device given to the HID driver?
+--------------------------------------------------------------------------
+
+Unfortunately, now there's no 'passthrough' driver that'd take only part of all the keypresses and pass all the other further. This driver is to appear soon.
+
+
+.. _x86_hardware:
+
+Which hardware can you use for running ZPUI on desktop computer/server/HTPC?
+-----------------------------------------------------------------------------
+
+* First of all, there are plans for making a firmware&driver for Arduino devices with commonly encountered button&16x2 LCD shields. The result will be connectable over USB as a USB-Serial device. 
+* Second thing is that most video cards have I2C lines on video ports accessible from Linux, and there's no problem with connecting I2C GPIO expanders to it, except that there's no GPIO to take advantage of button interrupt function.
+* Third thing is that you can easily use HID keyboards and numpads as input devices.
diff --git a/zpui/docs/hacking_ui.rst b/zpui/docs/hacking_ui.rst
new file mode 100644
index 0000000..bb55b50
--- /dev/null
+++ b/zpui/docs/hacking_ui.rst
@@ -0,0 +1,102 @@
+.. _hacking_ui:
+
+Hacking on UI
+#############
+
+If you want to change the way ZPUI looks and behaves for you, 
+make a better UI for your application by using more graphics or even
+design your own UI elements, these directions will help you on your way.
+
+Using the ZPUI emulator
+=======================
+
+ZPUI has an emulator that will allow you to test your applications, UI tweaks 
+and ZPUI logic changes, so that you don't have to have a ZeroPhone to develop 
+and test your UI.
+
+It will require a Linux computer with a graphical interface running (X forwarding 
+might work, too) and Python 2.7 available. :ref:`Here are the setup and usage instructions <emulator>`.
+
+Tweaking how the UI looks
+=========================
+
+ZPUI allows you to modify the way UI looks. The main way is tweaking UI element 
+"views" ( a view object defines the way an UI element is displayed ). So, you can 
+change the look of a certain UI element (say, main ZPUI menu), or a group of 
+elements (like, force a certain view for all checkboxes). You can also define your 
+own views, then apply them to UI elements using the same method. To know more about it,
+`read here`_.
+
+If your needs aren't covered by this, feel free to modify the ZPUI code - 
+it strives to be straightforward, and the parts that aren't are either 
+covered with comments and documentation, or will be covered upon request.
+If you need assistance, contact us on IRC or email!
+
+.. note:: If you decide to modify the ZPUI code, :doc:`here's a starting point <app_mgmt>`. Also, please `open an issue`_ on GitHub describing your changes - we can include it as a feature in the next versions of ZPUI!
+.. warning:: Modifying ZPUI code directly might result in merge conflicts if you will update using ``git pull``, or the built-in "Update ZPUI" app. Again, please do consider opening an issue on GitHub proposing your changes to be included in the mainline =)
+
+.. _read here: http://wiki.zerophone.org/index.php/Tweaking_ZeroPhone_UI
+.. _open an issue: https://github.com/ZeroPhone/ZPUI/issues/new
+
+Making and modifying UI elements
+================================
+
+If :doc:`existing UI elements <ui>` do not cover your usecase, you can also 
+make your own UI elements! :doc:`Contact us <contact>` to find out how, 
+or just use the `code for existing UI elements`_ as guidelines if you feel confident.
+
+Also, check if the UI element you want is mentioned `in ZPUI TODO`_ and `ZPUI GH issues`_- 
+there might already be progress on that front, or you might find some 
+useful guidelines.
+
+.. _code for existing UI elements: https://github.com/ZeroPhone/ZPUI/tree/master/ui
+.. _in ZPUI TODO: http://zpui.readthedocs.io/en/latest/plans.html
+.. _ZPUI GH issues: https://github.com/ZeroPhone/ZPUI/issues
+
+Testing the UI
+==============
+
+There are two ways to test UI elements:
+
+1. Running existing tests 
+-------------------------
+
+There's a small amount of tests, they're being added when bugs are found, 
+sometimes also when features are added. **From** ``ui/tests`` **folder**, 
+run existing tests like:
+
+    ``python -m unittest TEST_FILENAME`` *(without .py at the end)*
+
+For example, try:
+
+    ``python -m unittest test_checkbox``
+
+2. Running example applications
+-------------------------------
+
+There are `example applications`_ available for you to play with UI elements.
+You can run ZPUI in single-app mode to try out any UI element before using it:
+
+    ``python main.py -a apps/example_apps/checkbox_test``
+
+You can also, of course, use the code from example apps as a reference
+when developing your own applications.
+
+.. _example applications: https://github.com/ZeroPhone/ZPUI/tree/master/apps/example_apps
+
+Contributing your changes
+=========================
+
+Send us `a pull request`_! If your changes affect the UI element logic, please 
+try and make a test that checks whether it really works. If you're adding a new UI
+element, add docstrings to it - describing purpose, args and kwargs, as well as
+an example application to go with it.
+
+.. _a pull request: https://github.com/ZeroPhone/ZPUI/compare
+
+Useful links
+============
+
+* `Chat logs about ZPUI/ZeroPhone`_
+
+.. _Chat logs about ZPUI/ZeroPhone: http://wiki.zerophone.org/index.php/Chat_logs_about_ZeroPhone/ZPUI
diff --git a/zpui/docs/hardware.rst b/zpui/docs/hardware.rst
new file mode 100644
index 0000000..77c5578
--- /dev/null
+++ b/zpui/docs/hardware.rst
@@ -0,0 +1,36 @@
+##############
+Hardware guide
+##############
+
+.. rubric:: Absolute necessities:
+
+* A HD44780-compatible character display, from 16x2 to 20x4. They are cheap and available in most electronics shops in the world, as well as in most starter kits.
+* At least 5 simple pushbuttons (very cheap and salvageable from just about anything), or a USB keyboard/numpad.
+
+Some remarks:
+
+* There are Raspberry Pi shields which have a character LCDs and some buttons. They're good, too - as long as they're in the "supported" list.
+
+  Supported shields:
+    * PiFaceCAD Raspberry Pi shield
+    * Adafruit 16x2 Character LCD + Keypad for Raspberry Pi
+    * Chinese "LCD RGB KEYPAD ForRPI" shield (black PCB, pin-to-pin copy of aforementioned Adafruit shield)
+
+.. rubric :: Ways to connect your hardware:
+
+* Is it a shield ZPUI supports? Great, plug it on top of your Raspberry Pi and you're done!
+* If all you have is the character display and some buttons, you can:
+
+  * Connect them over GPIO (works for both screen and buttons) (only Raspberry Pi GPIO supported at the moment)
+  * Connect them over I2C using a PCF8574 expander (works for both screen and buttons, 1$ on eBay)
+
+* When assembling the hardware yourself, you can easily combine connection methods - for example, connect your LCD over I2C and buttons over GPIO, or use a shield for LCD and use a USB numpad.
+
+Afterwards, follow to the :doc:`ZPUI setup <setup>` part.
+
+Buying/choosing guide
+=====================
+
+* Want something cheap and minimum effort? Get a "LCD RGB KEYPAD ForRPI" shield. It's 6$, you can find it on eBay just by searching "Raspberry Pi LCD shield" and sorting the list by "Lowest price first". It'll take its time to arrive, but it's a great value for the price.
+* Want something quickly and minimum effort? Get a PiFaceCAD shield, or an Adafruit one. They're sold by distributors in UK/USA, and will arrive quickly. Moreover, they're nicely made.
+* Want something quickly and cheaply? You can assemble your own hardware from what you have. I2C expanders come in handy when you need to save pins, but connecting things through GPIO is a good alternative.
diff --git a/zpui/docs/helpers.rst b/zpui/docs/helpers.rst
new file mode 100644
index 0000000..d055d2b
--- /dev/null
+++ b/zpui/docs/helpers.rst
@@ -0,0 +1,131 @@
+.. _helpers:
+
+#######
+Helpers
+#######
+
+These are various objects and functions that help you with general-purpose 
+tasks while building your application - for example, config management, 
+running initialization tasks or exiting event loops on a keypress. 
+They can help you build the logic of your application quicker, and allow 
+to not repeat the code that was already written for other ZPUI apps.
+
+.. automodule:: helpers
+
+local_path_gen helper
+---------------------
+
+.. autofunction:: local_path_gen
+
+ExitHelper
+----------
+
+.. autoclass:: ExitHelper
+    :members: start,do_exit,do_run,stop,reset
+
+Usage:
+
+.. code-block:: python
+
+    from helpers import ExitHelper
+    ...
+    eh = ExitHelper(i)
+    eh.start()
+    while eh.do_run():
+        ... #do something until the user presses KEY_LEFT
+
+There is also a shortened usage form:
+
+.. code-block:: python
+
+    ...
+    eh = ExitHelper(i).start()
+    while eh.do_run():
+        ... #do your thing
+
+Oneshot helper
+--------------
+
+.. autoclass:: Oneshot
+    :members: run,running,finished, reset
+
+Usage:
+
+.. code-block:: python
+
+    from helpers import Oneshot
+    ...
+    def init_hardware():
+        #can only be run once
+
+    #since oneshot is only defined once, init_hardware function will only be run once,
+    #unless oneshot is reset.
+    oneshot = Oneshot(init_hardware)
+    
+    def callback():
+        oneshot.run() #something that you can't or don't want to init in init_app
+        ... #do whatever you want to do
+
+BackgroundRunner helper
+-----------------------
+
+.. autoclass:: BackgroundRunner
+    :members: run,running,finished,failed,reset,threaded_runner
+
+Usage:
+
+.. code-block:: python
+
+    from helpers import BackgroundRunner
+    ...
+    def init_hardware():
+        #takes a long time
+
+    init = BackgroundRunner(init_hardware)
+    
+    def init_app(i, o):
+        ...
+        init.run() #something too long that just has to run in the background,
+        #so that app is loaded quickly, but still can be initialized.
+
+    def callback():
+        if init.running: #still hasn't finished
+            PrettyPrinter("Still initializing...", i, o)
+            return
+        elif init.failed: #finished but threw an exception
+            PrettyPrinter("Hardware initialization failed!", i, o)
+            return
+        ... #everything initialized, can proceed safely
+        
+Combining BackgroundRunner and Oneshot
+--------------------------------------
+
+.. code-block:: python
+
+    from helpers import BackgroundRunner, Oneshot
+    ...
+    def init_hardware():
+        #takes a long time, *and* can only be run once
+
+    init = BackgroundRunner(Oneshot(init_hardware).run)
+    
+    def init_app(i, o):
+        #for some reason, you can't put the initialization here
+        #maybe that'll lock the device and you want to make sure 
+        #that other apps can use this until your app started to use it.
+
+    def callback():
+        init.run() 
+        #BackgroundRunner might have already ran
+        #but Oneshot inside won't run more than once
+        if init.running: #still hasn't finished
+            PrettyPrinter("Still initializing, please wait...", i, o)
+            eh = ExitHelper(i).start()
+            while eh.do_run() and init.running:
+                sleep(0.1)
+            if eh.do_exit(): return #User left impatiently before init has finished
+            #Even if the user has left, the hardware_init will continue running
+        elif init.failed: #finished but threw an exception
+            PrettyPrinter("Hardware initialization failed!", i, o)
+            return
+        ... #everything initialized, can proceed safely
diff --git a/zpui/docs/howto.rst b/zpui/docs/howto.rst
new file mode 100644
index 0000000..608ed2e
--- /dev/null
+++ b/zpui/docs/howto.rst
@@ -0,0 +1,707 @@
+.. _howto:
+
+How to...
+#########
+
+Do you want to improve your ZPUI app or solve your problem by copy-pasting
+a snippet in your app code? This page is for you =)
+
+.. contents::
+    :local:
+    :depth: 2
+
+Basics
+======
+
+What's the minimal ZPUI app?
+----------------------------
+
+In ``app/main.py``:
+
+.. code-block:: python
+
+    menu_name = "Skeleton app"
+    
+    i = None #Input device
+    o = None #Output device
+    
+    def init_app(input, output):
+        #Gets called when app is loaded
+        global i, o
+        i = input; o = output
+    
+    def callback():
+        #Gets called when app is selected from menu
+        pass
+
+``app/__init__.py`` has to be an empty file:
+
+.. code-block:: python
+
+
+------------
+
+What's the minimal class-based app?
+-----------------------------------
+
+In ``app/main.py``:
+
+.. code-block:: python
+
+    from apps import ZeroApp
+
+    class YourGreatApp(ZeroApp):
+        menu_name = "Skeleton app"
+
+        def on_start():
+            #Gets called when app is selected from menu
+            pass
+
+``app/__init__.py`` has to be an empty file, as with the previous example.
+     
+------------
+
+Experiment with ZPUI code
+=========================
+
+You can use the sandbox app to try out ZPUI code. First, stop the system-wide ZPUI
+process if it's running (use ``sudo systemctl stop zpui``). Then, run this in the
+install folder:
+
+.. code-block:: bash
+
+    sudo python main.py -a apps/example_apps/sandbox
+
+.. code-block:: python
+
+    [...]
+    Python 2.7.13 (default, Nov 24 2017, 17:33:09)
+    [GCC 6.3.0 20170516] on linux2
+    Type "help", "copyright", "credits" or "license" for more information.
+    (InteractiveConsole)
+    >>>
+
+Available variables:
+
+.. code-block:: python
+
+    >>> dir()
+    ['__builtins__', '__code__', '__doc__', '__file__', '__name__', '__package__',
+    'callback', 'context', 'i', 'init_app', 'menu_name', 'o', 'set_context']
+
+In short, you get ``i``, ``o``, a ``context`` object, and you can import all the
+usual things you'd import in your app - like UI elements
+
+.. code-block:: python
+
+    >>> from ui import Canvas
+    >>> c = Canvas(o, interactive=True)
+    >>> c.centered_text("Hello world!")
+
+.. image:: _static/canvas_test_7.png
+
+------------
+
+User-friendliness
+=================
+
+Whether your app involves a complex task, a task that could be done in multiple
+different ways or just something plain and simple, there are UI elements, functions
+and snippets that can help you make your app more accessible to the user.
+
+Confirm a choice
+----------------
+
+In case you're unsure the user will want to proceed with what you're doing,
+you might want them to confirm their actions. Here's how to ask them that:
+
+.. code-block:: python
+
+    from ui import DialogBox
+
+    message = "Are you sure?"
+    choice = DialogBox ('ync', i, o, message=message, name="HDD secure erase app erase confirmation").activate()
+    if choice:
+        erase_hdd(device_path)
+
+By default, Yes returns ``True``, No returns ``False`` and Cancel returns ``None``.
+
+Pick one thing out of many
+--------------------------
+
+If you have multiple things and you need your user to pick one, here's how to
+let them choose:
+
+.. code-block:: python
+
+    from ui import Listbox, PrettyPrinter
+    ...
+    # You pass lists of two elements - first one is the user-friendly label,
+    # second is something that your code can actually use
+    # (doesn't have to be a string)
+    lc = [["Kingston D4", "/dev/bus/usb/001/002"], ["Sandisk Ultra M3", "/dev/bus/usb/001/002"]]
+    # The user will want to know what is it you want them to choose;
+    # Showing a quick text message is a good way to do it
+    PrettyPrinter("More than one drive found, pick a flash drive", i, o, 5)
+    path = Listbox(lc, i, o, name="USB controller flashing app drive selection menu").activate()
+    if path: # if the user pressed left key to cancel the choice, None is returned
+        print(path)
+
+.. note:: If you autogenerate the listbox contents from an external source (for
+          example, your user needs to pick one flash drive from a list of all
+          connected flash drives), it's best if you check that the user really
+          has any choice in the matter - as in, maybe there's only one flash drive
+          connected?
+
+-----------
+
+Enable/disable options
+----------------------
+
+If you want user to be able to enable or disable settings or let them filter
+through a really long list of options to choose from, here's what you can do:
+
+.. code-block:: python
+
+    from ui import Checkbox
+    ...
+    # You pass lists of two/three elements - first one is the user-friendly label
+    # second is something that you'll receive as a response dictionary key,
+    # and you can optionally add the third element telling the default state
+    # (True/False)
+    # (doesn't have to be a string)
+    cc = [["Replace files that were changed", "replace_on_change", config["replace_on_change"]],
+          ["Delete files from destination", "delete_in_destination", config["delete_in_destination"]],
+          ["Save these settings", "save_settings"]]
+    choices = Checkbox(cc, i, o, name="Backup app options dialog").activate()
+    if choices: # if the user pressed left key to cancel the choice, None is returned
+        print(choices)
+    # {"replace_on_change":True, "delete_in_destination":False, "save_settings":False}
+
+Pick a file/directory
+---------------------
+
+In case your user needs to work with files, here's how you can make the file picking
+process easy for them:
+
+.. code-block:: python
+
+    from ui import PathPicker
+    ...
+    # You might already have some kind of path handy - maybe the one that your user
+    # picked last time?
+    path = os.path.split(last_path)[0] if last_path else '/'
+    new_path = PathPicker(path, self.i, self.o, name="Shred app file picker").activate()
+    if new_path: # As usual, the user can cancel the selection
+        self.last_path = new_path # Saving it for usability
+
+The ``PathPicker`` also supports a ``callback`` attribute which, instead of
+letting the user pick one file and returning it, lets the user just click on
+files and calls a function on each one of them as they're selected. An example
+of this working is the "File browser" app in "Utils" category of the main menu.
+
+Allow exiting a loop on a keypress
+-----------------------------------
+
+Say, you have a loop that doesn't have an UI element in it - you're just doing something
+repeatedly. You'll want to let the user exit that loop, and the reasonable way is to
+interrupt the loop when the user presses a key (by default, ``KEY_LEFT``).
+Here's how to allow that:
+
+.. code-block:: python
+
+    from helpers import ExitHelper
+    ...
+    eh = ExitHelper(i).start()
+    while eh.do_run():
+        ... #do something repeatedly until the user presses KEY_LEFT
+
+Stopping a foreground task on a keypress
+----------------------------------------
+
+If you have some kind of task that's running in foreground (say, a HTTP server), you will
+want to let the user exit the UI, at least - maybe even stop the task. If a task can be
+stopped from another thread, you can use ``ExitHelper``, too - it can call a custom function
+that would signal the task to stop.
+
+.. code-block:: python
+
+    from helpers import ExitHelper
+    ...
+    task = ... # Can be run in foreground with ``task.run()``
+    # Can also be stopped from another thread with ``task.stop()``
+    eh = ExitHelper(i, cb=task.stop).start()
+    task.run() # Will run until the task is not stopped
+
+Draw on the screen
+==================
+
+Display an image
+----------------
+
+You can easily draw an image on the screen with ZPUI. The easiest way is
+by using the ``display_image`` method of ``OutputProxy`` object:
+
+.. code-block:: python
+
+    o.display_image(image) #A PIL.Image object
+
+However, you might want a user-friendly wrapper around it that would allow
+you to easily load images by filename, invert, add a delay/exit-on-key etc.
+In this case, you'll want to use the ``GraphicsPrinter`` UI element, which
+accepts either a path to an image you want to display, or a ``PIL.Image``
+instance and supports some additional arguments:
+
+.. code-block:: python
+
+    from ui import GraphicsPrinter
+    ...
+    # Will display the ZPUI splash image for 1 second
+    # By default, it's inverted
+    GraphicsPrinter("splash.png", i, o, 1)
+    # Same, but the image is not inverted
+    GraphicsPrinter("splash.png", i, o, 1, invert=False)
+    # Display an image from the app folder - using the local_path helper
+    GraphicsPrinter(local_path("image.png"), i, o, 1)
+    # Display an image you drew on a Canvas
+    GraphicsPrinter(c.get_image(), i, o, 1)
+
+In case you have a Canvas object and you just want to display it, there's
+a shorthand:
+
+.. code-block:: python
+
+    c.display()
+
+------------
+
+Draw things on the screen - basics
+----------------------------------
+
+Uou can use the Canvas objects to draw on the screen.
+
+.. code-block:: python
+
+    from ui import Canvas
+    ...
+    c = Canvas(o) # Create a canvas
+    c.point((1, 2)) # Draw a point at x=1, y=2
+    c.point( ( (2, 1), (2, 3), (3, 4) ) ) # Draw some more points
+    ... # Draw other stuff here
+    c.display() # Display the canvas on the screen
+
+.. image:: _static/canvas_test_1.png
+
+------------
+
+Draw text
+---------
+
+You can draw text on the screen, and you can use different fonts. By default, a 8pt font
+is used:
+
+.. code-block:: python
+
+    c = Canvas(o)
+    c.text("Hello world", (0, 0)) # Draws "Hello world", starting from the top left corner
+    c.display()
+
+.. image:: _static/canvas_test_2.png
+
+You can also use a non-default font - for example, the Fixedsys62 font in
+the ZPUI font storage:
+
+.. code-block:: python
+
+    c.text("Hello world", (0, 0), font=("Fixedsys62.ttf", 16)) # Same, but in a 16pt Fixedsys62 font
+    c.text("Hello world", (0, 0), font=(local_path("my_font.ttf"), 16) ) # Using a custom font from your app directory
+
+------------
+
+Draw centered text
+------------------
+
+You can draw centered text, too!
+
+.. code-block:: python
+
+    c = Canvas(o)
+    c.centered_text("Hello world") # Draws "Hello world" in the center of the screen
+    c.display()
+
+.. image:: _static/canvas_test_7.png
+
+You can also draw text that's centered on one of the dimensions:
+
+.. code-block:: python
+
+    c = Canvas(o)
+    ctc = c.get_centered_text_bounds("a") # Centered Text Coords
+    # ctc == Rect(left=61, top=27, right=67, bottom=37)
+    c.text("a", (ctc.left, 0)) 
+    c.text("b", (str(ctc.left-ctc.right), ctc.top)) # ('-6', 27)
+    c.text("c", (ctc.left, str(ctc.top-ctc.bottom))) # (61, '-10')
+    c.text("d", (0, ctc.top))
+    c.display()
+
+.. image:: _static/canvas_test_8.png
+
+------------
+
+Draw a line
+-----------
+
+.. code-block:: python
+
+    c = Canvas(o)
+    c.line((10, 4, "-8", "-4")) # Draws a line from top left to bottom right corner
+    c.display()
+
+.. image:: _static/canvas_test_3.png
+
+------------
+
+Draw a rectangle
+----------------
+
+.. code-block:: python
+
+    c = Canvas(o)
+    c.rectangle((10, 4, 20, "-10")) # Draws a rectangle in the left of the screen
+    c.display()
+
+.. image:: _static/canvas_test_4.png
+
+------------
+
+Draw a circle
+-------------
+
+.. code-block:: python
+
+    c = Canvas(o)
+    c.circle(("-8", 8, 4)) # Draws a circle in the top left corner - with radius 4
+    c.display()
+
+.. image:: _static/canvas_test_5.png
+
+.. note:: There's also a ``Canvas.ellipse()`` method, which takes four coordinates
+          instead of two + radius.
+
+------------
+
+Invert a region of the screen
+-----------------------------
+
+If you want to highlight a region of the screen, you might want to invert it:
+
+.. code-block:: python
+
+    c = Canvas(o)
+    c.text("Hello world", (5, 5))
+    c.invert_rect((35, 5, 80, 17)) # Inverts, roughly, the right half of the text
+    c.display()
+
+.. image:: _static/canvas_test_6.png
+
+.. note:: To invert the whole screen, you can use the ``invert`` method.
+
+------------
+
+Make your app easier to support
+===============================
+
+Add logging to your app
+-----------------------
+
+In case your application does something more complicated than printing a sentence
+on the display and exiting, you might need to add logging - so that users can then
+look through the ZPUI history, figure out what was it that went wrong, and maybe
+submit a bugreport to you!
+
+.. code-block:: python
+
+    from helpers import setup_logger # Importing the needed function
+    logger = setup_logger(__name__, "warning") # Getting a logger for your app, 
+    # default level is "warning" - this level controls logging statements that
+    # will be displayed (and saved in the logfile) by default.
+    
+    ...
+    
+    try:
+        command = "my_awesome_script"
+        logger.info("Calling the '{}' command".format(command))
+        output = call(command)
+        logger.debug("Finished executing the command")
+        for value in output.split():
+            if value not in expected_values:
+                logger.warning("Unexpected value {} found when parsing command output; proceeding".format(value))
+    except:
+        logger.exception("Exception while calling the command!")
+        # .exception will also log the details of the exception after your message
+
+Add names to your UI elements
+=============================
+
+UI elements aren't perfect - sometimes, they themselves cause exceptions. In this case,
+we'll want to be able to debug them, to make sure we understand what was it that went
+wrong. Due to the nature of ZPUI and how multiple apps run in parallel, we need to be
+able to distinguish logs from different UI elements - so, each UI element has a ``name``
+attribute, and it's included in log messages for each UI element. By default, the
+attribute is set to something non-descriptive - we highly suggest you set it
+to tell:
+
+* which app the UI element belongs to
+* which part of the app the UI element is created
+
+For example:
+
+.. code-block:: python
+
+    from ui import Menu
+    ...
+    Menu(contents, i, o, name="Main menu of Frobulator app".activate()
+
+.. note:: The only UI elements that don't support the ``name`` attribute are Printers:
+          ``Printer``, ``GraphicsPrinter`` and ``PrettyPrinter``
+
+Config (and other) files
+========================
+
+Read JSON from a config file located in the app directory
+---------------------------------------------------------
+
+.. code-block:: python
+
+    from helpers import read_config, local_path_gen
+    config_filename = "config.json"
+    
+    local_path = local_path_gen(__name__)
+    config = read_config(local_path(config_filename))
+
+------------
+
+Read a config file with an easy "save" function and "restore to defaults on error" check
+----------------------------------------------------------------------------------------
+
+.. code-block:: python
+
+    from helpers import read_or_create_config, local_path_gen, save_config_gen
+    default_config = '{"your":"default", "config":"to_use"}' #has to be a string
+    config_filename = "config.json"
+    
+    local_path = local_path_gen(__name__)
+    config = read_or_create_config(local_path(config_filename), default_config, menu_name+" app")
+    save_config = save_config_gen(local_path(config_filename))
+
+To save the config, use ``save_config(config)`` from anywhere in your app.
+
+.. note:: The faulty ``config.json`` file will be copied into a ``config.json.faulty`` 
+          file before being overwritten
+
+.. warning:: If you're reassigning contents of the ``config`` variable from inside a
+             function, you will likely want to use Python ``global`` keyword in order
+             to make sure your reassignment will actually work.
+
+------------
+
+"Read", "save" and "restore" - in a class-based app
+---------------------------------------------------
+
+.. code-block:: python
+
+    from helpers import read_or_create_config, local_path_gen, save_config_method_gen
+    local_path = local_path_gen(__name__)
+
+    class YourApp(ZeroApp):
+
+        menu_name = "My greatest app"
+        default_config = '{"your":"default", "config":"to_use"}' #has to be a string
+        config_filename = "config.json"
+        
+        def __init__(self, *args, **kwargs):
+            ZeroApp.__init__(self, *args, **kwargs)
+            self.config = read_or_create_config(local_path(self.config_filename), self.default_config, self.menu_name+" app")
+            self.save_config = save_config_method_gen(local_path(self.config_filename))
+
+To save the config, use ``self.save_config()`` from anywhere in your app class.
+
+------------
+
+Get path to a file in the app directory
+---------------------------------------
+
+Say, you have a ``my_song.mp3`` file shipped with your app. However, in order to use
+that file from your code, you have to refer to that file using a path relative to the
+ZPUI root directory, such as ``apps/personal/my_app/my_song.mp3``.
+
+Here's how to get that path automatically, without hardcoding which folder your app is put in:
+
+.. code-block:: python
+
+    from helpers import local_path_gen
+    local_path = local_path_gen(__name__)
+    mp3_file_path = local_path("my_song.mp3")
+
+In case of your app having nested folders, you can also give multiple arguments to
+``local_path()``:
+
+.. code-block:: python
+
+    song_folder = "songs/"
+    mp3_file_path = local_path(song_folder, "my_song.mp3")
+
+------------
+
+Run tasks on app startup
+=====================================
+
+How to do things on app startup in a class-based app?
+-----------------------------------------------------
+
+.. code-block:: python
+
+    def __init__(self, *args, **kwargs):
+        ZeroApp.__init__(self, *args, **kwargs)
+        # do your thing
+     
+------------
+
+Run a short task only once when your app is called
+--------------------------------------------------
+
+This is suitable for short tasks that you only call once, and that won't conflict
+with other apps.
+
+.. code-block:: python
+
+    def init_app(i, o):
+        ...
+        init_hardware() #Your task - short enough to run while app is being loaded
+
+.. warning:: If there's a chance that the task will take a long time, use one
+             of the following methods instead.
+
+------------
+
+Run a task only once, first time when the app is called
+-------------------------------------------------------
+
+This is suitable for tasks that you can only call once, and you'd only need to
+call once the user activates the app (maybe grabbing some resource that could
+conflict with other apps, such as setting up GPIO or other interfaces).
+
+.. code-block:: python
+
+    from helpers import Oneshot
+    ...
+    def init_hardware():
+        #can only be run once
+
+    #since oneshot is only defined once, init_hardware function will only be run once,
+    #unless oneshot is reset.
+    oneshot = Oneshot(init_hardware)
+    
+    def callback():
+        oneshot.run() #something that you can't or don't want to init in init_app
+        ... #do whatever you want to do
+
+Run a task in background after the app was loaded
+-------------------------------------------------
+
+This is suitable for tasks that take a long time. You wouldn't want to execute that task
+directly in ``init_app()``, since it'd stall loading of all ZPUI apps, not allowing the user
+to use ZPUI until your app has finished loading (which is pretty inconvenient for the user).
+
+.. code-block:: python
+
+    from helpers import BackgroundRunner
+    ...
+    def init_hardware():
+        #takes a long time
+
+    init = BackgroundRunner(init_hardware)
+    
+    def init_app(i, o):
+        ...
+        init.run() #something too long that just has to run in the background,
+        #so that app is loaded quickly, but still can be initialized.
+
+    def callback():
+        if init.running: #still hasn't finished
+            PrettyPrinter("Still initializing...", i, o)
+            return
+        elif init.failed: #finished but threw an exception
+            PrettyPrinter("Hardware initialization failed!", i, o)
+            return
+        ... #everything initialized, can proceed safely
+
+Context management
+==================
+
+Contexts are the core concept of ZPUI multitasking. They allow you to switch between apps
+dynamically, use notifications, global hotkeys etc. One common usage of contexts would be
+creating menus that appear on a button press.
+
+Get the context object
+----------------------
+
+In order to interact with your app's context object, you first need to get it. If your
+app is a simple one (function-based), you need to add a ``set_context()`` method that
+needs to accept a context object as its first argument. This function will be called
+after ``init_app`` is called. In case of a class-based app, you need to have a
+``set_context()`` method in the app's class. Once you get the context object, you
+can do whatever you want with it and, optionally, save it internally. Here's an example
+for the function-based apps:
+
+.. code-block:: python
+
+    def set_context(received_context):
+        global context
+        context = received_context
+        # Do things with the context
+
+Here's an example for the class-based apps:
+
+.. code-block:: python
+
+    def set_context(self, received_context):
+        self.context = received_context
+        # Do things with the context
+
+Check and request focus for your app
+------------------------------------
+
+User can switch from your app at any time, leaving it in the background. You won't receive
+any key input in the meantime - the screen interactions will work as intended regardless 
+of whether your app is the one active, but the actual screen won't be updated with your 
+images until the user switches back to your app. Here's how to check whether your app
+is the one active, and request the context manager to switch to your app:
+
+.. code-block:: python
+
+    if not context.is_active():
+        has_switched = context.request.switch()
+        if has_switched:
+            ... # Request to switch has been granted, your app is now the one active
+
+.. warning:: Don't overuse this capability - only use it when it's absolutely necessary, otherwise
+             the user will be annoyed. Also, keep in mind that your request might be denied.
+
+Set a global key callback for your app
+--------------------------------------
+
+You can define a hotkey for your app to request focus - or do something else. This way,
+you can have a function from your app be called when a certain key is pressed from any
+place in the interface.
+
+.. code-block:: python
+
+    # Call a function from your app without switching to it
+    context.request_global_keymap({"KEY_F6":function_you_want_to_call})
+    # Request switch to your app
+    context.request_global_keymap({"KEY_F6":self.context.request_switch})
+
+The ``request_global_keymap`` call returns a dictionary with a keyname as a key for each
+requested callback, with ``True`` as the value if the key was set or, if an exception was
+raised while setting the , an exception object.
diff --git a/zpui/docs/index.rst b/zpui/docs/index.rst
new file mode 100644
index 0000000..0404341
--- /dev/null
+++ b/zpui/docs/index.rst
@@ -0,0 +1,50 @@
+Welcome to ZPUI documentation!
+=================================
+
+ZPUI stands for ZeroPhone UI, it's the official user interface for ZeroPhone (installed on ZeroPhone official SD card images). It allows you to interact with your ZeroPhone, using the 1.3" OLED and the 30-button numpad.
+
+ZPUI is based on pyLCI, a general-purpose UI for embedded devices. However, unlike pyLCI, 
+ZPUI is tailored for the ZeroPhone hardware, namely, the 1.3" monochrome OLED 
+and 30-key numpad (though it still retains input&output drivers from pyLCI), and 
+it also ships with ZeroPhone-specific applications.
+
+Guides:
+=======
+
+* :doc:`Installing and updating ZPUI <setup>`
+* :ref:`Installing ZPUI emulator <emulator>`
+* :doc:`App development - how to ... ? <howto>`
+* :doc:`ZPUI configuration files <config>`
+* :doc:`Hacking on UI <hacking_ui>`
+* :doc:`Logging configuration <logging>`
+
+References:
+===========
+
+* :doc:`UI elements <ui>`
+* :doc:`Helper functions <helpers>`
+* :doc:`Input system <input>`
+* :doc:`Output system <output>`
+
+
+:doc:`Development plans <plans>`
+
+:doc:`Contact us <contact>`
+
+:doc:`Working on documentation <docs_development>`
+
+
+.. toctree::
+   :maxdepth: 1
+   :hidden:
+
+   setup.rst
+   config.rst
+   howto.rst
+   ui.rst
+   helpers.rst
+   hacking_ui.rst
+   logging.rst
+   app_mgmt.rst
+   docs_development.rst
+   contact.rst
diff --git a/zpui/docs/input.rst b/zpui/docs/input.rst
new file mode 100644
index 0000000..aba215e
--- /dev/null
+++ b/zpui/docs/input.rst
@@ -0,0 +1,52 @@
+###############
+Input subsystem
+###############
+
+These are the devices that receive key commands from some external source and route them to your applications. 
+At the input system core, there's ``InputListener``. It receives key events from drivers you use and routes them to currently active application.
+
+Available input drivers:
+
+   * :ref:`input_hid`
+   * :ref:`input_pcf8574`
+   * :ref:`input_pifacecad`
+   * :ref:`input_adafruit`
+   * :ref:`input_pi_gpio`
+
+==========
+InputProxy
+==========
+
+The ``i`` variable you have supplied by ``main.py`` ``load_app()`` in your applications is an ``InputProxy`` instance. It's operating on key names, such as "KEY_ENTER" or "KEY_UP". You can assign callback once a keypress with a matching keyname is received, which is as simple as ``i.set_callback(key_name, callback)``.
+You can also set a dictionary of ``"keyname":callback_function`` mappings, this would be called a **keymap**.
+
+
+.. automodule:: input.input
+ 
+.. autoclass:: InputProxy
+    :members:
+    :special-members:
+
+Sample usage - it should rarely be necessary for you to set callbacks directly, as this
+is mostly taken care of by the UI elements.
+
+.. code-block:: python
+   
+   i.stop_listen()
+   i.clear_keymap() #Useful because there might be callbacks left from whatever your function was called by
+   #... Set your callbacks
+   i.set_callback("KEY_ENTER", my_function)
+   i.listen()
+
+========
+Drivers:
+========
+
+.. toctree::
+   :maxdepth: 2
+
+   input/hid.rst
+   input/pcf8574.rst
+   input/pifacecad.rst
+   input/adafruit.rst
+   input/pi_gpio.rst
diff --git a/zpui/docs/input/adafruit.rst b/zpui/docs/input/adafruit.rst
new file mode 100644
index 0000000..2d96f1e
--- /dev/null
+++ b/zpui/docs/input/adafruit.rst
@@ -0,0 +1,28 @@
+.. _input_adafruit:
+
+###################################################################
+Adafruit CharLCD Plate&Chinese "LCD RGB KEYPAD" shield input driver
+###################################################################
+
+This driver works with Adafruit Raspberry Pi character LCD&button shields, as well as with Chinese clones following the schematic (can be bought for 5$ on eBay, typically have "LCD RGB KEYPAD ForRPi" written on them).
+
+Sample ``config.json`` section:
+
+.. code:: json
+
+    "input":
+       [{
+         "driver":"adafruit_plate"
+       }]
+
+
+.. note:: Generally, you won't need to edit ``config.json`` if you're using this shield because it'll be done automatically by ``config.sh``.
+
+
+.. toctree::
+
+.. automodule:: input.drivers.adafruit_plate
+ 
+.. autoclass:: InputDevice
+    :members:
+    :special-members:
diff --git a/zpui/docs/input/hid.rst b/zpui/docs/input/hid.rst
new file mode 100644
index 0000000..05da73d
--- /dev/null
+++ b/zpui/docs/input/hid.rst
@@ -0,0 +1,29 @@
+.. _input_hid:
+
+#####################
+HID input driver
+#####################
+
+Sample config.json:
+
+.. code:: json
+
+    "input":                
+       [{                   
+         "driver":"hid",
+         "kwargs":          
+          {                 
+           "name":"HID 04d9:1603"
+          }                 
+       }]                  
+
+
+To get device names, you can just run ``python input/driver/hid.py`` while your device is connected. It will output available device names.
+
+.. toctree::
+
+.. automodule:: input.drivers.hid
+ 
+.. autoclass:: InputDevice
+    :members:
+    :special-members:
diff --git a/zpui/docs/input/pcf8574.rst b/zpui/docs/input/pcf8574.rst
new file mode 100644
index 0000000..2ec2e16
--- /dev/null
+++ b/zpui/docs/input/pcf8574.rst
@@ -0,0 +1,28 @@
+.. _input_pcf8574:
+
+#####################
+PCF8574 input driver
+#####################
+
+It works with PCF8574 IO expanders. You can see an guide on modifying them and connecting them to buttons & I2C `here. <http://www.instructables.com/id/Raspberry-Pi-Using-1-I2C-LCD-Backpacks-for-1602-Sc/>`__
+
+.. code:: json
+
+    "input":
+       [{
+         "driver":"pcf8574",
+         "kwargs":
+          {
+           "addr":63,
+           "int_pin":4
+          }
+       }]
+
+
+.. toctree::
+
+.. automodule:: input.drivers.pcf8574
+ 
+.. autoclass:: InputDevice
+    :members:
+    :special-members:
diff --git a/zpui/docs/input/pi_gpio.rst b/zpui/docs/input/pi_gpio.rst
new file mode 100644
index 0000000..535a566
--- /dev/null
+++ b/zpui/docs/input/pi_gpio.rst
@@ -0,0 +1,27 @@
+.. _input_pi_gpio:
+
+##############################
+Raspberry Pi GPIO input driver
+##############################
+
+Driver for buttons connected to GPIO. Up to 8 button are supported now.
+Sample config.json:
+
+.. code:: json
+
+    "input":
+       [{
+         "driver":"pi_gpio",
+         "kwargs":
+          {
+           "button_pins":[25, 24, 23, 18, 22, 27, 17, 4]
+          }
+       }]
+
+.. toctree::
+
+.. automodule:: input.drivers.pi_gpio
+ 
+.. autoclass:: InputDevice
+    :members:
+    :special-members:
diff --git a/zpui/docs/input/pifacecad.rst b/zpui/docs/input/pifacecad.rst
new file mode 100644
index 0000000..b9b00f0
--- /dev/null
+++ b/zpui/docs/input/pifacecad.rst
@@ -0,0 +1,27 @@
+.. _input_pifacecad:
+
+######################
+PiFaceCAD input driver
+######################
+
+This driver works with `PiFace Control and Display <www.piface.org.uk/products/piface_control_and_display/>`_ Raspberry Pi shields. 
+
+Sample config.json section:
+
+.. code:: json
+
+    "input":
+       [{
+         "driver":"pfcad"
+       }]
+
+
+.. note:: Generally, you won't need to edit ``config.json`` if you're using this shield because it'll be done automatically by ``config.sh``.
+
+.. toctree::
+
+.. automodule:: input.drivers.pfcad
+ 
+.. autoclass:: InputDevice
+    :members:
+    :special-members:
diff --git a/zpui/docs/logging.rst b/zpui/docs/logging.rst
new file mode 100644
index 0000000..6a2c29f
--- /dev/null
+++ b/zpui/docs/logging.rst
@@ -0,0 +1,26 @@
+.. _logging_config:
+
+Logging configuration
+#####################
+
+Changing log levels
+===================
+
+In case of problems with ZPUI, logs can help you understand it - especially when
+the problem is not easily repeatable. To enable verbose logging for a particular
+system/app/driver, go to ``"Settings"->"Logging settings"`` menu, then click on
+the part of ZPUI that you're interested in and pick "Debug". From now on, that part
+of ZPUI will log a lot more in ``zpui.log`` files - which you can then read through,
+or send to the developers.
+
+Alternatively, you can change the log_conf.ini file directly. In it, add a new
+section for the app you want to learn, like this:
+
+.. code-block:: ini
+
+    [path.to.code.file]
+    level = debug
+
+``path.to.code.file`` would be the Python-style path to the module you want to debug,
+for example, ``input.input``, ``context_manager`` or ``apps.network_apps.wpa_cli``.
+
diff --git a/zpui/docs/output.rst b/zpui/docs/output.rst
new file mode 100644
index 0000000..df2f19d
--- /dev/null
+++ b/zpui/docs/output.rst
@@ -0,0 +1,43 @@
+################
+Output subsystem
+################
+
+Currently ZPUI uses HD44780-compatible screens as output devices. Minimum screen size is 16x2, 20x4 screens are tested and working.
+Available output drivers:
+
+   * :ref:`output_pcf8574`
+   * :ref:`output_pifacecad`
+   * :ref:`output_adafruit`
+   * :ref:`output_pi_gpio`
+   * :ref:`output_mcp23008`
+
+=============
+Screen object
+=============
+
+The ``o`` variable you have supplied by ``main.py`` ``load_app()`` in your applications is a ``Screen`` instance. It provides you with a set of functions available to HD44780 displays.
+Most of drivers just provide low-level functions for ``HD44780`` object, which, in turn, provides ``Screen`` object users with high-level functions described below:
+
+.. automodule:: output.drivers.hd44780
+.. autoclass:: HD44780
+    :members:
+    :special-members:
+
+.. rubric:: Glue logic functions
+
+.. warning:: Not for user interaction, are called by ``main.py``, which is ZPUI launcher.
+
+.. autofunction:: output.output.init
+
+========
+Drivers:
+========
+
+.. toctree::
+   :maxdepth: 2
+
+   output/mcp23008.rst
+   output/pcf8574.rst
+   output/pifacecad.rst
+   output/adafruit.rst
+   output/pi_gpio.rst
diff --git a/zpui/docs/output/adafruit.rst b/zpui/docs/output/adafruit.rst
new file mode 100644
index 0000000..d594948
--- /dev/null
+++ b/zpui/docs/output/adafruit.rst
@@ -0,0 +1,43 @@
+.. _output_adafruit:
+
+####################################################################
+Adafruit CharLCD Plate&Chinese "LCD RGB KEYPAD" shield output driver
+####################################################################
+
+This driver works with Adafruit Raspberry Pi character LCD&button shields, as well as with Chinese clones following the schematic (can be bought for 5$ on eBay, typically have "LCD RGB KEYPAD ForRPi" written on them).
+
+If you have a genuine Adafruit board, pass ``"chinese":false`` keyword argument to the driver in config.json so that the backlight works right.
+
+Sample ``config.json`` section for Adafruit board:
+
+.. code:: json
+
+    "output":
+       [{
+         "driver":"adafruit_plate",
+         "kwargs":
+         {
+          "chinese":false
+         }
+       }]
+
+
+Sample ``config.json`` section for Chinese clone:
+
+.. code:: json
+
+    "output":
+       [{
+         "driver":"adafruit_plate"
+       }]
+
+
+.. note:: Generally, you won't need to edit ``config.json`` if you're using this shield because it'll be done automatically by ``config.sh``.
+
+.. toctree::
+
+.. automodule:: output.drivers.adafruit_plate
+ 
+.. autoclass:: Screen
+    :members:
+    :special-members:
diff --git a/zpui/docs/output/mcp23008.rst b/zpui/docs/output/mcp23008.rst
new file mode 100644
index 0000000..e31b565
--- /dev/null
+++ b/zpui/docs/output/mcp23008.rst
@@ -0,0 +1,33 @@
+.. _output_mcp23008:
+
+################################
+MCP23008 I2C LCD backpack driver
+################################
+
+This driver was written for wide.hk I2C LCD backpacks `(picture). <http://www.wide.hk/img/_MG_4713.JPG>`_ 
+They are very small and slim and don't have any means to configure their I2C address. 
+
+If you have another backpack and the driver doesn't work with this one, please open an issue on GitHub with a link to the backpack and its drivers for Arduino/Raspberry Pi
+
+Sample config.json:
+
+.. code:: json
+
+    "input":                
+       [{                   
+         "driver":"mcp23008",
+         "kwargs":          
+          {                 
+           "addr":"0x3f"
+          }                 
+       }]                  
+
+.. note:: If you provide backpack's I2C address as a kwarg, you should pass it as a string (as shown above).
+
+To test your screen, you can just run ``python output/driver/mcp23008.py`` while your screen is connected to I2C bus (you might want to adjust parameters in driver's ``if __name__ == "__main__"`` section). It will initialize the screen and show some text on it.
+
+.. automodule:: output.drivers.mcp23008
+ 
+.. autoclass:: Screen
+    :members:
+    :special-members:
diff --git a/zpui/docs/output/pcf8574.rst b/zpui/docs/output/pcf8574.rst
new file mode 100644
index 0000000..e560c88
--- /dev/null
+++ b/zpui/docs/output/pcf8574.rst
@@ -0,0 +1,31 @@
+.. _output_pcf8574:
+
+###############################
+PCF8574 I2C LCD backpack driver
+###############################
+
+This driver works with PCF8574 IO expanders. You can see an guide on modifying them and connecting them to LCD screens & I2C `here. <http://www.instructables.com/id/Raspberry-Pi-Using-1-I2C-LCD-Backpacks-for-1602-Sc/>`__
+
+.. code:: json
+
+    "output":
+       [{
+         "driver":"pcf8574",
+         "kwargs":
+          {
+           "addr":"0x3f"
+          }
+       }]
+
+
+.. note:: If you provide backpack's I2C address as a kwarg, you should pass it as a string (as shown above).
+
+To test your screen, you can just run ``python output/driver/pcf8574.py`` while your screen is connected to I2C bus (you might want to adjust parameters in driver's ``if __name__ == "__main__"`` section). It will initialize the screen and show some text on it.
+
+.. toctree::
+
+.. automodule:: output.drivers.pcf8574
+ 
+.. autoclass:: Screen
+    :members:
+    :special-members:
diff --git a/zpui/docs/output/pi_gpio.rst b/zpui/docs/output/pi_gpio.rst
new file mode 100644
index 0000000..ee10aee
--- /dev/null
+++ b/zpui/docs/output/pi_gpio.rst
@@ -0,0 +1,32 @@
+.. _output_pi_gpio:
+
+###############################
+Raspberry Pi GPIO output driver
+###############################
+
+This driver works with HD44780-screens connected to Raspberry Pi GPIO. The screen connected has to have its RW pin tied to ground.
+
+Sample config.json:
+
+.. code:: json
+
+    "output":
+       [{
+         "driver":"pi_gpio",
+         "kwargs":
+          {
+           "pins":[25, 24, 23, 18],
+           "en_pin":4,
+           "en_pin":17
+          }
+       }]
+
+
+
+.. toctree::
+
+.. automodule:: output.drivers.pi_gpio
+ 
+.. autoclass:: Screen
+    :members:
+    :special-members:
diff --git a/zpui/docs/output/pifacecad.rst b/zpui/docs/output/pifacecad.rst
new file mode 100644
index 0000000..d3af0ca
--- /dev/null
+++ b/zpui/docs/output/pifacecad.rst
@@ -0,0 +1,27 @@
+.. _output_pifacecad:
+
+#######################
+PiFaceCAD output driver
+#######################
+
+This driver works with `PiFace Control and Display <www.piface.org.uk/products/piface_control_and_display/>`_ Raspberry Pi shields. 
+
+Sample config.json section:
+
+.. code:: json
+
+    "output":
+       [{
+         "driver":"pfcad"
+       }]
+
+
+.. note:: Generally, you won't need to edit ``config.json`` if you're using this shield because it'll be done automatically by ``config.sh``.
+
+.. toctree::
+
+.. automodule:: output.drivers.pfcad
+ 
+.. autoclass:: Screen
+    :members:
+    :special-members:
diff --git a/zpui/docs/plans.rst b/zpui/docs/plans.rst
new file mode 100644
index 0000000..608e0b9
--- /dev/null
+++ b/zpui/docs/plans.rst
@@ -0,0 +1,70 @@
+#########################
+Future plans
+#########################
+
+A TODO document, if you will. This list might be eventually moved to ZPUI GitHub issues.
+
+.. note:: This list is not by any means complete. What's listed here is bound to appear sooner or later. What's not listed is either not yet considered or not going to be implemented - feel free to ask me at GitHub!
+
+=====================
+Global system changes
+=====================
+
+* Make hotplug of input/output devices possible
+* Include a notification system
+
+==============
+Input devices
+==============
+
+* Make a "passthrough" driver for HID so that a single keyboard can both be used for X and ZPUI
+* Add key remapping to HID driver
+* Pressed/released/held button states
+
+============
+Applications
+============
+
+* Bluetooth app (delayed, involves a lot of DBus work)
+* MPD/Mopidy app
+* Camera app
+* Stopwatch/timer app
+* UCI management app
+* Counter app
+* Calculator app
+* Mount partitions app
+* OpenHAB console
+* Twitter reader
+* SMS and call app - interfacing to mobile phones and GSM/3G modems
+
+============
+UI elements
+============
+
+.. rubric:: Input UI elements
+
+* Date/time picker
+* "Quick reading" UI element (word-by-word)
+* Wraparound for Menu UI element
+
+============
+Development
+============
+
+* More example apps & examples for UI elements
+* Guide about input callbacks and 5 main keys, as well as 30-button numpad
+* An app development course
+* Make a release system
+* More links to UI element usage examples in existing apps
+
+.. rubric:: Integration into projects
+
+* Examples for RPC API wrapper (for integration in any projects running in separate threads)
+
+============
+Maintenance
+============
+
+* Refactor main.py launcher
+* Clean up comments in UI elements, decide what functions to expose in the docs
+* Make an app for configuring ZPUI on the fly
diff --git a/zpui/docs/run_server.py b/zpui/docs/run_server.py
new file mode 100755
index 0000000..874a7d2
--- /dev/null
+++ b/zpui/docs/run_server.py
@@ -0,0 +1,13 @@
+#!/usr/bin/env python
+
+import os
+import sys
+
+os.chdir('_build/html')
+
+if os.fork():
+    sys.exit()
+
+import SimpleHTTPServer
+SimpleHTTPServer.test()
+
diff --git a/zpui/docs/setup.rst b/zpui/docs/setup.rst
new file mode 100644
index 0000000..666d23d
--- /dev/null
+++ b/zpui/docs/setup.rst
@@ -0,0 +1,153 @@
+.. _setup:
+
+Installing and updating ZPUI
+############################
+
+Installing ZPUI on a ZeroPhone
+==============================
+
+ZPUI is installed by default on official ZeroPhone SD card images. However, if 
+for some reason you don't have it installed on your ZeroPhone's SD card, or if you'd like to 
+install ZPUI on some other OS, this is what you have to do:
+
+Installation
+------------
+
+.. code-block:: bash
+
+    git clone https://github.com/ZeroPhone/ZPUI
+    cd ZPUI/
+    #Install main dependencies (apt and pip packages), configure systemd, and create a system-wide ZPUI copy
+    sudo ./setup.sh
+    #Start the system to test your configuration - do screen and buttons work OK?
+    sudo python main.py 
+    #Once tested:
+    sudo ./update.sh #Transfer the working system to your system-wide ZPUI copy
+
+.. admonition:: Behind the scenes
+   :class: note
+
+   There are two ZPUI copies on your system - your local copy, which you downloaded ZPUI into, 
+   and a system-wide copy, which is where ZPUI is launched from when it's started
+   as a service (typically, ``/opt/zpui``).
+   When you run ``./setup.sh``, the system-wide (``/opt/zpui``) ZPUI copy is created,
+   and a ``systemd`` unit file registered to run ZPUI from ``/opt/zpui`` at boot. 
+   The system-wide copy can then be updated from the local copy using the ``./update.sh`` script.
+   If you plan on modifying your ZPUI install, it's suggested you stick to a workflow like this:
+
+   * Make your changes in the local copy
+   * Stop the ZPUI service (to prevent it from grabbing the input&output devices), using ``sudo systemctl stop zpui.service``.
+   * Test your changes in the local directory, using ``sudo python main.py``
+   * If your changes work, transfer them to the system-wide directory using ``sudo ./update.sh``
+
+   Such a workflow is suggested to allow experimentation while making it harder 
+   to lock you out of the system, given that ZPUI is the primary interface for ZeroPhone
+   and if it's inaccessible, it might prevent you from knowing its IP address, 
+   connecting it to a wireless network or turning on SSH.
+   In documentation, ``/opt/zpui`` will be referred to as **system-wide copy**, 
+   while the directory you cloned the repository into will be referred to 
+   as **local copy**.
+
+Updating
+--------
+
+To get new ZPUI changes from GitHub, you can run **"Settings"** -> **"Update ZPUI"** 
+from the main ZPUI menu, which will update the system-wide copy by doing ``git pull``.
+
+If you want to sync your local copy to the system-wide copy, you can run ``update.sh``
+It **1)** automatically pulls new commits from GitHub and **2)** copies all the 
+changes from local directory to the system-wide directory. 
+
+.. tip:: To avoid pulling the new commits from GitHub when running ``./update.sh``, 
+          just comment the corresponding line out from the ``update.sh`` script. 
+
+
+Systemctl commands
+------------------
+
+To control the system-wide ZPUI copy, you can use the following commands:
+
+* ``systemctl start zpui.service``
+* ``systemctl stop zpui.service``
+* ``systemctl status zpui.service``
+
+Launching the system manually
+-----------------------------
+
+For testing configuration or development, you will want to launch ZPUI directly 
+so that you will see the logs and will be able to stop it with a simple Ctrl^C. 
+In that case, just run ZPUI with ``sudo python main.py`` from your local (or system-wide) directory. 
+
+-----------
+
+.. _emulator:
+
+Installing the ZPUI emulator
+============================
+
+.. image:: _static/ZPUI_Emulator.png
+
+If you want to develop ZPUI apps, but don't yet have the ZeroPhone hardware, 
+there's an option to use the emulator with a Linux PC - the emulator can use your 
+screen and keyboard instead of ZeroPhone hardware. The emulator works very well for 
+app development, as well as for UI element and ZPUI core feature development.
+
+System requirements
+-------------------
+
+* Some kind of Linux - there are install instructions for Ubuntu, Debian and OpenSUSE, but it will likely work with other systems, too
+* Graphical environment (the emulator is based on Pygame)
+* A keyboard (the same keyboard that you're using for the system will work great)
+
+Ubuntu/Debian installation
+--------------------------
+
+Assuming Python 2 is the default Python version:
+
+.. code-block:: bash
+
+    sudo apt-get update
+    sudo apt-get install python-pip git python-dev build-essential python-pygame
+    sudo pip install luma.emulator
+    git clone https://github.com/ZeroPhone/ZPUI
+    cd ZPUI
+    ./setup_emulator
+    #Run the emulator
+    python main.py
+
+Arch Linux installation
+-----------------------
+.. code-block:: bash
+
+    sudo pacman -Si python2-pip git python2-pygame
+    sudo pip2 install luma.emulator
+
+    git clone https://github.com/ZeroPhone/ZPUI
+    cd ZPUI
+    ./setup_emulator
+    #Run the emulator
+    python2 main.py
+
+OpenSUSE installation
+---------------------
+
+.. code-block:: bash
+
+    sudo zypper install python2-pip git python2-devel gcc python2-curses python2-pygame #If python2- version is not available, try python- and report on IRC - can't test it now
+    sudo pip2 install luma.emulator
+    git clone https://github.com/ZeroPhone/ZPUI
+    cd ZPUI
+    ./setup_emulator
+    #Run the emulator
+    python2 main.py
+
+Emulator credits
+----------------
+
+Most of the emulator research and work was done by Doug, and later 
+refactored by Brian Dunlay. The input driver was done by Arsenijs. 
+OpenSUSE instructions were compiled with help of `piajesse`_.
+Arch Linux instructions were compiled by `monsieurh`_.
+
+.. _monsieurh: https://github.com/monsieurh
+.. _piajesse: https://hackaday.io/piajesse
diff --git a/zpui/docs/ui.rst b/zpui/docs/ui.rst
new file mode 100644
index 0000000..ddef19f
--- /dev/null
+++ b/zpui/docs/ui.rst
@@ -0,0 +1,33 @@
+####################
+UI element reference
+####################
+
+UI elements are used in applications and some core system functions to interace with the user. For example, the Menu element is used for making menus, and can as well be used to show lists of items.
+
+Using UI elements in your applications is as easy as doing:
+
+``from ui import ElementName``
+
+and initialising them, passing your UI element contents and parameters, as well as input and output device objects as initialisation arguments.
+
+UI elements:
+
+   * :ref:`ui_canvas`
+   * :ref:`ui_menu`
+   * :ref:`ui_printer`
+   * :ref:`ui_refresher`
+   * :ref:`ui_checkbox`
+   * :ref:`ui_number_input`
+   * :ref:`ui_char_input`
+
+.. toctree::
+   :maxdepth: 1
+   :hidden:
+
+   ui/canvas.rst
+   ui/menu.rst
+   ui/printer.rst
+   ui/refresher.rst
+   ui/checkbox.rst
+   ui/number_input.rst
+   ui/char_input.rst
diff --git a/zpui/docs/ui/canvas.rst b/zpui/docs/ui/canvas.rst
new file mode 100644
index 0000000..02cb2c9
--- /dev/null
+++ b/zpui/docs/ui/canvas.rst
@@ -0,0 +1,21 @@
+.. _ui_canvas:
+
+#####################
+Canvas
+#####################
+
+.. code-block:: python
+                      
+    from ui import Canvas
+    ...
+    c = Canvas(o)
+    c.text("Hello world", (10, 20))
+    c.display()
+
+.. automodule:: ui.canvas
+
+.. autoclass:: Canvas
+    :show-inheritance:
+    :members: point,line,text,rectangle,circle,ellipse,polygon,display,clear,get_image,get_center,invert,invert_rect,width,height,size,image,background_color,default_color,get_text_bounds,get_centered_text_bounds,check_coordinates,check_coordinate_pairs,load_font
+
+.. autoclass:: MockOutput
diff --git a/zpui/docs/ui/char_input.rst b/zpui/docs/ui/char_input.rst
new file mode 100644
index 0000000..b1b70d2
--- /dev/null
+++ b/zpui/docs/ui/char_input.rst
@@ -0,0 +1,18 @@
+.. _ui_char_input:
+
+###########################
+Character input UI elements
+###########################
+
+.. code-block:: python
+
+    from ui import CharArrowKeysInput
+    password = CharArrowKeysInput(i, o, message="Password:", name="My password dialog").activate()
+    if password is None: #UI element exited 
+        return False #Cancelling
+    #processing the input you received...
+
+.. automodule:: ui.char_input
+
+.. autoclass:: CharArrowKeysInput
+    :members: __init__,activate,move_up,move_down,move_left,move_right,accept_value,deactivate,print_value,print_name
diff --git a/zpui/docs/ui/checkbox.rst b/zpui/docs/ui/checkbox.rst
new file mode 100644
index 0000000..a6db6c5
--- /dev/null
+++ b/zpui/docs/ui/checkbox.rst
@@ -0,0 +1,19 @@
+.. _ui_checkbox:
+
+#####################
+Checkbox UI element
+#####################
+
+.. code-block:: python
+                      
+    from ui import Checkbox
+    contents = [
+    ["Apples", 'apples'], #"Apples" will not be checked on activation
+    ["Oranges", 'oranges', True], #"Oranges" will be checked on activation
+    ["Bananas", 'bananas']]
+    selected_fruits = Checkbox(checkbox_contents, i, o).activate()
+
+.. automodule:: ui.checkbox
+ 
+.. autoclass:: Checkbox
+    :members: __init__,activate,deactivate,set_contents,print_name,print_contents
diff --git a/zpui/docs/ui/menu.rst b/zpui/docs/ui/menu.rst
new file mode 100644
index 0000000..7b6b3a3
--- /dev/null
+++ b/zpui/docs/ui/menu.rst
@@ -0,0 +1,27 @@
+.. _ui_menu:
+
+#####################
+Menu UI element
+#####################
+
+.. code-block:: python
+                      
+    from ui import Menu
+    ... 
+    menu_contents = [
+    ["Do this", do_this],
+    ["Do this with 20", lambda: do_this(x=20)],
+    ["Do nothing"],
+    ["My submenu", submenu.activate]
+    ]
+    Menu(menu_contents, i, o, "My menu").activate()
+
+.. automodule:: ui
+ 
+.. autoclass:: Menu
+    :show-inheritance:
+    :members: __init__,activate,deactivate,set_contents,print_name,print_contents,pointer,in_background,in_foreground
+    
+.. autoclass:: MenuExitException
+    :show-inheritance:
+
diff --git a/zpui/docs/ui/number_input.rst b/zpui/docs/ui/number_input.rst
new file mode 100644
index 0000000..5a4edfb
--- /dev/null
+++ b/zpui/docs/ui/number_input.rst
@@ -0,0 +1,19 @@
+.. _ui_number_input:
+
+#########################
+Numeric input UI elements
+#########################
+
+.. code-block:: python
+                      
+    from ui import IntegerAdjustInput
+    start_from = 0
+    number = IntegerAdjustInput(start_from, i, o).activate()
+    if number is None: #Input cancelled
+        return
+    #process the number
+
+.. automodule:: ui.number_input
+
+.. autoclass:: IntegerAdjustInput
+    :members: __init__,activate,increment,decrement,reset,select_number,deactivate,print_number,print_name
diff --git a/zpui/docs/ui/printer.rst b/zpui/docs/ui/printer.rst
new file mode 100644
index 0000000..e998981
--- /dev/null
+++ b/zpui/docs/ui/printer.rst
@@ -0,0 +1,19 @@
+.. _ui_printer:
+
+#####################
+Printer UI element
+#####################
+
+.. code-block:: python
+                      
+    from ui import Printer
+    Printer(["Line 1", "Line 2"], i, o, 3, exitable=True)
+    Printer("Long lines will be autosplit", i, o, 1)
+
+.. automodule:: ui.printer
+
+.. autofunction:: Printer
+
+.. autofunction:: PrettyPrinter
+
+.. autofunction:: GraphicsPrinter
diff --git a/zpui/docs/ui/refresher.rst b/zpui/docs/ui/refresher.rst
new file mode 100644
index 0000000..f7e32ea
--- /dev/null
+++ b/zpui/docs/ui/refresher.rst
@@ -0,0 +1,19 @@
+.. _ui_refresher:
+
+#####################
+Refresher UI element
+#####################
+
+.. code-block:: python
+                      
+    from ui import Refresher
+    counter = 0
+    def get_data():
+        counter += 1
+        return [str(counter), str(1000-counter)] #Return value will be sent directly to output.display_data
+    Refresher(get_data, i, o, 1, name="Counter view").activate()
+
+.. automodule:: ui.refresher
+
+.. autoclass:: Refresher
+    :members: __init__,activate,deactivate,print_name
diff --git a/emulator.py b/zpui/emulator.py
similarity index 100%
rename from emulator.py
rename to zpui/emulator.py
diff --git a/helpers/__init__.py b/zpui/helpers/__init__.py
similarity index 100%
rename from helpers/__init__.py
rename to zpui/helpers/__init__.py
diff --git a/helpers/config_parse.py b/zpui/helpers/config_parse.py
similarity index 100%
rename from helpers/config_parse.py
rename to zpui/helpers/config_parse.py
diff --git a/helpers/general.py b/zpui/helpers/general.py
similarity index 100%
rename from helpers/general.py
rename to zpui/helpers/general.py
diff --git a/helpers/logger.py b/zpui/helpers/logger.py
similarity index 100%
rename from helpers/logger.py
rename to zpui/helpers/logger.py
diff --git a/helpers/runners.py b/zpui/helpers/runners.py
similarity index 100%
rename from helpers/runners.py
rename to zpui/helpers/runners.py
diff --git a/helpers/usability.py b/zpui/helpers/usability.py
similarity index 100%
rename from helpers/usability.py
rename to zpui/helpers/usability.py
diff --git a/zpui/input/__init__.py b/zpui/input/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/input/drivers/__init__.py b/zpui/input/drivers/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/input/drivers/adafruit_plate.py b/zpui/input/drivers/adafruit_plate.py
similarity index 100%
rename from input/drivers/adafruit_plate.py
rename to zpui/input/drivers/adafruit_plate.py
diff --git a/input/drivers/custom_i2c.py b/zpui/input/drivers/custom_i2c.py
similarity index 100%
rename from input/drivers/custom_i2c.py
rename to zpui/input/drivers/custom_i2c.py
diff --git a/input/drivers/hid.py b/zpui/input/drivers/hid.py
similarity index 100%
rename from input/drivers/hid.py
rename to zpui/input/drivers/hid.py
diff --git a/input/drivers/max7318.py b/zpui/input/drivers/max7318.py
similarity index 100%
rename from input/drivers/max7318.py
rename to zpui/input/drivers/max7318.py
diff --git a/input/drivers/pcf8574.py b/zpui/input/drivers/pcf8574.py
similarity index 100%
rename from input/drivers/pcf8574.py
rename to zpui/input/drivers/pcf8574.py
diff --git a/input/drivers/pfcad.py b/zpui/input/drivers/pfcad.py
similarity index 100%
rename from input/drivers/pfcad.py
rename to zpui/input/drivers/pfcad.py
diff --git a/input/drivers/pi_gpio.py b/zpui/input/drivers/pi_gpio.py
similarity index 100%
rename from input/drivers/pi_gpio.py
rename to zpui/input/drivers/pi_gpio.py
diff --git a/input/drivers/pi_gpio_matrix.py b/zpui/input/drivers/pi_gpio_matrix.py
similarity index 100%
rename from input/drivers/pi_gpio_matrix.py
rename to zpui/input/drivers/pi_gpio_matrix.py
diff --git a/input/drivers/pygame_input.py b/zpui/input/drivers/pygame_input.py
similarity index 100%
rename from input/drivers/pygame_input.py
rename to zpui/input/drivers/pygame_input.py
diff --git a/input/drivers/skeleton.py b/zpui/input/drivers/skeleton.py
similarity index 100%
rename from input/drivers/skeleton.py
rename to zpui/input/drivers/skeleton.py
diff --git a/input/input.py b/zpui/input/input.py
similarity index 100%
rename from input/input.py
rename to zpui/input/input.py
diff --git a/main.py b/zpui/main.py
similarity index 100%
rename from main.py
rename to zpui/main.py
diff --git a/zpui/output/__init__.py b/zpui/output/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/zpui/output/drivers/__init__.py b/zpui/output/drivers/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/output/drivers/adafruit_plate.py b/zpui/output/drivers/adafruit_plate.py
similarity index 100%
rename from output/drivers/adafruit_plate.py
rename to zpui/output/drivers/adafruit_plate.py
diff --git a/output/drivers/arduino_lcd.py b/zpui/output/drivers/arduino_lcd.py
similarity index 100%
rename from output/drivers/arduino_lcd.py
rename to zpui/output/drivers/arduino_lcd.py
diff --git a/output/drivers/backlight.py b/zpui/output/drivers/backlight.py
similarity index 100%
rename from output/drivers/backlight.py
rename to zpui/output/drivers/backlight.py
diff --git a/output/drivers/hd44780.py b/zpui/output/drivers/hd44780.py
similarity index 100%
rename from output/drivers/hd44780.py
rename to zpui/output/drivers/hd44780.py
diff --git a/output/drivers/luma_driver.py b/zpui/output/drivers/luma_driver.py
similarity index 100%
rename from output/drivers/luma_driver.py
rename to zpui/output/drivers/luma_driver.py
diff --git a/output/drivers/mcp23008.py b/zpui/output/drivers/mcp23008.py
similarity index 100%
rename from output/drivers/mcp23008.py
rename to zpui/output/drivers/mcp23008.py
diff --git a/output/drivers/pcf8574.py b/zpui/output/drivers/pcf8574.py
similarity index 100%
rename from output/drivers/pcf8574.py
rename to zpui/output/drivers/pcf8574.py
diff --git a/output/drivers/pfcad.py b/zpui/output/drivers/pfcad.py
similarity index 100%
rename from output/drivers/pfcad.py
rename to zpui/output/drivers/pfcad.py
diff --git a/output/drivers/pi_gpio.py b/zpui/output/drivers/pi_gpio.py
similarity index 100%
rename from output/drivers/pi_gpio.py
rename to zpui/output/drivers/pi_gpio.py
diff --git a/output/drivers/pygame_emulator.py b/zpui/output/drivers/pygame_emulator.py
similarity index 100%
rename from output/drivers/pygame_emulator.py
rename to zpui/output/drivers/pygame_emulator.py
diff --git a/output/drivers/pygame_emulator_factory.py b/zpui/output/drivers/pygame_emulator_factory.py
similarity index 100%
rename from output/drivers/pygame_emulator_factory.py
rename to zpui/output/drivers/pygame_emulator_factory.py
diff --git a/output/drivers/rw1062.py b/zpui/output/drivers/rw1062.py
similarity index 100%
rename from output/drivers/rw1062.py
rename to zpui/output/drivers/rw1062.py
diff --git a/output/drivers/serial_lcd_0.py b/zpui/output/drivers/serial_lcd_0.py
similarity index 100%
rename from output/drivers/serial_lcd_0.py
rename to zpui/output/drivers/serial_lcd_0.py
diff --git a/output/drivers/sh1106.py b/zpui/output/drivers/sh1106.py
similarity index 100%
rename from output/drivers/sh1106.py
rename to zpui/output/drivers/sh1106.py
diff --git a/output/drivers/ssd1306.py b/zpui/output/drivers/ssd1306.py
similarity index 100%
rename from output/drivers/ssd1306.py
rename to zpui/output/drivers/ssd1306.py
diff --git a/output/output.py b/zpui/output/output.py
similarity index 100%
rename from output/output.py
rename to zpui/output/output.py
diff --git a/splash.py b/zpui/splash.py
similarity index 100%
rename from splash.py
rename to zpui/splash.py
diff --git a/tests/test_context_manager.py b/zpui/tests/test_context_manager.py
similarity index 100%
rename from tests/test_context_manager.py
rename to zpui/tests/test_context_manager.py
diff --git a/ui/__init__.py b/zpui/ui/__init__.py
similarity index 100%
rename from ui/__init__.py
rename to zpui/ui/__init__.py
diff --git a/ui/base_list_ui.py b/zpui/ui/base_list_ui.py
similarity index 100%
rename from ui/base_list_ui.py
rename to zpui/ui/base_list_ui.py
diff --git a/ui/canvas.py b/zpui/ui/canvas.py
similarity index 100%
rename from ui/canvas.py
rename to zpui/ui/canvas.py
diff --git a/ui/char_input.py b/zpui/ui/char_input.py
similarity index 100%
rename from ui/char_input.py
rename to zpui/ui/char_input.py
diff --git a/ui/checkbox.py b/zpui/ui/checkbox.py
similarity index 100%
rename from ui/checkbox.py
rename to zpui/ui/checkbox.py
diff --git a/ui/config_manager.py b/zpui/ui/config_manager.py
similarity index 100%
rename from ui/config_manager.py
rename to zpui/ui/config_manager.py
diff --git a/ui/configs/base_config.json b/zpui/ui/configs/base_config.json
similarity index 100%
rename from ui/configs/base_config.json
rename to zpui/ui/configs/base_config.json
diff --git a/ui/dialog.py b/zpui/ui/dialog.py
similarity index 100%
rename from ui/dialog.py
rename to zpui/ui/dialog.py
diff --git a/ui/experimental/__init__.py b/zpui/ui/experimental/__init__.py
similarity index 100%
rename from ui/experimental/__init__.py
rename to zpui/ui/experimental/__init__.py
diff --git a/ui/experimental/keypad_input.py b/zpui/ui/experimental/keypad_input.py
similarity index 100%
rename from ui/experimental/keypad_input.py
rename to zpui/ui/experimental/keypad_input.py
diff --git a/ui/fonts/Fixedsys62.ttf b/zpui/ui/fonts/Fixedsys62.ttf
similarity index 100%
rename from ui/fonts/Fixedsys62.ttf
rename to zpui/ui/fonts/Fixedsys62.ttf
diff --git a/ui/fonts/Fixedsys62_readme.txt b/zpui/ui/fonts/Fixedsys62_readme.txt
similarity index 100%
rename from ui/fonts/Fixedsys62_readme.txt
rename to zpui/ui/fonts/Fixedsys62_readme.txt
diff --git a/ui/funcs.py b/zpui/ui/funcs.py
similarity index 100%
rename from ui/funcs.py
rename to zpui/ui/funcs.py
diff --git a/ui/input.py b/zpui/ui/input.py
similarity index 100%
rename from ui/input.py
rename to zpui/ui/input.py
diff --git a/ui/listbox.py b/zpui/ui/listbox.py
similarity index 100%
rename from ui/listbox.py
rename to zpui/ui/listbox.py
diff --git a/ui/loading_indicators.py b/zpui/ui/loading_indicators.py
similarity index 100%
rename from ui/loading_indicators.py
rename to zpui/ui/loading_indicators.py
diff --git a/ui/menu.py b/zpui/ui/menu.py
similarity index 100%
rename from ui/menu.py
rename to zpui/ui/menu.py
diff --git a/ui/number_input.py b/zpui/ui/number_input.py
similarity index 100%
rename from ui/number_input.py
rename to zpui/ui/number_input.py
diff --git a/ui/numbered_menu.py b/zpui/ui/numbered_menu.py
similarity index 100%
rename from ui/numbered_menu.py
rename to zpui/ui/numbered_menu.py
diff --git a/ui/numpad_input.py b/zpui/ui/numpad_input.py
similarity index 100%
rename from ui/numpad_input.py
rename to zpui/ui/numpad_input.py
diff --git a/ui/path_picker.py b/zpui/ui/path_picker.py
similarity index 100%
rename from ui/path_picker.py
rename to zpui/ui/path_picker.py
diff --git a/ui/printer.py b/zpui/ui/printer.py
similarity index 100%
rename from ui/printer.py
rename to zpui/ui/printer.py
diff --git a/ui/refresher.py b/zpui/ui/refresher.py
similarity index 100%
rename from ui/refresher.py
rename to zpui/ui/refresher.py
diff --git a/ui/scrollable_element.py b/zpui/ui/scrollable_element.py
similarity index 100%
rename from ui/scrollable_element.py
rename to zpui/ui/scrollable_element.py
diff --git a/ui/tests/canvas_1.png b/zpui/ui/tests/canvas_1.png
similarity index 100%
rename from ui/tests/canvas_1.png
rename to zpui/ui/tests/canvas_1.png
diff --git a/ui/tests/canvas_2.png b/zpui/ui/tests/canvas_2.png
similarity index 100%
rename from ui/tests/canvas_2.png
rename to zpui/ui/tests/canvas_2.png
diff --git a/ui/tests/canvas_3.png b/zpui/ui/tests/canvas_3.png
similarity index 100%
rename from ui/tests/canvas_3.png
rename to zpui/ui/tests/canvas_3.png
diff --git a/ui/tests/canvas_4.png b/zpui/ui/tests/canvas_4.png
similarity index 100%
rename from ui/tests/canvas_4.png
rename to zpui/ui/tests/canvas_4.png
diff --git a/ui/tests/canvas_5.png b/zpui/ui/tests/canvas_5.png
similarity index 100%
rename from ui/tests/canvas_5.png
rename to zpui/ui/tests/canvas_5.png
diff --git a/ui/tests/canvas_6.png b/zpui/ui/tests/canvas_6.png
similarity index 100%
rename from ui/tests/canvas_6.png
rename to zpui/ui/tests/canvas_6.png
diff --git a/ui/tests/canvas_7.png b/zpui/ui/tests/canvas_7.png
similarity index 100%
rename from ui/tests/canvas_7.png
rename to zpui/ui/tests/canvas_7.png
diff --git a/ui/tests/canvas_8.png b/zpui/ui/tests/canvas_8.png
similarity index 100%
rename from ui/tests/canvas_8.png
rename to zpui/ui/tests/canvas_8.png
diff --git a/ui/tests/test_base_list_ui.py b/zpui/ui/tests/test_base_list_ui.py
similarity index 100%
rename from ui/tests/test_base_list_ui.py
rename to zpui/ui/tests/test_base_list_ui.py
diff --git a/ui/tests/test_canvas.py b/zpui/ui/tests/test_canvas.py
similarity index 100%
rename from ui/tests/test_canvas.py
rename to zpui/ui/tests/test_canvas.py
diff --git a/ui/tests/test_char_input.py b/zpui/ui/tests/test_char_input.py
similarity index 100%
rename from ui/tests/test_char_input.py
rename to zpui/ui/tests/test_char_input.py
diff --git a/ui/tests/test_checkbox.py b/zpui/ui/tests/test_checkbox.py
similarity index 100%
rename from ui/tests/test_checkbox.py
rename to zpui/ui/tests/test_checkbox.py
diff --git a/ui/tests/test_config_manager.py b/zpui/ui/tests/test_config_manager.py
similarity index 100%
rename from ui/tests/test_config_manager.py
rename to zpui/ui/tests/test_config_manager.py
diff --git a/ui/tests/test_dialog_box.py b/zpui/ui/tests/test_dialog_box.py
similarity index 100%
rename from ui/tests/test_dialog_box.py
rename to zpui/ui/tests/test_dialog_box.py
diff --git a/ui/tests/test_menu.py b/zpui/ui/tests/test_menu.py
similarity index 100%
rename from ui/tests/test_menu.py
rename to zpui/ui/tests/test_menu.py
diff --git a/ui/tests/test_numpad_input.py b/zpui/ui/tests/test_numpad_input.py
similarity index 100%
rename from ui/tests/test_numpad_input.py
rename to zpui/ui/tests/test_numpad_input.py
diff --git a/ui/tests/test_path_picker.py b/zpui/ui/tests/test_path_picker.py
similarity index 100%
rename from ui/tests/test_path_picker.py
rename to zpui/ui/tests/test_path_picker.py
diff --git a/ui/tests/test_refresher.py b/zpui/ui/tests/test_refresher.py
similarity index 100%
rename from ui/tests/test_refresher.py
rename to zpui/ui/tests/test_refresher.py
diff --git a/ui/tests/test_universal_input.py b/zpui/ui/tests/test_universal_input.py
similarity index 100%
rename from ui/tests/test_universal_input.py
rename to zpui/ui/tests/test_universal_input.py
diff --git a/ui/utils.py b/zpui/ui/utils.py
similarity index 100%
rename from ui/utils.py
rename to zpui/ui/utils.py
diff --git a/utils/README.md b/zpui/utils/README.md
similarity index 100%
rename from utils/README.md
rename to zpui/utils/README.md
diff --git a/utils/__init__.py b/zpui/utils/__init__.py
similarity index 100%
rename from utils/__init__.py
rename to zpui/utils/__init__.py
diff --git a/utils/debug_list_inputs.py b/zpui/utils/debug_list_inputs.py
similarity index 100%
rename from utils/debug_list_inputs.py
rename to zpui/utils/debug_list_inputs.py
diff --git a/utils/debug_listener.py b/zpui/utils/debug_listener.py
similarity index 100%
rename from utils/debug_listener.py
rename to zpui/utils/debug_listener.py
diff --git a/utils/rpc_api.py b/zpui/utils/rpc_api.py
similarity index 100%
rename from utils/rpc_api.py
rename to zpui/utils/rpc_api.py
diff --git a/utils/rpc_client.py b/zpui/utils/rpc_client.py
similarity index 100%
rename from utils/rpc_client.py
rename to zpui/utils/rpc_client.py
